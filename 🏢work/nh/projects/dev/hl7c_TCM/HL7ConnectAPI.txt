using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using HL7Connect;
using HL7Connect.Ccd;
using HL7Connect.Cda;
using HL7Connect.Dicom;
using HL7Connect.Events;
using HL7Connect.Exchange;
using HL7Connect.Kernel;
using HL7Connect.Loinc;
using HL7Connect.Services;
using HL7Connect.Ucum;
using HL7Connect.Util;
using HL7Connect.Utils;
using HL7Connect.V2;
using HL7Connect.Interop;

/*
HL7Connect PIA source ï¿½ Kestral Computing P/L. 

This source file and it's use is covered by the HL7Connect
license agreement. 

About this file
===============

There's a variety of problems associated with importing the 
HL7Connect COM Library in DotNet projects. Whatever means is 
chosen, there's the following problems:
* IStream aliasing issues
* Tlbimp / Tlbimp2 changes the case of methods and properties
  (some up, some down)
* The inheritence structures get flattened out. While this 
  mainly causes conceptual resistence, it's sometimes a technical
  problem
  
HL7Connect is distributed with 3 DotNet related resources:
1. HL7Connect.Interop.dll
  This is the result of running Tlbimp2 on the HL7Connect
	Type Library and aliasing IStream to System.RuntimeInterop.ComTypes. 
  You are welcome to use this dll directly, but we do not support 
  this, as it still has the other problems above
	
2. HL7Connect.API.dll
  This is a generated wrapper that brings across the full
	semantics of the HL7Connect API:
	* The full inheritence structure is exposed
	* lists and sets use System.Collections.Generics
	* Native .Net types are used (especially Stream)
	* The classes are in namespaces to make navigation and
	  understanding easier.
	We support the use of the classes defined in this dll.
	
3. This file, HL7ConnectAPI.cs - the source for HL7Connect.API.dll.
   You can use this directly if you want.
*/

/*
 * Note about the use of Marshall.ReleaseCOMObject and reference counting.
 * 
 *   Any COM interface parameters passed to the DotNet API
 *   by the server are cleaned up using Marshall.ReleaseCOMObject.
 *   If this isn't done, the interface parameters will be released
 *   in DotNet's own sweet time. And it doesn't bother cleaning up 
 *   when it shuts down either. So to avoid reporting DotNet's lazy 
 *   cleanup as real leaks, we always release com objects that are
 *   passed to us. This has the useful side effect of orphaning any
 *   copies of the objects that are still hanging around - the server
 *   wouldn't know what to do with any further use of them anyway.
 *   
 *   This doesn't apply to any COM interfaces generated by request
 *   (such as Access.HL7.CreateMessage()....) - these are managed
 *   by DotNet. Note that these may appear to leak, particularly at
 *   shutdown, as .Net will simply abandon COM interfaces at shutdown.
 *   You can use HL7Connect.Utils.Base.ReleaseCOM() if you want to release objects manally.
 *   
 *   http://msdn.microsoft.com/en-us/magazine/cc163316.aspx
 */

namespace HL7Connect
{

  namespace Utils
  {
    #region Utilities
    // from http://www.sturmnet.org/blog/2005/03/03/cds-csharp-extractor
    // see also http://www.tomergabel.com/ManagedIStreamWrapperForNETCompactFramework20.aspx
    // see also http://hl7connect.blogspot.com/2010/04/c-implementation-of-istream.html

    public class StreamWrapper : IStream
    {
      public StreamWrapper(Stream stream)
      {
        if (stream == null)
          throw new ArgumentNullException("stream", "Can't wrap null stream.");
        this.stream = stream;
      }

      private Stream stream;

      public void Clone(out System.Runtime.InteropServices.ComTypes.IStream ppstm)
      {
        // can't clone in DotNet
        ppstm = null;
        throw new Exception("not implemented");
      }

      public void Commit(int grfCommitFlags)
      {
        // not used by HL7Connect
        throw new Exception("not implemented");
      }

      public void CopyTo(System.Runtime.InteropServices.ComTypes.IStream pstm, long cb, System.IntPtr pcbRead, System.IntPtr pcbWritten)
      {
        // not used by HL7Connect
        throw new Exception("not implemented");
      }

      public void LockRegion(long libOffset, long cb, int dwLockType)
      {
        // not used by HL7Connect
        throw new Exception("not implemented");
      }

      public void Read(byte[] pv, int cb, System.IntPtr pcbRead)
      {
        Marshal.WriteInt32(pcbRead, (Int32)stream.Read(pv, 0, cb));
      }

      public void Revert()
      {
        // not used by HL7Connect
        throw new Exception("not implemented");
      }

      public void Seek(long dlibMove, int dwOrigin, System.IntPtr plibNewPosition)
      {
        Marshal.WriteInt32(plibNewPosition, (int) stream.Seek(dlibMove, (SeekOrigin)dwOrigin));
      }

      public void SetSize(long libNewSize)
      {
        // not used by HL7Connect
        throw new Exception("not implemented");
      }

      public void Stat(out System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag)
      {
        // todo: HL7Connect uses size
        pstatstg = new System.Runtime.InteropServices.ComTypes.STATSTG();
        throw new Exception("not implemented");
      }

      public void UnlockRegion(long libOffset, long cb, int dwLockType)
      {
        // not used by HL7Connect
        throw new Exception("not implemented");
      }

      public void Write(byte[] pv, int cb, System.IntPtr pcbWritten)
      {
        int written = Marshal.ReadInt32(pcbWritten);
        stream.Write(pv, 0, written);
      }
    }

    public class IStreamWrapper : Stream
    {

      IStream stream;

      public IStreamWrapper(IStream stream)
      {
        if (stream == null)
          throw new ArgumentNullException("stream");
        this.stream = stream;
      }

      ~IStreamWrapper()
      {
        Close();
      }


      public override int Read(byte[] buffer, int offset, int count)
      {
        if (offset != 0)
          throw new NotSupportedException("only 0 offset is supported");
        if (buffer.Length < count)
          throw new NotSupportedException("buffer is not large enough");

        IntPtr bytesRead = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(int)));
        try
        {
          stream.Read(buffer, count, bytesRead);
          return Marshal.ReadInt32(bytesRead);
        }
        finally
        {
          Marshal.FreeCoTaskMem(bytesRead);
        }

        /* unsafe variation
          int bytesRead;
          IntPtr address = new IntPtr(&bytesRead);
          stream.Read(buffer, count, address);
          return bytesRead; */
      }


      public override void Write(byte[] buffer, int offset, int count)
      {
        if (offset != 0)
          throw new NotSupportedException("only 0 offset is supported");
        stream.Write(buffer, count, IntPtr.Zero);
      }

      public override long Seek(long offset, SeekOrigin origin)
      {
        IntPtr address = Marshal.AllocCoTaskMem(Marshal.SizeOf(typeof(int)));
        try
        {
          stream.Seek(offset, (int)origin, address);
          return Marshal.ReadInt32(address);
        }
        finally
        {
          Marshal.FreeCoTaskMem(address);
        }

        /* unsafe variation
        long position = 0;
        IntPtr address = new IntPtr(&position);
        stream.Seek(offset, (int)origin, address);
        return position;
         */
      }


      public override long Length
      {
        get
        {
          System.Runtime.InteropServices.ComTypes.STATSTG statstg;
          stream.Stat(out statstg, 1 /* STATSFLAG_NONAME*/ );
          return statstg.cbSize;
        }
      }

      public override long Position
      {
        get { return Seek(0, SeekOrigin.Current); }
        set { Seek(value, SeekOrigin.Begin); }
      }


      public override void SetLength(long value)
      {
        stream.SetSize(value);
      }

      public override void Close()
      {
        stream.Commit(0);
        // Marshal.ReleaseComObject(stream);
        stream = null;
        GC.SuppressFinalize(this);
      }

      public override void Flush()
      {
        stream.Commit(0);
      }

      public override bool CanRead
      {
        get { return true; }
      }

      public override bool CanWrite
      {
        get { return true; }
      }

      public override bool CanSeek
      {
        get { return true; }
      }

      public static byte[] IStreamToBytes(IStream source)
      {
        if (source == null)
          return null;

        Stream stream = new IStreamWrapper(source);
        byte[] result = new byte[(int)stream.Length];
        stream.Read(result, 0, (int)stream.Length);
        return result;
      }
    }

    [type: ComVisible(true)]
    public class Base
    {
      internal Object com;

      internal Base(Object com)
      {
        this.com = com;
      }

      internal Object wrapped() { return com; }

      /// <summary>
      ///   Wraps Marshal.ReleaseComObject() for Base which is the base for all the API wrapping classes.
      ///   For further information, see note in HL7Connect Documentation - search for Memory Management
      /// </summary>
      /// <param name="b">The Object whose COM reference should be released</param>
      public void ReleaseCOM(Base b)
      {
        Marshal.ReleaseComObject(b.com);
      }

    }

    public class StringListWrapper : IList<string>
    {
      private IStringList com;

      public StringListWrapper(IStringList com)
      {
        this.com = com;
      }

      public string this[int index]
      {
        get { return com.GetItems(index); }
        set { com.SetItems(index, value); }
      }

      public int IndexOf(string item)
      {
        return com.IndexOf(item);
      }

      public void Insert(int index, string item)
      {
        com.insert(index, item);
      }

      public void RemoveAt(int index)
      {
        com.delete(index);
      }

      public int Count { get { return com.Count; } }

      public bool IsReadOnly { get { return false; } }

      public void Add(string item)
      {
        com.Add(item);
      }

      public void Clear()
      {
        com.Clear();
      }

      public bool Contains(string item)
      {
        return com.IndexOf(item) > -1;
      }

      public void CopyTo(string[] array, int arrayIndex)
      {
        var l = com.Count;
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be " + (arrayIndex + l).ToString() + " in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = com.Items[i];
      }

      public bool Remove(string item)
      {
        var i = com.IndexOf(item);
        if (i > -1)
          com.delete(i);
        return i > -1;
      }

      public class StringListWrapperEnumerator : IEnumerator<string>
      {
        private IStringList com;
        int index = -1;

        public StringListWrapperEnumerator(IStringList com)
        {
          this.com = com;
        }

        public string Current { get { return com.Items[index]; } }

        public void Dispose() { }


        public bool MoveNext()
        {
          index++;
          return index < com.Count;
        }

        public void Reset()
        {
          index = -1;
        }

        object System.Collections.IEnumerator.Current
        {
          get { { return com.Items[index]; } }
        }

      }

      public IEnumerator<string> GetEnumerator()
      {
        return new StringListWrapperEnumerator(com);
      }

      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new StringListWrapperEnumerator(com);
      }

    }

    public interface IHL7ConnectList<T> : IList<T>
    {
      /// <summary>
      ///   Create a new item to go in the list. Caution: when the item in the list is polymorphic, this is not a very useful method. However most lists aren't polymorphic, and this is pretty useful
      /// </summary>
      /// <returns></returns>
      T Append();
    }

    #endregion Utilities
  }

  #region Generated Code

  namespace Events
  {
    ///<summary>
    /// Base class for events; never actually passed to a program
    ///</summary>
    public class Base : HL7Connect.Utils.Base
    {

      internal Base(IScriptEvent com) : base(com) {} 

      internal new HCScriptEvent wrapped() { return (HCScriptEvent) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The Name of the event
      ///</summary>
      private string propGetEventName()
      {
        return wrapped().EventName;
      }
      ///<summary>
      /// The Name of the event
      ///</summary>
      public string EventName { get { return propGetEventName(); } }

      ///<summary>
      /// The string parameter the entered for the script parameter in script configuration
      ///</summary>
      private string propGetParameter()
      {
        return wrapped().Parameter;
      }
      ///<summary>
      /// The string parameter the entered for the script parameter in script configuration
      ///</summary>
      public string Parameter { get { return propGetParameter(); } }

      ///<summary>
      /// True if this is just a test case (useful for debugging)
      ///</summary>
      private bool propGetIsTestCase()
      {
        return wrapped().IsTestCase != 0;
      }
      ///<summary>
      /// True if this is just a test case (useful for debugging)
      ///</summary>
      public bool IsTestCase { get { return propGetIsTestCase(); } }

    }

    ///<summary>
    /// Called by the File Interface when it needs to convert a line of ascii text into a message
    ///</summary>
    public class ConvertText : HL7Connect.Events.Base
    {

      internal ConvertText(IHL7ConvertEvent com) : base(com) {} 

      internal new HCHL7ConvertEvent wrapped() { return (HCHL7ConvertEvent) com; }

      ///<summary>
      /// Blank message that the script needs to populate
      ///</summary>
      private HL7Connect.V2.Message propGetMsg()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Msg);
      }
      ///<summary>
      /// Blank message that the script needs to populate
      ///</summary>
      public HL7Connect.V2.Message Msg { get { return propGetMsg(); } }

      ///<summary>
      /// Raw contents of the line
      ///</summary>
      private string propGetRawLine()
      {
        return wrapped().RawLine;
      }
      ///<summary>
      /// Raw contents of the line
      ///</summary>
      public string RawLine { get { return propGetRawLine(); } }

      ///<summary>
      /// persistent within the context of an incoming interface. Whatever the value of this at the end of the event, this is the value it will have at the start of the next event. Note that this will carry over at the end of a file. You can use this in conjunction with the HasMessage property to suppress production of a message for a line and then to use the content of this line when processing the next.
      ///</summary>
      private string propGetCarryOver()
      {
        return wrapped().CarryOver;
      }
      private void propSetCarryOver(string value)
      {
        wrapped().CarryOver = value;
      }
      ///<summary>
      /// persistent within the context of an incoming interface. Whatever the value of this at the end of the event, this is the value it will have at the start of the next event. Note that this will carry over at the end of a file. You can use this in conjunction with the HasMessage property to suppress production of a message for a line and then to use the content of this line when processing the next.
      ///</summary>
      public string CarryOver { get { return propGetCarryOver(); } set { propSetCarryOver(value); } }

      ///<summary>
      /// Default is true. If this is true, then a valid message is produced by the script processing the event. If it is false, then the contents of Msg will be ignored
      ///</summary>
      private bool propGetHasMessage()
      {
        return wrapped().HasMessage != 0;
      }
      private void propSetHasMessage(bool value)
      {
        wrapped().HasMessage = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Default is true. If this is true, then a valid message is produced by the script processing the event. If it is false, then the contents of Msg will be ignored
      ///</summary>
      public bool HasMessage { get { return propGetHasMessage(); } set { propSetHasMessage(value); } }

      ///<summary>
      /// If the interface is able to determine that the line is comma or tab delimited, then this StringList will be populated with the fields starting at #0
      ///</summary>
      private IList<String> propGetFields()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().Fields);
      }
      ///<summary>
      /// If the interface is able to determine that the line is comma or tab delimited, then this StringList will be populated with the fields starting at #0
      ///</summary>
      public IList<String> Fields { get { return propGetFields(); } }

    }

    ///<summary>
    /// Called by a File Interface when it has an HL7 Message it needs to convert to ascii text. 
    /// 
    /// The script has the option to populate the RawLine variable, or to fill the fields list, in which case RawLine will be ignored
    ///</summary>
    public class BuildText : HL7Connect.Events.Base
    {

      internal BuildText(IHL7BuildEvent com) : base(com) {} 

      internal new HCHL7BuildEvent wrapped() { return (HCHL7BuildEvent) com; }

      ///<summary>
      /// Sequential File Message Counter. First message in a file will have value 1
      ///</summary>
      private int propGetFileOffset()
      {
        return wrapped().FileOffset;
      }
      ///<summary>
      /// Sequential File Message Counter. First message in a file will have value 1
      ///</summary>
      public int FileOffset { get { return propGetFileOffset(); } }

      ///<summary>
      /// message containing the content to be converted to text
      ///</summary>
      private HL7Connect.V2.Message propGetMsg()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Msg);
      }
      ///<summary>
      /// message containing the content to be converted to text
      ///</summary>
      public HL7Connect.V2.Message Msg { get { return propGetMsg(); } }

      ///<summary>
      /// Raw contents of the line
      ///</summary>
      private string propGetRawLine()
      {
        return wrapped().RawLine;
      }
      private void propSetRawLine(string value)
      {
        wrapped().RawLine = value;
      }
      ///<summary>
      /// Raw contents of the line
      ///</summary>
      public string RawLine { get { return propGetRawLine(); } set { propSetRawLine(value); } }

      ///<summary>
      /// Seperator if Fields are used
      ///</summary>
      private char propGetSeparatorChar()
      {
        return wrapped().SeparatorChar[0];
      }
      private void propSetSeparatorChar(char value)
      {
        wrapped().SeparatorChar = value.ToString();
      }
      ///<summary>
      /// Seperator if Fields are used
      ///</summary>
      public char SeparatorChar { get { return propGetSeparatorChar(); } set { propSetSeparatorChar(value); } }

      ///<summary>
      /// Empty List of fields. If any content is put in here, then RawLine will be ignored, and the contents built from this Field list
      ///</summary>
      private IList<String> propGetFields()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().Fields);
      }
      ///<summary>
      /// Empty List of fields. If any content is put in here, then RawLine will be ignored, and the contents built from this Field list
      ///</summary>
      public IList<String> Fields { get { return propGetFields(); } }

    }

    ///<summary>
    /// This event is called whenever an interface is configured to perform script validation of messages. The script should set the Error property of the event if there is a problem with the message
    ///</summary>
    public class ValidateMessage : HL7Connect.Events.Base
    {

      internal ValidateMessage(IValidationEvent com) : base(com) {} 

      internal new HCValidationEvent wrapped() { return (HCValidationEvent) com; }

      ///<summary>
      /// The Message which must be validated.
      ///</summary>
      private HL7Connect.V2.Message propGetMsg()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Msg);
      }
      ///<summary>
      /// The Message which must be validated.
      ///</summary>
      public HL7Connect.V2.Message Msg { get { return propGetMsg(); } }

      ///<summary>
      /// Error to return from validation (empty = no error).
      ///</summary>
      private string propGetErrors()
      {
        return wrapped().Errors;
      }
      private void propSetErrors(string value)
      {
        wrapped().Errors = value;
      }
      ///<summary>
      /// Error to return from validation (empty = no error).
      ///</summary>
      public string Errors { get { return propGetErrors(); } set { propSetErrors(value); } }

    }

    ///<summary>
    /// This event is called whenever a CDA interface is configured to perform script validation of documents. The script should set the Error property of the event if there is a problem with the document
    ///</summary>
    public class ValidationDocument : HL7Connect.Events.Base
    {

      internal ValidationDocument(ICDAValidationEvent com) : base(com) {} 

      internal new HCCDAValidationEvent wrapped() { return (HCCDAValidationEvent) com; }

      ///<summary>
      /// The Document which must be validated.
      ///</summary>
      private HL7Connect.Cda.ClinicalDocument propGetDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().Document);
      }
      ///<summary>
      /// The Document which must be validated.
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument Document { get { return propGetDocument(); } }

      ///<summary>
      /// Error to return from validation (empty = no error).
      ///</summary>
      private string propGetErrors()
      {
        return wrapped().Errors;
      }
      private void propSetErrors(string value)
      {
        wrapped().Errors = value;
      }
      ///<summary>
      /// Error to return from validation (empty = no error).
      ///</summary>
      public string Errors { get { return propGetErrors(); } set { propSetErrors(value); } }

    }

    ///<summary>
    /// This event is called manually by a user through the web interface. It may be called to simply execute, or it may be called to execute against an interface, a message, or a document. You can use the Kind Property to determine which it is being run against.
    ///</summary>
    public class UserInitiated : HL7Connect.Events.Base
    {

      internal UserInitiated(IUserInitiatedEvent com) : base(com) {} 

      internal new HCUserInitiatedEvent wrapped() { return (HCUserInitiatedEvent) com; }

      ///<summary>
      /// What kind of context this script is running in 
      /// 
      /// -- List of types of user initiated events EventGeneralEventInterfaceEventMessageEventDocument
      ///</summary>
      private TUserInitiatedEventKind propGetKind()
      {
        return wrapped().Kind;
      }
      ///<summary>
      /// What kind of context this script is running in 
      /// 
      /// -- List of types of user initiated events EventGeneralEventInterfaceEventMessageEventDocument
      ///</summary>
      public TUserInitiatedEventKind Kind { get { return propGetKind(); } }

      ///<summary>
      /// The Message passed to the script - if Kind = EventMessage
      ///</summary>
      private HL7Connect.V2.Message propGetMsg()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Msg);
      }
      ///<summary>
      /// The Message passed to the script - if Kind = EventMessage
      ///</summary>
      public HL7Connect.V2.Message Msg { get { return propGetMsg(); } }

      ///<summary>
      /// The Document passed to the script - if Kind = EventDocument
      ///</summary>
      private HL7Connect.Cda.ClinicalDocument propGetDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().Document);
      }
      ///<summary>
      /// The Document passed to the script - if Kind = EventDocument
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument Document { get { return propGetDocument(); } }

      ///<summary>
      /// The interface passed to the script - if Kind = EventInterface
      ///</summary>
      private HL7Connect.Kernel.Interface propGetIface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().Iface);
      }
      ///<summary>
      /// The interface passed to the script - if Kind = EventInterface
      ///</summary>
      public HL7Connect.Kernel.Interface Iface { get { return propGetIface(); } }

    }

    ///<summary>
    /// This event is called when the kernel has finised loading and immediately before the kernel starts. This event will not be called if "no interfaces start automatically" is selected in the HL7Connect Manager, to allow the administrator to successfully start HL7Connect to change a bad startup script
    ///</summary>
    public class KernelStart : HL7Connect.Events.Base
    {

      internal KernelStart(IKernelStartEvent com) : base(com) {} 

      internal new HCKernelStartEvent wrapped() { return (HCKernelStartEvent) com; }

    }

    ///<summary>
    /// This event is called after all interfaces have stopped or been terminated, but before the internal modules such as the database layer are shutdown
    ///</summary>
    public class KernelStop : HL7Connect.Events.Base
    {

      internal KernelStop(IKernelStopEvent com) : base(com) {} 

      internal new HCKernelStopEvent wrapped() { return (HCKernelStopEvent) com; }

      ///<summary>
      /// true if the whole system is shutting down
      ///</summary>
      private bool propGetSystemShutdown()
      {
        return wrapped().SystemShutdown != 0;
      }
      ///<summary>
      /// true if the whole system is shutting down
      ///</summary>
      public bool SystemShutdown { get { return propGetSystemShutdown(); } }

    }

    ///<summary>
    /// Base event class for RAS related events
    ///</summary>
    public class RASBase : HL7Connect.Events.Base
    {

      internal RASBase(IRASEvent com) : base(com) {} 

      internal new HCRASEvent wrapped() { return (HCRASEvent) com; }

      ///<summary>
      /// handle to RAS Connection that changed status
      ///</summary>
      private HL7Connect.Kernel.RASConnection propGetConnection()
      {
        return HL7Connect.Kernel.WrapperFactory.RASConnection(wrapped().Connection);
      }
      ///<summary>
      /// handle to RAS Connection that changed status
      ///</summary>
      public HL7Connect.Kernel.RASConnection Connection { get { return propGetConnection(); } }

    }

    ///<summary>
    /// Called when a RAS connection is established. Not implemented yet
    ///</summary>
    public class RASConnect : HL7Connect.Events.RASBase
    {

      internal RASConnect(IRASConnectEvent com) : base(com) {} 

      internal new HCRASConnectEvent wrapped() { return (HCRASConnectEvent) com; }

    }

    ///<summary>
    /// Called when a RAS connection is disconnected/lost. Not implemented yet
    ///</summary>
    public class RASDisconnect : HL7Connect.Events.RASBase
    {

      internal RASDisconnect(IRASDisconnectEvent com) : base(com) {} 

      internal new HCRASDisconnectEvent wrapped() { return (HCRASDisconnectEvent) com; }

    }

    ///<summary>
    /// Called by an incoming scripted message interface basis. If the script determines that a message is to be generated, then it should create one (using Kernel.CreateHL7Message or one of it's variants) and send it using the Event's SendMessage method 
    /// 
    /// The script is called under two different circumstances (as configured). Either it is called on a regular schedule, or it is called when there are items in the virtual queue to be processed. If the event is called because there is a message or document in a virtual queue, then one of the IncomingMessage, IncomingDocument or IncomingDicom properties will be non-null, and the script must set IncomingHandled to true - or else the same item will be processed repeatedly Note that this is the one place in HL7Connect where documents, messages and DICOM Images can mix - this event requires an outgoing message, but one of documents, messages or images will come in, depending on the configuration of the interface KScript: the generated content is sent to the kernel as a v2.xml message (One message per execution). IncomingHandled is set to true if the script executes and the message is accepted. Note: KScript is not configured to work usefully with incoming dicom messages at this time.
    ///</summary>
    public class CheckMessage : HL7Connect.Events.Base
    {

      internal CheckMessage(ICheckMessageEvent com) : base(com) {} 

      internal new HCCheckMessageEvent wrapped() { return (HCCheckMessageEvent) com; }

      ///<summary>
      /// Send the message to the kernel as a new incoming message. The return value of the function is the Kernel's HL7 response
      ///</summary>
      public HL7Connect.V2.Message SendMessage(HL7Connect.V2.Message AMessage)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().SendMessage(AMessage.wrapped()));
      }

      ///<summary>
      /// Send the message to the kernel as a new incoming message. The second parameter is passed to any incoming scripts as the source parameter on the event The return value of the function is the Kernel's HL7 response
      ///</summary>
      public HL7Connect.V2.Message SendMessageEx(HL7Connect.V2.Message AMessage, string ASourceParameter)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().SendMessageEx(AMessage.wrapped(), ASourceParameter));
      }

      ///<summary>
      /// The message that is being handled, if the event is being called because a message has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      private HL7Connect.Exchange.Message propGetIncomingMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().IncomingMessage);
      }
      ///<summary>
      /// The message that is being handled, if the event is being called because a message has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      public HL7Connect.Exchange.Message IncomingMessage { get { return propGetIncomingMessage(); } }

      ///<summary>
      /// The Document that is being handled, if the event is being called because a Document has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      private HL7Connect.Exchange.Document propGetIncomingDocument()
      {
        return HL7Connect.Exchange.WrapperFactory.Document(wrapped().IncomingDocument);
      }
      ///<summary>
      /// The Document that is being handled, if the event is being called because a Document has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      public HL7Connect.Exchange.Document IncomingDocument { get { return propGetIncomingDocument(); } }

      ///<summary>
      /// The Dicom Message that is being handled, if the event is being called because a Dicom Message has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      private HL7Connect.Exchange.DicomMessage propGetIncomingDicom()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomMessage(wrapped().IncomingDicom);
      }
      ///<summary>
      /// The Dicom Message that is being handled, if the event is being called because a Dicom Message has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      public HL7Connect.Exchange.DicomMessage IncomingDicom { get { return propGetIncomingDicom(); } }

      ///<summary>
      /// If the event is being called in response to a message or document in a virtual queue, this must be set to true to tell the kernel to remove the message from the virtual queue - else the script will be called again indefinitely. 
      /// 
      /// You can safely leave IncomingHandled = false; there is always a short break (at least 1 second) before repeating the script after IncomingHandled is false to keep the load on the system down
      ///</summary>
      private bool propGetIncomingHandled()
      {
        return wrapped().IncomingHandled != 0;
      }
      private void propSetIncomingHandled(bool value)
      {
        wrapped().IncomingHandled = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// If the event is being called in response to a message or document in a virtual queue, this must be set to true to tell the kernel to remove the message from the virtual queue - else the script will be called again indefinitely. 
      /// 
      /// You can safely leave IncomingHandled = false; there is always a short break (at least 1 second) before repeating the script after IncomingHandled is false to keep the load on the system down
      ///</summary>
      public bool IncomingHandled { get { return propGetIncomingHandled(); } set { propSetIncomingHandled(value); } }

    }

    ///<summary>
    /// Called by an incoming scripted message interface basis. If the script determines that a message is to be generated, then it should create one and send it using the SendMessage method 
    /// 
    /// The script is called under two different circumstances (as configured). Either it is called on a regular schedule, or it is called when there are items in the virtual queue to be processed. If the event is called because there is a message or document in a virtual queue, then either the IncomingMessage or IncomingDocument properties will be non-null, and the script must set IncomingHandled to true - or else the same message will be processed repeatedly Note that this is the one place in HL7Connect where documents and messages can mix - this event requires an outgoing message, but either documents or messages will come in, depending on the configuration of the interface KScript: the generated content is sent to the kernel as a document (One document per execution). IncomingHandled is set to true if the script executes and the message is accepted.
    ///</summary>
    public class CheckDocument : HL7Connect.Events.Base
    {

      internal CheckDocument(ICheckDocumentEvent com) : base(com) {} 

      internal new HCCheckDocumentEvent wrapped() { return (HCCheckDocumentEvent) com; }

      ///<summary>
      /// Start building a CDA document. The document is created, but no properties are set other than the mandatory typeId.
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument MakeDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().MakeDocument());
      }

      ///<summary>
      /// Use the CCD builder with a document. 
      /// 
      /// The CCD builder wraps the CDA document with a set of object builders based on the CCD specification. The CCD builder builds the CDA document in the background. Note that you can work with either the CDA document or the CCD builder, and you can mix the use. In fact, you have to, since the CCD specification makes a set of rules about how to use the CDA document, but it is incomplete. Important note: when the CCD Builder works with the lists, it keeps links into the underlying CDA list. For exxample, the CCD builder uses the section list. If you add a section through the CCD builder, but then delete the section in the underlying document, unpredictable effects will result. Either use the CCD Builder to add sections, or reset the CCD Builder list if you edit the sections directly. If you set build = true, then the CCD Builder will (re)initialise the document, ensuring that it conforms to the CCD specification to the degree possible as information is possible. If you set build = false, the CCD builder will read the document to the degree possible, and then you can edit/update the document.
      ///</summary>
      public HL7Connect.Ccd.Builder UseCCD(HL7Connect.Cda.ClinicalDocument oDocument, bool bBuild)
      {
        return HL7Connect.Ccd.WrapperFactory.Builder(wrapped().UseCCD(oDocument.wrapped(), bBuild ? (sbyte) 0 : (sbyte) -1));
      }

      ///<summary>
      /// Send the Document to the kernel as a new incoming Document. 
      /// 
      /// If sending the document fails, an exception will be thrown
      ///</summary>
      public void SendDocument(HL7Connect.Cda.ClinicalDocument ADocument)
      {
        wrapped().SendDocument(ADocument.wrapped());
      }

      ///<summary>
      /// Send the Document to the kernel as a new incoming Document. The second parameter is passed to any incoming scripts as the source parameter on the event 
      /// 
      /// If sending the document fails, an exception will be thrown
      ///</summary>
      public void SendDocumentEx(HL7Connect.Cda.ClinicalDocument ADocument, string ASourceParameter)
      {
        wrapped().SendDocumentEx(ADocument.wrapped(), ASourceParameter);
      }

      ///<summary>
      /// The message that is being handled, if the event is being called because a message has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      private HL7Connect.Exchange.Message propGetIncomingMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().IncomingMessage);
      }
      ///<summary>
      /// The message that is being handled, if the event is being called because a message has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      public HL7Connect.Exchange.Message IncomingMessage { get { return propGetIncomingMessage(); } }

      ///<summary>
      /// The Document that is being handled, if the event is being called because a Document has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      private HL7Connect.Exchange.Document propGetIncomingDocument()
      {
        return HL7Connect.Exchange.WrapperFactory.Document(wrapped().IncomingDocument);
      }
      ///<summary>
      /// The Document that is being handled, if the event is being called because a Document has been queued to a virtual queue that the incoming scripted interface is triggered on.
      ///</summary>
      public HL7Connect.Exchange.Document IncomingDocument { get { return propGetIncomingDocument(); } }

      ///<summary>
      /// If the event is being called in response to a message or document in a virtual queue, this must be set to true to tell the kernel to remove the message from the virtual queue - else the script will be called again indefinitely. 
      /// 
      /// You can safely leave IncomingHandled = false; there is always a short break (at least 1 second) before repeating the script after IncomingHandled is false to keep the load on the system down
      ///</summary>
      private bool propGetIncomingHandled()
      {
        return wrapped().IncomingHandled != 0;
      }
      private void propSetIncomingHandled(bool value)
      {
        wrapped().IncomingHandled = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// If the event is being called in response to a message or document in a virtual queue, this must be set to true to tell the kernel to remove the message from the virtual queue - else the script will be called again indefinitely. 
      /// 
      /// You can safely leave IncomingHandled = false; there is always a short break (at least 1 second) before repeating the script after IncomingHandled is false to keep the load on the system down
      ///</summary>
      public bool IncomingHandled { get { return propGetIncomingHandled(); } set { propSetIncomingHandled(value); } }

    }

    ///<summary>
    /// Called by an outgoing scripted message interface when a message is to be sent. The script must populate a reply message, and set the return status.
    ///</summary>
    public class SendScriptMessage : HL7Connect.Events.Base
    {

      internal SendScriptMessage(ISendScriptMessageEvent com) : base(com) {} 

      internal new HCSendScriptMessageEvent wrapped() { return (HCSendScriptMessageEvent) com; }

      ///<summary>
      /// A handle to the message that is being sent. The script is responsible for what happens to the message when this event is used.
      ///</summary>
      private HL7Connect.V2.Message propGetOutMessage()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().OutMessage);
      }
      ///<summary>
      /// A handle to the message that is being sent. The script is responsible for what happens to the message when this event is used.
      ///</summary>
      public HL7Connect.V2.Message OutMessage { get { return propGetOutMessage(); } }

      ///<summary>
      /// A handle to a prebuilt ACK answer message to the message to be sent. If the script wants, it can modify this message. If an error condition arises, the script can throw an exception, which will be treated as a message error (AE) by the kernel. If this doesn't give quite enough control over the kernel behaviour, the script can change the values of the MSA segment of the ReplyMessage
      ///</summary>
      private HL7Connect.V2.Message propGetReplyMessage()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().ReplyMessage);
      }
      ///<summary>
      /// A handle to a prebuilt ACK answer message to the message to be sent. If the script wants, it can modify this message. If an error condition arises, the script can throw an exception, which will be treated as a message error (AE) by the kernel. If this doesn't give quite enough control over the kernel behaviour, the script can change the values of the MSA segment of the ReplyMessage
      ///</summary>
      public HL7Connect.V2.Message ReplyMessage { get { return propGetReplyMessage(); } }

    }

    ///<summary>
    /// Called by an outgoing scripted Document interface when a Document is to be sent. The script must populate the response (which is already created)
    ///</summary>
    public class SendScriptDocument : HL7Connect.Events.Base
    {

      internal SendScriptDocument(ISendScriptDocumentEvent com) : base(com) {} 

      internal new HCSendScriptDocumentEvent wrapped() { return (HCSendScriptDocumentEvent) com; }

      ///<summary>
      /// A handle to the Document that is being sent. The script is responsible for what happens to the Document when this event is used.
      ///</summary>
      private HL7Connect.Cda.ClinicalDocument propGetOutDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().OutDocument);
      }
      ///<summary>
      /// A handle to the Document that is being sent. The script is responsible for what happens to the Document when this event is used.
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument OutDocument { get { return propGetOutDocument(); } }

      ///<summary>
      /// How HL7Connect should process the response document
      ///</summary>
      private HL7Connect.Exchange.DocumentResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DocumentResponse(wrapped().Response);
      }
      ///<summary>
      /// How HL7Connect should process the response document
      ///</summary>
      public HL7Connect.Exchange.DocumentResponse Response { get { return propGetResponse(); } }

    }

    ///<summary>
    /// Base class for interface related events
    ///</summary>
    public class InterfaceBase : HL7Connect.Events.Base
    {

      internal InterfaceBase(IInterfaceEvent com) : base(com) {} 

      internal new HCInterfaceEvent wrapped() { return (HCInterfaceEvent) com; }

      ///<summary>
      /// Handle the interface object
      ///</summary>
      private HL7Connect.Kernel.Interface propGetIface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().Iface);
      }
      ///<summary>
      /// Handle the interface object
      ///</summary>
      public HL7Connect.Kernel.Interface Iface { get { return propGetIface(); } }

    }

    ///<summary>
    /// This event is called when an interface starts. 
    /// 
    /// Note that there is 2 levels of start. One, the kernel starts the interface (by user prompting, for instance). Then the actual transport layer is allowed to start. This event will only be called when the actual transport layer indicates to the kernel that it has successfully started. Some carriers (file, http, email) will do this immediately. The LLP carrier will call this event whenever the remote system actually connects. In the context of the LLP interface this could better be called "OnInterfaceConnect"
    ///</summary>
    public class InterfaceStart : HL7Connect.Events.InterfaceBase
    {

      internal InterfaceStart(IInterfaceStartEvent com) : base(com) {} 

      internal new HCInterfaceStartEvent wrapped() { return (HCInterfaceStartEvent) com; }

    }

    ///<summary>
    /// This event is called when the interface stops. As with the OnInterfaceStart event, this is called when the transport layer stops, not when the user stops the interface (although these often happen at the same time). Again, with the LLP carrier, this will happen when the remote system disconnects
    ///</summary>
    public class InterfaceStop : HL7Connect.Events.InterfaceBase
    {

      internal InterfaceStop(IInterfaceStopEvent com) : base(com) {} 

      internal new HCInterfaceStopEvent wrapped() { return (HCInterfaceStopEvent) com; }

    }

    ///<summary>
    /// This event is called when a message is received from an interface and the message has passed the sequence numbering and HL7 Validation checks. It exists to allow the user to impose custom validation checks, do message translation, and send the messages to interfaces or virtual queues. 
    /// 
    /// The event handler can do anything it wants with the Message but it must leave it parsable and with the compulsory headers in the MSH populated. If the interface wishes to reject the message, it should set ErrorMessage and optionally ErrorCode The message is logged prior to this event. XSLT: the input is the original message, the output replaces the original message
    ///</summary>
    public class ReceiveMessage : HL7Connect.Events.InterfaceBase
    {

      internal ReceiveMessage(IReceiveMessageEvent com) : base(com) {} 

      internal new HCReceiveMessageEvent wrapped() { return (HCReceiveMessageEvent) com; }

      ///<summary>
      /// Call this to tell HL7Connect to reject the message. A NACK message will be built based on the information provided in this call. 
      /// 
      /// The code is one of the nuemrical codes that goes in MSA-6
      ///</summary>
      public void SetError(string Code, string Message)
      {
        wrapped().SetError(Code, Message);
      }

      ///<summary>
      /// Send the message to the named (message) interface. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the message to the named (message) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the message to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the message to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the actual message received
      ///</summary>
      private HL7Connect.Exchange.Message propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().Message);
      }
      ///<summary>
      /// A handle to the actual message received
      ///</summary>
      public HL7Connect.Exchange.Message Message { get { return propGetMessage(); } }

      ///<summary>
      /// Read/Write the error message. The error message will be ignored unless you also set an ErrorCode. You can also set the ErrorMessage using SetError
      ///</summary>
      private string propGetErrorMessage()
      {
        return wrapped().ErrorMessage;
      }
      private void propSetErrorMessage(string value)
      {
        wrapped().ErrorMessage = value;
      }
      ///<summary>
      /// Read/Write the error message. The error message will be ignored unless you also set an ErrorCode. You can also set the ErrorMessage using SetError
      ///</summary>
      public string ErrorMessage { get { return propGetErrorMessage(); } set { propSetErrorMessage(value); } }

      ///<summary>
      /// Read/Write the errorCode. The error message will be ignored unless you also set an ErrorMessage. You can also set the ErrorCode using SetError. The error Code is one of the nuemrical codes that goes in MSA-6
      ///</summary>
      private string propGetErrorCode()
      {
        return wrapped().ErrorCode;
      }
      private void propSetErrorCode(string value)
      {
        wrapped().ErrorCode = value;
      }
      ///<summary>
      /// Read/Write the errorCode. The error message will be ignored unless you also set an ErrorMessage. You can also set the ErrorCode using SetError. The error Code is one of the nuemrical codes that goes in MSA-6
      ///</summary>
      public string ErrorCode { get { return propGetErrorCode(); } set { propSetErrorCode(value); } }

    }

    ///<summary>
    /// This event is called when a Document is received from an interface and the Document has been parsed. It exists to allow the user to impose custom validation checks, do Document modification/translation, and send the Documents to interfaces or virtual queues. 
    /// 
    /// The event handler can do anything it wants with the Document but it must leave it the compulsory CDA headers populated. If the interface wishes to reject the Document, it should set the response accordingly (before the script is executed, the response is "accepted", though the kernel will override this later when it processes the document if the script does not reject it). The Document is logged prior to this event XSLT: the input is the document message, the output replaces the original document
    ///</summary>
    public class ReceiveDocument : HL7Connect.Events.InterfaceBase
    {

      internal ReceiveDocument(IReceiveDocumentEvent com) : base(com) {} 

      internal new HCReceiveDocumentEvent wrapped() { return (HCReceiveDocumentEvent) com; }

      ///<summary>
      /// Send the Document to the named (document) interface 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the Document to the named (document) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the Document to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the Document to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the actual Document received
      ///</summary>
      private HL7Connect.Exchange.Document propGetDocument()
      {
        return HL7Connect.Exchange.WrapperFactory.Document(wrapped().Document);
      }
      ///<summary>
      /// A handle to the actual Document received
      ///</summary>
      public HL7Connect.Exchange.Document Document { get { return propGetDocument(); } }

      ///<summary>
      /// The response for to the document. Before the script executes, this is set to droUnknown; if the script sets the response to droRejected, then no further processing will take place. If the script sets the response to droAccepted, the kernel will assume that the script has processed the message.
      ///</summary>
      private HL7Connect.Exchange.DocumentResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DocumentResponse(wrapped().Response);
      }
      ///<summary>
      /// The response for to the document. Before the script executes, this is set to droUnknown; if the script sets the response to droRejected, then no further processing will take place. If the script sets the response to droAccepted, the kernel will assume that the script has processed the message.
      ///</summary>
      public HL7Connect.Exchange.DocumentResponse Response { get { return propGetResponse(); } }

    }

    ///<summary>
    /// {** note: DICOM Support is under development. DICOM events and types are already present in the; }API for declarative purposes, DICOM is not supported, and the API should be expected to change without notice *** 
    /// 
    /// This event is called when a Dicom Message is received from an interface and the message has been parsed and logged. It exists to allow the user to impose custom validation checks, do Message modification/translation, and send the Messages to interfaces or virtual queues. The event handler can do anything it wants with the message, though the message generally needs to be valid afterwards If the script wishes to reject the Message, it should set the Outcome accordingly (before the script is executed, the response is "unknown": the kernel will update this later when it processes the document if the script does not reject it). The Message is logged prior to this event XSLT: the input is the document message in XML format, the output replaces the original document
    ///</summary>
    public class ReceiveDicom : HL7Connect.Events.InterfaceBase
    {

      internal ReceiveDicom(IReceiveDicomEvent com) : base(com) {} 

      internal new HCReceiveDicomEvent wrapped() { return (HCReceiveDicomEvent) com; }

      ///<summary>
      /// Send the message to the named (dicom) interface 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing kernel after the script executes.
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the message to the named (dicom) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing kernel after the script executes.
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the message to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the message to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// The negotiated DICOM association. Will be null for non network associations
      ///</summary>
      private HL7Connect.Dicom.Association propGetAssociation()
      {
        return HL7Connect.Dicom.WrapperFactory.Association(wrapped().Association);
      }
      ///<summary>
      /// The negotiated DICOM association. Will be null for non network associations
      ///</summary>
      public HL7Connect.Dicom.Association Association { get { return propGetAssociation(); } }

      ///<summary>
      /// A handle to the actual Dicom message received
      ///</summary>
      private HL7Connect.Exchange.DicomMessage propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomMessage(wrapped().Message);
      }
      ///<summary>
      /// A handle to the actual Dicom message received
      ///</summary>
      public HL7Connect.Exchange.DicomMessage Message { get { return propGetMessage(); } }

      ///<summary>
      /// The outcome of processing the Dicom message. 
      /// 
      /// The Response.outcome property defaults to droUnknown. If the outcome is not changed, the dicom message will be passed to the kernel for processing.
      ///</summary>
      private HL7Connect.Exchange.DicomResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomResponse(wrapped().Response);
      }
      ///<summary>
      /// The outcome of processing the Dicom message. 
      /// 
      /// The Response.outcome property defaults to droUnknown. If the outcome is not changed, the dicom message will be passed to the kernel for processing.
      ///</summary>
      public HL7Connect.Exchange.DicomResponse Response { get { return propGetResponse(); } }

      ///<summary>
      /// Replies for the message. Usually empty. Ignored unless the outcome status is changed. If the Response.outcome is changed, and the replies list is empty, HL7Connect will build a reply for trhe response
      ///</summary>
      private HL7Connect.Dicom.DicomMessageList propGetReplies()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomMessageList(wrapped().Replies);
      }
      ///<summary>
      /// Replies for the message. Usually empty. Ignored unless the outcome status is changed. If the Response.outcome is changed, and the replies list is empty, HL7Connect will build a reply for trhe response
      ///</summary>
      public HL7Connect.Dicom.DicomMessageList Replies { get { return propGetReplies(); } }

    }

    ///<summary>
    /// This event is called immediately before a message is sent. If the script chooses, it can build a reply in ReplyMessage and set UseReplyMessage. In this case, the message will not be sent an ReplyMessage will be sent as the response 
    /// 
    /// The script is able to modify the Message as it chooses but it should maintain a valid MSH segment. The logs are written after this event Setting UseReplyMessage := true while sequencenumbering is in use can have unexpected consequences. It's best not to do this Note that when this event is called with a message that is being passed through, the message is not stored (if the incoming interface message processing mode is "Pass-through with store", the message will be stored after the remote system has responded). XSLT: the input is the message to be sent, the output replaces the message to be sent
    ///</summary>
    public class SendMessage : HL7Connect.Events.InterfaceBase
    {

      internal SendMessage(ISendMessageEvent com) : base(com) {} 

      internal new HCSendMessageEvent wrapped() { return (HCSendMessageEvent) com; }

      ///<summary>
      /// Send the message to the named (message) interface. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the message to the named (message) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the message to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the message to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the actual message to be sent
      ///</summary>
      private HL7Connect.Exchange.Message propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().Message);
      }
      ///<summary>
      /// A handle to the actual message to be sent
      ///</summary>
      public HL7Connect.Exchange.Message Message { get { return propGetMessage(); } }

      ///<summary>
      /// A handle to a prebuilt ACK answer message to the message to be sent. If the script wants, it can add to this message, and then set UseReplyMessage to true to have this message become the reply message (rather than sending the message to the nominated interface)
      ///</summary>
      private HL7Connect.Exchange.Message propGetReplyMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().ReplyMessage);
      }
      ///<summary>
      /// A handle to a prebuilt ACK answer message to the message to be sent. If the script wants, it can add to this message, and then set UseReplyMessage to true to have this message become the reply message (rather than sending the message to the nominated interface)
      ///</summary>
      public HL7Connect.Exchange.Message ReplyMessage { get { return propGetReplyMessage(); } }

      ///<summary>
      /// Handle the source interface that received the message. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      /// Handle the source interface that received the message. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

      ///<summary>
      /// set UseReplyMessage to true to have the message in ReplyMessage become the reply message that the kernel uses (rather than sending the message to the nominated interface). Note that the OnReceiveReply event will not be called if UseReplyMessage is true
      ///</summary>
      private bool propGetUseReplyMessage()
      {
        return wrapped().UseReplyMessage != 0;
      }
      private void propSetUseReplyMessage(bool value)
      {
        wrapped().UseReplyMessage = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// set UseReplyMessage to true to have the message in ReplyMessage become the reply message that the kernel uses (rather than sending the message to the nominated interface). Note that the OnReceiveReply event will not be called if UseReplyMessage is true
      ///</summary>
      public bool UseReplyMessage { get { return propGetUseReplyMessage(); } set { propSetUseReplyMessage(value); } }

    }

    ///<summary>
    /// This event is called immediately before a Document is sent. If the script chooses, it can abort further document sending by setting the response to either droAccepted or droRejected. 
    /// 
    /// The script is able to modify the Document as it chooses but it should maintain valid CDA headers. Note that any digital signatures in the document will not be updated automatically The logs are written after this event XSLT: the input is the document to be sent, the output replaces the document to be sent
    ///</summary>
    public class SendDocument : HL7Connect.Events.InterfaceBase
    {

      internal SendDocument(ISendDocumentEvent com) : base(com) {} 

      internal new HCSendDocumentEvent wrapped() { return (HCSendDocumentEvent) com; }

      ///<summary>
      /// Send the Document to the named (document) interface 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the Document to the named (document) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the Document to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the Document to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the actual Document to be sent
      ///</summary>
      private HL7Connect.Exchange.Document propGetDocument()
      {
        return HL7Connect.Exchange.WrapperFactory.Document(wrapped().Document);
      }
      ///<summary>
      /// A handle to the actual Document to be sent
      ///</summary>
      public HL7Connect.Exchange.Document Document { get { return propGetDocument(); } }

      ///<summary>
      /// Response for this document. Leave the Response.Outcome as drcUnknown, and the document will be sent to the transport layer 
      /// 
      /// If the script sets the response to droRejected, then the kernel will handle the error as configured. If the script sets the response to droAccepted, the kernel will assume that the script has processed the message.
      ///</summary>
      private HL7Connect.Exchange.DocumentResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DocumentResponse(wrapped().Response);
      }
      ///<summary>
      /// Response for this document. Leave the Response.Outcome as drcUnknown, and the document will be sent to the transport layer 
      /// 
      /// If the script sets the response to droRejected, then the kernel will handle the error as configured. If the script sets the response to droAccepted, the kernel will assume that the script has processed the message.
      ///</summary>
      public HL7Connect.Exchange.DocumentResponse Response { get { return propGetResponse(); } }

      ///<summary>
      /// Handle the source interface that received the Document. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      /// Handle the source interface that received the Document. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

    }

    ///<summary>
    /// This event is called immediately before a Dicom Message is sent. If the script chooses, it can abort further message sending by setting the Response.Outcome to either droAccepted or droRejected. 
    /// 
    /// The script is able to modify the message as it chooses but it should maintain a valid Dicom message. The logs are written after this event XSLT: the input is the message to be sent (in XML format used in the development environment), the output replaces the document to be sent
    ///</summary>
    public class SendDicomMessage : HL7Connect.Events.InterfaceBase
    {

      internal SendDicomMessage(ISendDicomEvent com) : base(com) {} 

      internal new HCSendDicomEvent wrapped() { return (HCSendDicomEvent) com; }

      ///<summary>
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      ///</summary>
      private HL7Connect.Exchange.DicomMessage propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomMessage(wrapped().Message);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Exchange.DicomMessage Message { get { return propGetMessage(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Dicom.DicomMessageList propGetReplies()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomMessageList(wrapped().Replies);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DicomMessageList Replies { get { return propGetReplies(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Exchange.DicomResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomResponse(wrapped().Response);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Exchange.DicomResponse Response { get { return propGetResponse(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

    }

    ///<summary>
    /// This event is called after a Dicom Message is sent, and a response has been received. 
    /// 
    /// Before this event is called, the incoming reply is interpreted into the response that summarises the reply. The script can override the interpretation of the DICOM replies, and/or change the values in the one or more messages received from the external destination system The logs are written after this event
    ///</summary>
    public class ReceiveDicomReply : HL7Connect.Events.InterfaceBase
    {

      internal ReceiveDicomReply(IReceiveDicomReplyEvent com) : base(com) {} 

      internal new HCReceiveDicomReplyEvent wrapped() { return (HCReceiveDicomReplyEvent) com; }

      ///<summary>
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      ///</summary>
      private HL7Connect.Exchange.DicomMessage propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomMessage(wrapped().Message);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Exchange.DicomMessage Message { get { return propGetMessage(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Dicom.DicomMessageList propGetReplies()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomMessageList(wrapped().Replies);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DicomMessageList Replies { get { return propGetReplies(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Exchange.DicomResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomResponse(wrapped().Response);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Exchange.DicomResponse Response { get { return propGetResponse(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

    }

    ///<summary>
    /// This event is called when a message has been sent and no reply was received. Usually this event is used to report errors and take other actions as desired. Note: You can stop the outgoing interface on which this error has occurred, but it will not actually stop until the script for this event has completed, so don't wait for the interface to stop (Started = false) 
    /// 
    /// If the script chooses, it can build a reply in ReplyMessage and set UseReplyMessage. In this case, HL7connect will treat the ReplyMessage as the reply from the interface. Setting UseReplyMessage := true while sequencenumbering is in use can have unexpected consequences. It's best not to do this
    ///</summary>
    public class MessageTimeout : HL7Connect.Events.InterfaceBase
    {

      internal MessageTimeout(IMessageTimeoutEvent com) : base(com) {} 

      internal new HCMessageTimeoutEvent wrapped() { return (HCMessageTimeoutEvent) com; }

      ///<summary>
      /// A handle to the actual message to be sent
      ///</summary>
      private HL7Connect.Exchange.Message propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().Message);
      }
      ///<summary>
      /// A handle to the actual message to be sent
      ///</summary>
      public HL7Connect.Exchange.Message Message { get { return propGetMessage(); } }

      ///<summary>
      /// A handle to a prebuilt ACK answer message to the message to be sent. If the script wants, it can add to this message, and then set UseReplyMessage to true to have this message become the reply message (rather than sending the message to the nominated interface)
      ///</summary>
      private HL7Connect.Exchange.Message propGetReplyMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().ReplyMessage);
      }
      ///<summary>
      /// A handle to a prebuilt ACK answer message to the message to be sent. If the script wants, it can add to this message, and then set UseReplyMessage to true to have this message become the reply message (rather than sending the message to the nominated interface)
      ///</summary>
      public HL7Connect.Exchange.Message ReplyMessage { get { return propGetReplyMessage(); } }

      ///<summary>
      /// Handle the source interface that received the message. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      /// Handle the source interface that received the message. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

      ///<summary>
      /// set UseReplyMessage to true to have this message become the reply message (rather than sending the message to the nominated interface). Note that the OnReceiveReply event will not be called if UseReplyMessage is true
      ///</summary>
      private bool propGetUseReplyMessage()
      {
        return wrapped().UseReplyMessage != 0;
      }
      private void propSetUseReplyMessage(bool value)
      {
        wrapped().UseReplyMessage = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// set UseReplyMessage to true to have this message become the reply message (rather than sending the message to the nominated interface). Note that the OnReceiveReply event will not be called if UseReplyMessage is true
      ///</summary>
      public bool UseReplyMessage { get { return propGetUseReplyMessage(); } set { propSetUseReplyMessage(value); } }

    }

    ///<summary>
    /// This event is called when a Document has been sent to the transport layer. Either the document is accepted, rejected, or timed out (what is possible depends on the transport layer details) 
    /// 
    /// Usually this event is used to handle errors and take other actions as desired. Note: You can stop the outgoing interface on which this error has occurred, but it will not actually stop until the script for this event has completed, so don't wait for the interface to stop (Started = false) The response will be pre-populated with the response from the underlying transport layer. The script can override this if it wants,
    ///</summary>
    public class DocumentSentOutcome : HL7Connect.Events.InterfaceBase
    {

      internal DocumentSentOutcome(IDocumentSentOutcomeEvent com) : base(com) {} 

      internal new HCDocumentSentOutcomeEvent wrapped() { return (HCDocumentSentOutcomeEvent) com; }

      ///<summary>
      /// Send the Document to the named (document) interface 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the Document to the named (document) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the Document to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the Document to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the Document will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the actual Document that was sent
      ///</summary>
      private HL7Connect.Exchange.Document propGetDocument()
      {
        return HL7Connect.Exchange.WrapperFactory.Document(wrapped().Document);
      }
      ///<summary>
      /// A handle to the actual Document that was sent
      ///</summary>
      public HL7Connect.Exchange.Document Document { get { return propGetDocument(); } }

      ///<summary>
      /// The response will be pre-populated with the response from the underlying transport layer. The script can override this if it wants.
      ///</summary>
      private HL7Connect.Exchange.DocumentResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DocumentResponse(wrapped().Response);
      }
      ///<summary>
      /// The response will be pre-populated with the response from the underlying transport layer. The script can override this if it wants.
      ///</summary>
      public HL7Connect.Exchange.DocumentResponse Response { get { return propGetResponse(); } }

      ///<summary>
      /// Handle the source interface that received the Document. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      /// Handle the source interface that received the Document. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

    }

    ///<summary>
    /// This event is called when a reply is received. The incoming message can be changed but MSH and MSA must be valid. 
    /// 
    /// XSLT: the input is the reply from the other system, the output replaces the reply for further processing
    ///</summary>
    public class ReceiveReply : HL7Connect.Events.InterfaceBase
    {

      internal ReceiveReply(IReceiveReplyEvent com) : base(com) {} 

      internal new HCReceiveReplyEvent wrapped() { return (HCReceiveReplyEvent) com; }

      ///<summary>
      /// Send the message to the named (message) interface. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the message to the named (message) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the message to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the message to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the message that was sent to the interface
      ///</summary>
      private HL7Connect.Exchange.Message propGetSourceMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().SourceMessage);
      }
      ///<summary>
      /// A handle to the message that was sent to the interface
      ///</summary>
      public HL7Connect.Exchange.Message SourceMessage { get { return propGetSourceMessage(); } }

      ///<summary>
      /// A handle to the reply message from the interface. The incoming message can be changed but MSH and MSA must be valid.
      ///</summary>
      private HL7Connect.Exchange.Message propGetReplyMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().ReplyMessage);
      }
      ///<summary>
      /// A handle to the reply message from the interface. The incoming message can be changed but MSH and MSA must be valid.
      ///</summary>
      public HL7Connect.Exchange.Message ReplyMessage { get { return propGetReplyMessage(); } }

      ///<summary>
      /// Handle the source interface that received the sent message in the first place. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      private HL7Connect.Kernel.Interface propGetSourceInterface()
      {
        return HL7Connect.Kernel.WrapperFactory.Interface(wrapped().SourceInterface);
      }
      ///<summary>
      /// Handle the source interface that received the sent message in the first place. It is possible that the source interface is no longer valid, in which case the value will be null
      ///</summary>
      public HL7Connect.Kernel.Interface SourceInterface { get { return propGetSourceInterface(); } }

    }

    ///<summary>
    /// This event is called once a reply has been generated for a message. The script is allowed full access to the reply message but should leave the MSH and MSA fields populated. 
    /// 
    /// The logs are written after this event This event is also a chance to queue the incoming message (SourceMessage) for other interfaces, but beware that the event will be called whether or not the message was accepted. (Use SourceMessage.Stored to check) XSLT: the input is the reply that will be sent, the output replaces the reply
    ///</summary>
    public class SendReply : HL7Connect.Events.InterfaceBase
    {

      internal SendReply(ISendReplyEvent com) : base(com) {} 

      internal new HCSendReplyEvent wrapped() { return (HCSendReplyEvent) com; }

      ///<summary>
      /// Send the message to the named (message) interface. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the message to the named (message) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the message to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the message to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// A handle to the message that was received, for which this is an answer.
      ///</summary>
      private HL7Connect.Exchange.Message propGetSourceMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().SourceMessage);
      }
      ///<summary>
      /// A handle to the message that was received, for which this is an answer.
      ///</summary>
      public HL7Connect.Exchange.Message SourceMessage { get { return propGetSourceMessage(); } }

      ///<summary>
      /// A handle to the message that is to be returned to the sending interface
      ///</summary>
      private HL7Connect.Exchange.Message propGetReplyMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.Message(wrapped().ReplyMessage);
      }
      ///<summary>
      /// A handle to the message that is to be returned to the sending interface
      ///</summary>
      public HL7Connect.Exchange.Message ReplyMessage { get { return propGetReplyMessage(); } }

    }

    ///<summary>
    /// {** note: DICOM Support is under development. DICOM events and types are already present in the; }API for declarative purposes, DICOM is not supported, and the API should be expected to change without notice *** 
    /// 
    /// This event is called when an incoming interface is replying to a Dicom Message. There may be 0 to many response messages. The event will be called even if there is no proposed responses, and even if the message is being rejected. The script can change the response messages, and also change the outcome. Note that if the outcome is anything other than droAccepted, then the response messages will ignored, and an Abort PDU sent instead. The outgoing responses are logged subsequent to this event
    ///</summary>
    public class SendDicomReply : HL7Connect.Events.InterfaceBase
    {

      internal SendDicomReply(ISendDicomReplyEvent com) : base(com) {} 

      internal new HCSendDicomReplyEvent wrapped() { return (HCSendDicomReplyEvent) com; }

      ///<summary>
      /// Send the message to the named (dicom) interface 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing kernel after the script executes.
      ///</summary>
      public void SendToInterface(string Name)
      {
        wrapped().SendToInterface(Name);
      }

      ///<summary>
      /// Send the message to the named (dicom) interface with translation parameters for the scripts. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing kernel after the script executes.
      ///</summary>
      public void SendToInterfaceWithParams(string Name, string OutTranslationParam, string InTranslationParam)
      {
        wrapped().SendToInterfaceWithParams(Name, OutTranslationParam, InTranslationParam);
      }

      ///<summary>
      /// Send the message to the named virtual queue. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueue(string Name)
      {
        wrapped().SendToVirtualQueue(Name);
      }

      ///<summary>
      /// Send the message to the named virtual queue with a specified partition. 
      /// 
      /// Note that this is not immediate; instead, the message will be added to the queue after the script finishes executing
      ///</summary>
      public void SendToVirtualQueueWithPartition(string Name, string Partition)
      {
        wrapped().SendToVirtualQueueWithPartition(Name, Partition);
      }

      ///<summary>
      /// The negotiated DICOM association
      ///</summary>
      private HL7Connect.Dicom.Association propGetAssociation()
      {
        return HL7Connect.Dicom.WrapperFactory.Association(wrapped().Association);
      }
      ///<summary>
      /// The negotiated DICOM association
      ///</summary>
      public HL7Connect.Dicom.Association Association { get { return propGetAssociation(); } }

      ///<summary>
      /// A handle to the actual DICOM message received
      ///</summary>
      private HL7Connect.Exchange.DicomMessage propGetMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomMessage(wrapped().Message);
      }
      ///<summary>
      /// A handle to the actual DICOM message received
      ///</summary>
      public HL7Connect.Exchange.DicomMessage Message { get { return propGetMessage(); } }

      ///<summary>
      /// The outcome of processing the DICOM message.
      ///</summary>
      private HL7Connect.Exchange.DicomResponse propGetResponse()
      {
        return HL7Connect.Exchange.WrapperFactory.DicomResponse(wrapped().Response);
      }
      ///<summary>
      /// The outcome of processing the DICOM message.
      ///</summary>
      public HL7Connect.Exchange.DicomResponse Response { get { return propGetResponse(); } }

      ///<summary>
      /// Actual replies for the message. If this list is empty after this event is executed, HL7Connect will build a default reply based on the information in the response
      ///</summary>
      private HL7Connect.Dicom.DicomMessageList propGetReplies()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomMessageList(wrapped().Replies);
      }
      ///<summary>
      /// Actual replies for the message. If this list is empty after this event is executed, HL7Connect will build a default reply based on the information in the response
      ///</summary>
      public HL7Connect.Dicom.DicomMessageList Replies { get { return propGetReplies(); } }

    }

    ///<summary>
    /// The event that is called when THL7V2Manager.executeScript is called.
    ///</summary>
    public class ExecuteHL7 : HL7Connect.Events.Base
    {

      internal ExecuteHL7(IExecuteHL7Event com) : base(com) {} 

      internal new HCExecuteHL7Event wrapped() { return (HCExecuteHL7Event) com; }

    }

    ///<summary>
    /// The event that is called when TCDAManager.executeScript is called.
    ///</summary>
    public class ExecuteCDA : HL7Connect.Events.Base
    {

      internal ExecuteCDA(IExecuteCDAEvent com) : base(com) {} 

      internal new HCExecuteCDAEvent wrapped() { return (HCExecuteCDAEvent) com; }

    }

    ///<summary>
    /// The event that is called when TCDAManager.executeScript is called.
    ///</summary>
    public class ExecuteKScript : HL7Connect.Events.Base
    {

      internal ExecuteKScript(IExecuteKScriptEvent com) : base(com) {} 

      internal new HCExecuteKScriptEvent wrapped() { return (HCExecuteKScriptEvent) com; }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Events.Base Base(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCHL7ConvertEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ConvertText(wrapped);
        else if (wrapped is HCHL7BuildEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.BuildText(wrapped);
        else if (wrapped is HCValidationEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ValidateMessage(wrapped);
        else if (wrapped is HCCDAValidationEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ValidationDocument(wrapped);
        else if (wrapped is HCUserInitiatedEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.UserInitiated(wrapped);
        else if (wrapped is HCKernelStartEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.KernelStart(wrapped);
        else if (wrapped is HCKernelStopEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.KernelStop(wrapped);
        else if (wrapped is HCRASEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.RASBase(wrapped);
        else if (wrapped is HCCheckMessageEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.CheckMessage(wrapped);
        else if (wrapped is HCCheckDocumentEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.CheckDocument(wrapped);
        else if (wrapped is HCSendScriptMessageEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendScriptMessage(wrapped);
        else if (wrapped is HCSendScriptDocumentEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendScriptDocument(wrapped);
        else if (wrapped is HCInterfaceEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.InterfaceBase(wrapped);
        else if (wrapped is HCExecuteHL7Event)
          return /*4*/HL7Connect.Events.WrapperFactory.ExecuteHL7(wrapped);
        else if (wrapped is HCExecuteCDAEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ExecuteCDA(wrapped);
        else if (wrapped is HCExecuteKScriptEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ExecuteKScript(wrapped);
        else
          return new HL7Connect.Events.Base((IScriptEvent) wrapped);
      }

      internal static HL7Connect.Events.ConvertText ConvertText(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ConvertText((IHL7ConvertEvent) wrapped);
      }

      internal static HL7Connect.Events.BuildText BuildText(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.BuildText((IHL7BuildEvent) wrapped);
      }

      internal static HL7Connect.Events.ValidateMessage ValidateMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ValidateMessage((IValidationEvent) wrapped);
      }

      internal static HL7Connect.Events.ValidationDocument ValidationDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ValidationDocument((ICDAValidationEvent) wrapped);
      }

      internal static HL7Connect.Events.UserInitiated UserInitiated(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.UserInitiated((IUserInitiatedEvent) wrapped);
      }

      internal static HL7Connect.Events.KernelStart KernelStart(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.KernelStart((IKernelStartEvent) wrapped);
      }

      internal static HL7Connect.Events.KernelStop KernelStop(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.KernelStop((IKernelStopEvent) wrapped);
      }

      internal static HL7Connect.Events.RASBase RASBase(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCRASConnectEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.RASConnect(wrapped);
        else if (wrapped is HCRASDisconnectEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.RASDisconnect(wrapped);
        else
          return new HL7Connect.Events.RASBase((IRASEvent) wrapped);
      }

      internal static HL7Connect.Events.RASConnect RASConnect(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.RASConnect((IRASConnectEvent) wrapped);
      }

      internal static HL7Connect.Events.RASDisconnect RASDisconnect(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.RASDisconnect((IRASDisconnectEvent) wrapped);
      }

      internal static HL7Connect.Events.CheckMessage CheckMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.CheckMessage((ICheckMessageEvent) wrapped);
      }

      internal static HL7Connect.Events.CheckDocument CheckDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.CheckDocument((ICheckDocumentEvent) wrapped);
      }

      internal static HL7Connect.Events.SendScriptMessage SendScriptMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendScriptMessage((ISendScriptMessageEvent) wrapped);
      }

      internal static HL7Connect.Events.SendScriptDocument SendScriptDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendScriptDocument((ISendScriptDocumentEvent) wrapped);
      }

      internal static HL7Connect.Events.InterfaceBase InterfaceBase(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCInterfaceStartEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.InterfaceStart(wrapped);
        else if (wrapped is HCInterfaceStopEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.InterfaceStop(wrapped);
        else if (wrapped is HCReceiveMessageEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ReceiveMessage(wrapped);
        else if (wrapped is HCReceiveDocumentEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ReceiveDocument(wrapped);
        else if (wrapped is HCReceiveDicomEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ReceiveDicom(wrapped);
        else if (wrapped is HCSendMessageEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendMessage(wrapped);
        else if (wrapped is HCSendDocumentEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendDocument(wrapped);
        else if (wrapped is HCSendDicomEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendDicomMessage(wrapped);
        else if (wrapped is HCReceiveDicomReplyEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ReceiveDicomReply(wrapped);
        else if (wrapped is HCMessageTimeoutEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.MessageTimeout(wrapped);
        else if (wrapped is HCDocumentSentOutcomeEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.DocumentSentOutcome(wrapped);
        else if (wrapped is HCReceiveReplyEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.ReceiveReply(wrapped);
        else if (wrapped is HCSendReplyEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendReply(wrapped);
        else if (wrapped is HCSendDicomReplyEvent)
          return /*4*/HL7Connect.Events.WrapperFactory.SendDicomReply(wrapped);
        else
          return new HL7Connect.Events.InterfaceBase((IInterfaceEvent) wrapped);
      }

      internal static HL7Connect.Events.InterfaceStart InterfaceStart(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.InterfaceStart((IInterfaceStartEvent) wrapped);
      }

      internal static HL7Connect.Events.InterfaceStop InterfaceStop(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.InterfaceStop((IInterfaceStopEvent) wrapped);
      }

      internal static HL7Connect.Events.ReceiveMessage ReceiveMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ReceiveMessage((IReceiveMessageEvent) wrapped);
      }

      internal static HL7Connect.Events.ReceiveDocument ReceiveDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ReceiveDocument((IReceiveDocumentEvent) wrapped);
      }

      internal static HL7Connect.Events.ReceiveDicom ReceiveDicom(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ReceiveDicom((IReceiveDicomEvent) wrapped);
      }

      internal static HL7Connect.Events.SendMessage SendMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendMessage((ISendMessageEvent) wrapped);
      }

      internal static HL7Connect.Events.SendDocument SendDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendDocument((ISendDocumentEvent) wrapped);
      }

      internal static HL7Connect.Events.SendDicomMessage SendDicomMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendDicomMessage((ISendDicomEvent) wrapped);
      }

      internal static HL7Connect.Events.ReceiveDicomReply ReceiveDicomReply(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ReceiveDicomReply((IReceiveDicomReplyEvent) wrapped);
      }

      internal static HL7Connect.Events.MessageTimeout MessageTimeout(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.MessageTimeout((IMessageTimeoutEvent) wrapped);
      }

      internal static HL7Connect.Events.DocumentSentOutcome DocumentSentOutcome(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.DocumentSentOutcome((IDocumentSentOutcomeEvent) wrapped);
      }

      internal static HL7Connect.Events.ReceiveReply ReceiveReply(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ReceiveReply((IReceiveReplyEvent) wrapped);
      }

      internal static HL7Connect.Events.SendReply SendReply(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendReply((ISendReplyEvent) wrapped);
      }

      internal static HL7Connect.Events.SendDicomReply SendDicomReply(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.SendDicomReply((ISendDicomReplyEvent) wrapped);
      }

      internal static HL7Connect.Events.ExecuteHL7 ExecuteHL7(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ExecuteHL7((IExecuteHL7Event) wrapped);
      }

      internal static HL7Connect.Events.ExecuteCDA ExecuteCDA(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ExecuteCDA((IExecuteCDAEvent) wrapped);
      }

      internal static HL7Connect.Events.ExecuteKScript ExecuteKScript(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Events.ExecuteKScript((IExecuteKScriptEvent) wrapped);
      }

    }
  }
  namespace V2
  {
    ///<summary>
    /// The base V2 object
    ///</summary>
    public class Base : HL7Connect.Utils.Base
    {

      internal Base(IHL7MSSEObject com) : base(com) {} 

      internal new HCHL7MSSEObject wrapped() { return (HCHL7MSSEObject) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
    }

    ///<summary>
    /// A specific entry in an HL7 Table
    ///</summary>
    public class DictTableItem : HL7Connect.V2.Base
    {

      internal DictTableItem(IHL7TableItem com) : base(com) {} 

      internal new HCHL7TableItem wrapped() { return (HCHL7TableItem) com; }

      ///<summary>
      /// Numerical ID of table item
      ///</summary>
      private int propGetID()
      {
        return wrapped().ID;
      }
      ///<summary>
      /// Numerical ID of table item
      ///</summary>
      public int ID { get { return propGetID(); } }

      ///<summary>
      /// Code for table item
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      ///<summary>
      /// Code for table item
      ///</summary>
      public string Code { get { return propGetCode(); } }

      ///<summary>
      /// Description of Table Item
      ///</summary>
      private string propGetDescription()
      {
        return wrapped().Description;
      }
      ///<summary>
      /// Description of Table Item
      ///</summary>
      public string Description { get { return propGetDescription(); } }

    }

    ///<summary>
    /// Definition of a table
    ///</summary>
    public class DictTable : HL7Connect.V2.Base
    {

      internal DictTable(IHL7DictTable com) : base(com) {} 

      internal new HCHL7DictTable wrapped() { return (HCHL7DictTable) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DictTableItem GetValue(int iIndex)
      {
        return HL7Connect.V2.WrapperFactory.DictTableItem(wrapped().GetValue(iIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DictTableItem GetValueById(int iId)
      {
        return HL7Connect.V2.WrapperFactory.DictTableItem(wrapped().GetValueById(iId));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DictTableItem GetValueByCode(string sCode)
      {
        return HL7Connect.V2.WrapperFactory.DictTableItem(wrapped().GetValueByCode(sCode));
      }

      ///<summary>
      /// Get a table entry by ID
      ///</summary>
      public HL7Connect.V2.DictTableItem ValueById(int iId)
      {
        return HL7Connect.V2.WrapperFactory.DictTableItem(wrapped().ValueById(iId));
      }

      ///<summary>
      /// Get a table entry by Code
      ///</summary>
      public HL7Connect.V2.DictTableItem ValueByCode(string sCode)
      {
        return HL7Connect.V2.WrapperFactory.DictTableItem(wrapped().ValueByCode(sCode));
      }

      ///<summary>
      /// Numerical ID of table
      ///</summary>
      private int propGetID()
      {
        return wrapped().ID;
      }
      ///<summary>
      /// Numerical ID of table
      ///</summary>
      public int ID { get { return propGetID(); } }

      ///<summary>
      /// Description of table
      ///</summary>
      private string propGetDesc()
      {
        return wrapped().Desc;
      }
      ///<summary>
      /// Description of table
      ///</summary>
      public string Desc { get { return propGetDesc(); } }

      ///<summary>
      /// number of entries in the table
      ///</summary>
      private int propGetValueCount()
      {
        return wrapped().ValueCount;
      }
      ///<summary>
      /// number of entries in the table
      ///</summary>
      public int ValueCount { get { return propGetValueCount(); } }

    }

    ///<summary>
    /// Definition of a data type
    ///</summary>
    public class DictDataType : HL7Connect.V2.Base
    {

      internal DictDataType(IHL7DictDataType com) : base(com) {} 

      internal new HCHL7DictDataType wrapped() { return (HCHL7DictDataType) com; }

      ///<summary>
      /// Length of the Data type
      ///</summary>
      private int propGetLength()
      {
        return wrapped().Length;
      }
      ///<summary>
      /// Length of the Data type
      ///</summary>
      public int Length { get { return propGetLength(); } }

      ///<summary>
      /// Name of the Data type
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// Name of the Data type
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// Description of the Data type
      ///</summary>
      private string propGetDesc()
      {
        return wrapped().Desc;
      }
      ///<summary>
      /// Description of the Data type
      ///</summary>
      public string Desc { get { return propGetDesc(); } }

      ///<summary>
      /// Whether content of this type should be escaped (ER/7)
      ///</summary>
      private bool propGetEscapable()
      {
        return wrapped().Escapable != 0;
      }
      ///<summary>
      /// Whether content of this type should be escaped (ER/7)
      ///</summary>
      public bool Escapable { get { return propGetEscapable(); } }

    }

    ///<summary>
    /// Definition of a component
    ///</summary>
    public class DictComponent : HL7Connect.V2.Base
    {

      internal DictComponent(IHL7DictComponent com) : base(com) {} 

      internal new HCHL7DictComponent wrapped() { return (HCHL7DictComponent) com; }

      ///<summary>
      /// Type of component
      ///</summary>
      private HL7Connect.V2.DictDataType propGetDataType()
      {
        return HL7Connect.V2.WrapperFactory.DictDataType(wrapped().DataType);
      }
      ///<summary>
      /// Type of component
      ///</summary>
      public HL7Connect.V2.DictDataType DataType { get { return propGetDataType(); } }

      ///<summary>
      /// table for component if defined
      ///</summary>
      private HL7Connect.V2.DictTable propGetTable()
      {
        return HL7Connect.V2.WrapperFactory.DictTable(wrapped().Table);
      }
      ///<summary>
      /// table for component if defined
      ///</summary>
      public HL7Connect.V2.DictTable Table { get { return propGetTable(); } }

      ///<summary>
      /// Description of component
      ///</summary>
      private string propGetDescription()
      {
        return wrapped().Description;
      }
      ///<summary>
      /// Description of component
      ///</summary>
      public string Description { get { return propGetDescription(); } }

    }

    ///<summary>
    /// Definition of a structure
    ///</summary>
    public class DictStructure : HL7Connect.V2.Base
    {

      internal DictStructure(IHL7DictStructure com) : base(com) {} 

      internal new HCHL7DictStructure wrapped() { return (HCHL7DictStructure) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DictComponent GetComponents(int iIndex)
      {
        return HL7Connect.V2.WrapperFactory.DictComponent(wrapped().GetComponents(iIndex));
      }

      ///<summary>
      /// Data type - if the type is a simple one
      ///</summary>
      private HL7Connect.V2.DictDataType propGetDataType()
      {
        return HL7Connect.V2.WrapperFactory.DictDataType(wrapped().DataType);
      }
      ///<summary>
      /// Data type - if the type is a simple one
      ///</summary>
      public HL7Connect.V2.DictDataType DataType { get { return propGetDataType(); } }

    }

    ///<summary>
    /// Information about a data element definition
    ///</summary>
    public class DictDataElement : HL7Connect.V2.Base
    {

      internal DictDataElement(IHL7DictDataElement com) : base(com) {} 

      internal new HCHL7DictDataElement wrapped() { return (HCHL7DictDataElement) com; }

      ///<summary>
      /// Name of Structural definition of Data Element
      ///</summary>
      private string propGetStructure()
      {
        return wrapped().Structure;
      }
      ///<summary>
      /// Name of Structural definition of Data Element
      ///</summary>
      public string Structure { get { return propGetStructure(); } }

      ///<summary>
      /// Description of the dataelement type
      ///</summary>
      private string propGetDescription()
      {
        return wrapped().Description;
      }
      ///<summary>
      /// Description of the dataelement type
      ///</summary>
      public string Description { get { return propGetDescription(); } }

      ///<summary>
      /// Structural definition of Data Element
      ///</summary>
      private HL7Connect.V2.DictStructure propGetStructureObj()
      {
        return HL7Connect.V2.WrapperFactory.DictStructure(wrapped().StructureObj);
      }
      ///<summary>
      /// Structural definition of Data Element
      ///</summary>
      public HL7Connect.V2.DictStructure StructureObj { get { return propGetStructureObj(); } }

      ///<summary>
      /// Length limit of data element (for simple types)
      ///</summary>
      private int propGetLength()
      {
        return wrapped().Length;
      }
      ///<summary>
      /// Length limit of data element (for simple types)
      ///</summary>
      public int Length { get { return propGetLength(); } }

      ///<summary>
      /// Table ID if table is defined for this field
      ///</summary>
      private HL7Connect.V2.DictTable propGetTable()
      {
        return HL7Connect.V2.WrapperFactory.DictTable(wrapped().Table);
      }
      ///<summary>
      /// Table ID if table is defined for this field
      ///</summary>
      public HL7Connect.V2.DictTable Table { get { return propGetTable(); } }

    }

    ///<summary>
    /// Information about a particular field in a Segment
    ///</summary>
    public class DictSegmentField : HL7Connect.V2.Base
    {

      internal DictSegmentField(IHL7DictSegmentField com) : base(com) {} 

      internal new HCHL7DictSegmentField wrapped() { return (HCHL7DictSegmentField) com; }

      ///<summary>
      /// Identity for the data element
      ///</summary>
      private int propGetDataElement()
      {
        return wrapped().DataElement;
      }
      ///<summary>
      /// Identity for the data element
      ///</summary>
      public int DataElement { get { return propGetDataElement(); } }

      ///<summary>
      /// Link to the formal definition for the data element in this field
      ///</summary>
      private HL7Connect.V2.DictDataElement propGetDataElementObj()
      {
        return HL7Connect.V2.WrapperFactory.DictDataElement(wrapped().DataElementObj);
      }
      ///<summary>
      /// Link to the formal definition for the data element in this field
      ///</summary>
      public HL7Connect.V2.DictDataElement DataElementObj { get { return propGetDataElementObj(); } }

      ///<summary>
      /// whether this field is required
      ///</summary>
      private bool propGetRequired()
      {
        return wrapped().Required != 0;
      }
      ///<summary>
      /// whether this field is required
      ///</summary>
      public bool Required { get { return propGetRequired(); } }

      ///<summary>
      /// whether the field is repeatable
      ///</summary>
      private bool propGetRepeatable()
      {
        return wrapped().Repeatable != 0;
      }
      ///<summary>
      /// whether the field is repeatable
      ///</summary>
      public bool Repeatable { get { return propGetRepeatable(); } }

      ///<summary>
      /// if this field is repeatable, the number of repeats. 0 = no limit
      ///</summary>
      private int propGetRepeats()
      {
        return wrapped().Repeats;
      }
      ///<summary>
      /// if this field is repeatable, the number of repeats. 0 = no limit
      ///</summary>
      public int Repeats { get { return propGetRepeats(); } }

    }

    ///<summary>
    /// Information pertaining to a segment
    ///</summary>
    public class DictSegment : HL7Connect.V2.Base
    {

      internal DictSegment(IHL7DictSegment com) : base(com) {} 

      internal new HCHL7DictSegment wrapped() { return (HCHL7DictSegment) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DictSegmentField GetField(int iIndex)
      {
        return HL7Connect.V2.WrapperFactory.DictSegmentField(wrapped().GetField(iIndex));
      }

      ///<summary>
      /// Name of the segment (3 letter code)
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// Name of the segment (3 letter code)
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// Description of the segment
      ///</summary>
      private string propGetDesc()
      {
        return wrapped().Desc;
      }
      ///<summary>
      /// Description of the segment
      ///</summary>
      public string Desc { get { return propGetDesc(); } }

      ///<summary>
      /// number of Fields in the segment
      ///</summary>
      private int propGetFieldCount()
      {
        return wrapped().FieldCount;
      }
      ///<summary>
      /// number of Fields in the segment
      ///</summary>
      public int FieldCount { get { return propGetFieldCount(); } }

    }

    ///<summary>
    /// An Entry for a group in a Segment Map
    ///</summary>
    public class DictSegmentGroup : HL7Connect.V2.Base
    {

      internal DictSegmentGroup(IHL7DictSegmentGroup com) : base(com) {} 

      internal new HCHL7DictSegmentGroup wrapped() { return (HCHL7DictSegmentGroup) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DictSegmentGroup GetChild(int i)
      {
        return HL7Connect.V2.WrapperFactory.DictSegmentGroup(wrapped().GetChild(i));
      }

      ///<summary>
      /// valid values: Single, Group, Choice
      ///</summary>
      private string propGetGroupType()
      {
        return wrapped().GroupType;
      }
      ///<summary>
      /// valid values: Single, Group, Choice
      ///</summary>
      public string GroupType { get { return propGetGroupType(); } }

      ///<summary>
      /// Whether Segment Node is optional
      ///</summary>
      private bool propGetOptional()
      {
        return wrapped().Optional != 0;
      }
      ///<summary>
      /// Whether Segment Node is optional
      ///</summary>
      public bool Optional { get { return propGetOptional(); } }

      ///<summary>
      /// Whether Segment Node can repeat
      ///</summary>
      private bool propGetRepeating()
      {
        return wrapped().Repeating != 0;
      }
      ///<summary>
      /// Whether Segment Node can repeat
      ///</summary>
      public bool Repeating { get { return propGetRepeating(); } }

      ///<summary>
      /// Name of this group. Either a 3 letter segment name of the name from the v2.xml std schemas.
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// Name of this group. Either a 3 letter segment name of the name from the v2.xml std schemas.
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// Number of Nodes in this Group
      ///</summary>
      private int propGetChildCount()
      {
        return wrapped().ChildCount;
      }
      ///<summary>
      /// Number of Nodes in this Group
      ///</summary>
      public int ChildCount { get { return propGetChildCount(); } }

    }

    ///<summary>
    /// Structure ID - required for XML encoding
    ///</summary>
    public class DictMessageStructure : HL7Connect.V2.Base
    {

      internal DictMessageStructure(IHL7DictMessageStruct com) : base(com) {} 

      internal new HCHL7DictMessageStruct wrapped() { return (HCHL7DictMessageStruct) com; }

      ///<summary>
      /// Name of Message Structure. Some names are '?' - predates serious HL7 interest in managing the name of the structure
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// Name of Message Structure. Some names are '?' - predates serious HL7 interest in managing the name of the structure
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// Description of Message Structure if available in HL7 standard
      ///</summary>
      private string propGetDescription()
      {
        return wrapped().Description;
      }
      ///<summary>
      /// Description of Message Structure if available in HL7 standard
      ///</summary>
      public string Description { get { return propGetDescription(); } }

      ///<summary>
      /// Nominated example event for this type. Note that there may be more than one event for a given type
      ///</summary>
      private string propGetExampleEvent()
      {
        return wrapped().ExampleEvent;
      }
      ///<summary>
      /// Nominated example event for this type. Note that there may be more than one event for a given type
      ///</summary>
      public string ExampleEvent { get { return propGetExampleEvent(); } }

      ///<summary>
      /// Nominated example Message Type for this type. Note that there may be more than one message type for a given type
      ///</summary>
      private string propGetExampleMsgType()
      {
        return wrapped().ExampleMsgType;
      }
      ///<summary>
      /// Nominated example Message Type for this type. Note that there may be more than one message type for a given type
      ///</summary>
      public string ExampleMsgType { get { return propGetExampleMsgType(); } }

      ///<summary>
      /// From the standard. Meaning?
      ///</summary>
      private string propGetAction()
      {
        return wrapped().Action;
      }
      ///<summary>
      /// From the standard. Meaning?
      ///</summary>
      public string Action { get { return propGetAction(); } }

      ///<summary>
      /// the Segment Map for this message
      ///</summary>
      private HL7Connect.V2.DictSegmentGroup propGetSegmentMap()
      {
        return HL7Connect.V2.WrapperFactory.DictSegmentGroup(wrapped().SegmentMap);
      }
      ///<summary>
      /// the Segment Map for this message
      ///</summary>
      public HL7Connect.V2.DictSegmentGroup SegmentMap { get { return propGetSegmentMap(); } }

    }

    ///<summary>
    /// A class that represents a section of a complex content in an escaped field.
    ///</summary>
    public class Content : HL7Connect.V2.Base
    {

      internal Content(IHL7Content com) : base(com) {} 

      internal new HCHL7Content wrapped() { return (HCHL7Content) com; }

      ///<summary>
      /// Highlight the selected range of the content using \H\ and \N\. range is 1 based (i.e. to highlight 'is' in "This is a test", you would use 6,8 for the begin and end parameters
      ///</summary>
      public void Highlight(int iBegin, int iEnd)
      {
        wrapped().Highlight(iBegin, iEnd);
      }

      ///<summary>
      /// Highlight the selected range of the content using \x\ and \N\. range is 1 based (i.e. to highlight 'is' in "This is a test", you would use 6,8 for the begin and end parameters) 
      /// 
      /// The code is a custom code to be used in place of \H\. Do not use a code that has other meanings in HL7. You can use more than one character. This is for custom extension - other HL7 applications will only know what these extensions mean if they are specfically designed for them.
      ///</summary>
      public void HighlightCustom(int iBegin, int iEnd, string sStart, string sEnd)
      {
        wrapped().HighlightCustom(iBegin, iEnd, sStart, sEnd);
      }

      ///<summary>
      /// Return the type of section that this is. Possible return values are { NULL = this section represents a "" - this is only ever found by itself. Text will be "";  TEXT - simple text. Text is the content of the string;  ESCAPE - an escape sequence. Text is the content of the escape;  BINARY - a sequence of bytes (a \X escape in HL7). Text is a sequence of characters that represent the bytes denoted in the escape sequence.; }There is no XML representation for a BINARY sequence in HL7. Binary content will never exist if the source message was in XML format. Users should be beware that the two message formats are not the same in this regard: the XML format is a sequence of Unicode characters (whatever the character encoding, it's unicode logically), and there is many pitfalls in mapping between unicode characters and whatever is intended to be conveyed when a \X escape sequence is used.
      ///</summary>
      private string propGetContentType()
      {
        return wrapped().ContentType;
      }
      ///<summary>
      /// Return the type of section that this is. Possible return values are { NULL = this section represents a "" - this is only ever found by itself. Text will be "";  TEXT - simple text. Text is the content of the string;  ESCAPE - an escape sequence. Text is the content of the escape;  BINARY - a sequence of bytes (a \X escape in HL7). Text is a sequence of characters that represent the bytes denoted in the escape sequence.; }There is no XML representation for a BINARY sequence in HL7. Binary content will never exist if the source message was in XML format. Users should be beware that the two message formats are not the same in this regard: the XML format is a sequence of Unicode characters (whatever the character encoding, it's unicode logically), and there is many pitfalls in mapping between unicode characters and whatever is intended to be conveyed when a \X escape sequence is used.
      ///</summary>
      public string ContentType { get { return propGetContentType(); } }

      ///<summary>
      /// The contents of the section of content. The exact meaning of the Text property depends on the ContentType property.
      ///</summary>
      private string propGetText()
      {
        return wrapped().Text;
      }
      ///<summary>
      /// The contents of the section of content. The exact meaning of the Text property depends on the ContentType property.
      ///</summary>
      public string Text { get { return propGetText(); } }

    }

    ///<summary>
    /// Common ancestor for all Messages, Segments, Fields, Components
    ///</summary>
    public class DataObject : HL7Connect.V2.Base
    {

      internal DataObject(IHL7DataObject com) : base(com) {} 

      internal new HCHL7DataObject wrapped() { return (HCHL7DataObject) com; }

    }

    ///<summary>
    /// The common Component lays down common content management for the subcomponent, component and DataElement classes. 
    /// 
    /// The cell may have actual contents if it doesn't have children. When the cell has contents, the content is stored internally as a sequence of content parts. The content parts may consist of a single null (for ""), or a sequence of Text, Escape and Binary Parts in any order. The internal representation enables the full content of any valid HL7 message to be stored, but these features (escapes, binary content) are not widely used, and the internal content storage API is not a convenient form to work with simple content - which is the majority of cases. For this reason, the content of a cell can be accessed in a number of ways: { using simple typed accessors such as asDate, asInteger, asString etc.;  getting the RawContent (but this is potentially dangerous, see the documentation for RawContent);  examaning the contents directly using the Contents and ContentCount properties. This is usually overkill except where the content has escapes such as \H\, \.br\, \X..\ or similar; }The simple typed accessors and RawContent check that there is no escape or binary content. Errors will be raised if these exist.
    ///</summary>
    public class Cell : HL7Connect.V2.DataObject
    {

      internal Cell(IHL7CommonDataCell com) : base(com) {} 

      internal new HCHL7CommonDataCell wrapped() { return (HCHL7CommonDataCell) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Content GetContents(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.Content(wrapped().GetContents(AIndex));
      }

      ///<summary>
      /// Gets the content of the cell as a DateTime. If the contents are not a valid date, an exception with the message Desc will be raised (this is to assist in tracking down which field was responsible for the problem
      ///</summary>
      public DateTime AsDateTimeWithReject(string Desc)
      {
        return wrapped().AsDateTimeWithReject(Desc);
      }

      ///<summary>
      /// returns true if the segment is identified by the name provided. The syntax of name follows that of Element, with the difference that if the syntax does not specify a repeat index for segment or field, then any repeat will match
      ///</summary>
      public bool IsElement(string AName)
      {
        return wrapped().IsElement(AName) != 0;
      }

      ///<summary>
      /// Check if a table is defined for this component. If the cell has children, the result for the first child will be returned.
      ///</summary>
      public bool TableDefined()
      {
        return wrapped().TableDefined() != 0;
      }

      ///<summary>
      /// checks to see if a table is defined, then if the value provided is from the table. either code, or description is accepted. If the cell has children, the result for the first child will be returned.
      ///</summary>
      public bool ValueInTable()
      {
        return wrapped().ValueInTable() != 0;
      }

      ///<summary>
      /// return the code for the item provided, whether a code or text was provided. If the cell has children, the result for the first child will be returned.
      ///</summary>
      public bool AsTableCode(ref string VCode)
      {
        return wrapped().AsTableCode(ref VCode) != 0;
      }

      ///<summary>
      /// look up the value provided in the table and insert the code if value is non numeric this will return false if the code was not found If the cell has children, the result for the first child will be returned..
      ///</summary>
      public bool AddTableCode(string sCode)
      {
        return wrapped().AddTableCode(sCode) != 0;
      }

      ///<summary>
      /// Decode the fragment over the top of the existing content 
      /// 
      /// Note that when this method is used on data elements with XML, field repeats cannot be decoded sFormat - XML or ER7
      ///</summary>
      public void Decode(string sContent, string sFormat, bool bWipeContent)
      {
        wrapped().Decode(sContent, sFormat, bWipeContent ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// This cell as encoded in ER7 or XML 
      /// 
      /// Note that when this method is used on data elements with XML, field repeats cannot be encoded
      ///</summary>
      public string EnCode(string sFormat)
      {
        return wrapped().EnCode(sFormat);
      }

      ///<summary>
      /// get the values from the source. Self and source can be different types - you can assign a DataElement into a Component. This will work as long as the copy doesn't create sub-sub-components
      ///</summary>
      public void CopyCell(HL7Connect.V2.Cell ASource)
      {
        wrapped().CopyCell(ASource.wrapped());
      }

      ///<summary>
      ///</summary>
      private string propGetEncoded()
      {
        return wrapped().Encoded;
      }
      ///<summary>
      ///</summary>
      public string Encoded { get { return propGetEncoded(); } }

      ///<summary>
      /// Get the nth content section that contributes to the resource. (0 based) 
      /// 
      /// There will be a content section for each of the following: { "" (if it's the only content in the cell);  any text;  any escape that is not a syntactic escape (i.e. not an escape taking the place of the field separator for instance;  any binary sequence (\Xxxxx); } See notes on IHL7Content.contentType about binary sequences and XML
      ///</summary>
      public HL7Connect.V2.Content Contents(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.Content(wrapped().Contents(AIndex));
      }

      ///<summary>
      /// Highlight the entire content of the cell using \H\ and \N\
      ///</summary>
      public void HighlightAll()
      {
        wrapped().HighlightAll();
      }

      ///<summary>
      /// Highlight the selected range of the cell using \H\ and \N\. range is 0 based (i.e. to highlight 'is' in "This is a test", you would use 5,7 for the begin and end parameters 
      /// 
      /// The index is calculated from the start of the cell using the Text property. Where there is escapes etc, it can get confusing to calculate the offsets, so there is a matching routine on the Content class to simplify matters in these cases. This routine will fail with an exception if there is already highlighting on the cell
      ///</summary>
      public void Highlight(int iBegin, int iEnd)
      {
        wrapped().Highlight(iBegin, iEnd);
      }

      ///<summary>
      /// Highlight the selected range of the cell using \x\ and \N\. range is 0 based (i.e. to highlight 'is' in "This is a test", you would use 5,7 for the begin and end parameters) 
      /// 
      /// The codes are custom codes to be used in place of \H\ and \N\. Do not use a code that has other meanings in HL7. You can use more than one character. Generally it would be recommended to start custom codes with Z to be consistent with HL7 localisation rules This is for custom extension - other HL7 applications will only know what these extensions mean if they are specfically designed for them. The index is calculated from the start of the cell using the Text property. Where there is escapes etc, it can get confusing to calculate the offsets, so there is a matching routine on the Content class to simplify matters in these cases.
      ///</summary>
      public void HighlightCustom(int iBegin, int iEnd, string sStart, string sEnd)
      {
        wrapped().HighlightCustom(iBegin, iEnd, sStart, sEnd);
      }

      ///<summary>
      /// Remove all highlights \H\ and \N\ in the cell
      ///</summary>
      public void RemoveHighlights()
      {
        wrapped().RemoveHighlights();
      }

      ///<summary>
      /// Remove the nominated highlight from the cell. 
      /// 
      /// The index is the index of the Content item that encodes the H. The matching N will be automatically removed.
      ///</summary>
      public void RemoveHighlight(int iIndex)
      {
        wrapped().RemoveHighlight(iIndex);
      }

      ///<summary>
      /// Remove all escape sequences in the cell
      ///</summary>
      public void RemoveEscapes()
      {
        wrapped().RemoveEscapes();
      }

      ///<summary>
      /// Remove the nominated escape sequence. No other escape sequences will be removed 
      /// 
      /// The index is the index of the Content item (Same as RemoveContent, but checks that the nominated content is an escape before removing it
      ///</summary>
      public void RemoveEscape(int iIndex)
      {
        wrapped().RemoveEscape(iIndex);
      }

      ///<summary>
      /// Remove the nominated content 
      /// 
      /// The index is the index of the Content item
      ///</summary>
      public void RemoveContent(int iIndex)
      {
        wrapped().RemoveContent(iIndex);
      }

      ///<summary>
      /// Append content to the end of the content list. See IHL7Content for the meaning of the ContentType and Text fields.
      ///</summary>
      public void AppendContent(string sContentType, string sText)
      {
        wrapped().AppendContent(sContentType, sText);
      }

      ///<summary>
      /// Insert content to at position Index in the content list (0 based). 
      /// 
      /// See IHL7Content for the meaning of the ContentType and Text fields.
      ///</summary>
      public void InsertContent(int iIndex, string sContentType, string sText)
      {
        wrapped().InsertContent(iIndex, sContentType, sText);
      }

      ///<summary>
      /// Get the contents of the cell as a string. If the cell has children, the contents of the first child will be returned. 
      /// 
      /// Note: This method returns the cell with escape sequences, using the default escaping characters
      ///</summary>
      private string propGetAsString()
      {
        return wrapped().AsString;
      }
      private void propSetAsString(string value)
      {
        wrapped().AsString = value;
      }
      ///<summary>
      /// Get the contents of the cell as a string. If the cell has children, the contents of the first child will be returned. 
      /// 
      /// Note: This method returns the cell with escape sequences, using the default escaping characters
      ///</summary>
      public string AsString { get { return propGetAsString(); } set { propSetAsString(value); } }

      ///<summary>
      /// Get the contents of the cell as an integer. If the contents are not an integer, an exception will be raised. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      private int propGetAsInteger()
      {
        return wrapped().AsInteger;
      }
      private void propSetAsInteger(int value)
      {
        wrapped().AsInteger = value;
      }
      ///<summary>
      /// Get the contents of the cell as an integer. If the contents are not an integer, an exception will be raised. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      public int AsInteger { get { return propGetAsInteger(); } set { propSetAsInteger(value); } }

      ///<summary>
      /// Get the contents of the cell as a datetime. If the contents are not a datetime, then an exception will be raised. if the content is blank, then the result will be 0. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      private DateTime propGetAsDateTime()
      {
        return wrapped().AsDateTime;
      }
      private void propSetAsDateTime(DateTime value)
      {
        wrapped().AsDateTime = value;
      }
      ///<summary>
      /// Get the contents of the cell as a datetime. If the contents are not a datetime, then an exception will be raised. if the content is blank, then the result will be 0. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      public DateTime AsDateTime { get { return propGetAsDateTime(); } set { propSetAsDateTime(value); } }

      ///<summary>
      /// Get the contents of the cell as a datetime. If the contents are not a datetime, then an exception will be raised. if the content is blank, then the result will be 0. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      private DateTime propGetAsDate()
      {
        return wrapped().AsDate;
      }
      private void propSetAsDate(DateTime value)
      {
        wrapped().AsDate = value;
      }
      ///<summary>
      /// Get the contents of the cell as a datetime. If the contents are not a datetime, then an exception will be raised. if the content is blank, then the result will be 0. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      public DateTime AsDate { get { return propGetAsDate(); } set { propSetAsDate(value); } }

      ///<summary>
      /// Get the contents of the cell as a Float. If the contents are not a number, then an exception will be raised. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      private double propGetAsFloat()
      {
        return wrapped().AsFloat;
      }
      private void propSetAsFloat(double value)
      {
        wrapped().AsFloat = value;
      }
      ///<summary>
      /// Get the contents of the cell as a Float. If the contents are not a number, then an exception will be raised. If the cell has children, the contents of the first child will be returned.
      ///</summary>
      public double AsFloat { get { return propGetAsFloat(); } set { propSetAsFloat(value); } }

      ///<summary>
      /// True if the contents are defined. This is relevent when the contents are empty, whether this is known empty, or unknown. i.e. true means that the cell contents are "" if the raw content is empty. 
      /// 
      /// If the cell has children, the contents of the first child will be returned.
      ///</summary>
      private bool propGetDefined()
      {
        return wrapped().Defined != 0;
      }
      private void propSetDefined(bool value)
      {
        wrapped().Defined = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// True if the contents are defined. This is relevent when the contents are empty, whether this is known empty, or unknown. i.e. true means that the cell contents are "" if the raw content is empty. 
      /// 
      /// If the cell has children, the contents of the first child will be returned.
      ///</summary>
      public bool Defined { get { return propGetDefined(); } set { propSetDefined(value); } }

      ///<summary>
      /// True if the cell contains only "" - to indicate that the value is null
      ///</summary>
      private bool propGetIsNull()
      {
        return wrapped().isNull != 0;
      }
      private void propSetIsNull(bool value)
      {
        wrapped().isNull = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// True if the cell contains only "" - to indicate that the value is null
      ///</summary>
      public bool IsNull { get { return propGetIsNull(); } set { propSetIsNull(value); } }

      ///<summary>
      /// True if there is children of this cell
      ///</summary>
      private bool propGetHasChildren()
      {
        return wrapped().HasChildren != 0;
      }
      ///<summary>
      /// True if there is children of this cell
      ///</summary>
      public bool HasChildren { get { return propGetHasChildren(); } }

      ///<summary>
      /// true if the field should contain a date according to the dictionary. The contents of the cell are not checked. If the cell has children, the value for the first child will be returned.
      ///</summary>
      private bool propGetIsDate()
      {
        return wrapped().IsDate != 0;
      }
      ///<summary>
      /// true if the field should contain a date according to the dictionary. The contents of the cell are not checked. If the cell has children, the value for the first child will be returned.
      ///</summary>
      public bool IsDate { get { return propGetIsDate(); } }

      ///<summary>
      /// Access raw content of the cell. Use with care: { this value does not properly handle "" in cells. (see Defined);  If the cell has real escaping (use of \H\ or \.br\ or \X..\ then the raw content does not include these parts (see ContentCount and Contents); }Setting RawContent will remove any escapes in the cell
      ///</summary>
      private string propGetRawContent()
      {
        return wrapped().RawContent;
      }
      private void propSetRawContent(string value)
      {
        wrapped().RawContent = value;
      }
      ///<summary>
      /// Access raw content of the cell. Use with care: { this value does not properly handle "" in cells. (see Defined);  If the cell has real escaping (use of \H\ or \.br\ or \X..\ then the raw content does not include these parts (see ContentCount and Contents); }Setting RawContent will remove any escapes in the cell
      ///</summary>
      public string RawContent { get { return propGetRawContent(); } set { propSetRawContent(value); } }

      ///<summary>
      /// Access plain text content of the cell. If there is any formatting or binary escapes (\X), they will be ignored. 
      /// 
      /// Setting PlainTextContent will remove any escapes in the cell
      ///</summary>
      private string propGetAsPlainText()
      {
        return wrapped().AsPlainText;
      }
      private void propSetAsPlainText(string value)
      {
        wrapped().AsPlainText = value;
      }
      ///<summary>
      /// Access plain text content of the cell. If there is any formatting or binary escapes (\X), they will be ignored. 
      /// 
      /// Setting PlainTextContent will remove any escapes in the cell
      ///</summary>
      public string AsPlainText { get { return propGetAsPlainText(); } set { propSetAsPlainText(value); } }

      ///<summary>
      /// Remove any content associated with the cell, and also in any children if they exist.
      ///</summary>
      public void ClearAll()
      {
        wrapped().ClearAll();
      }

      ///<summary>
      /// The index of this cell in it's parents children
      ///</summary>
      private int propGetElementIndex()
      {
        return wrapped().ElementIndex;
      }
      ///<summary>
      /// The index of this cell in it's parents children
      ///</summary>
      public int ElementIndex { get { return propGetElementIndex(); } }

      ///<summary>
      /// The Data Type of this cell, if known
      ///</summary>
      private string propGetDataTypeName()
      {
        return wrapped().DataTypeName;
      }
      ///<summary>
      /// The Data Type of this cell, if known
      ///</summary>
      public string DataTypeName { get { return propGetDataTypeName(); } }

      ///<summary>
      /// true if this element or any of it's children are Defined
      ///</summary>
      private bool propGetIsRelevent()
      {
        return wrapped().IsRelevent != 0;
      }
      ///<summary>
      /// true if this element or any of it's children are Defined
      ///</summary>
      public bool IsRelevent { get { return propGetIsRelevent(); } }

      ///<summary>
      /// The numer of parts that make up the content. Usually this is one, but it might be more than one if there is \H\ or \.br\ or \X...\ in the field
      ///</summary>
      private int propGetContentCount()
      {
        return wrapped().ContentCount;
      }
      ///<summary>
      /// The numer of parts that make up the content. Usually this is one, but it might be more than one if there is \H\ or \.br\ or \X...\ in the field
      ///</summary>
      public int ContentCount { get { return propGetContentCount(); } }

      ///<summary>
      /// true if there is no complex content (escapes, binary sequences) in the content of the cell 
      /// 
      /// Also true if there is no content in the cell at all.
      ///</summary>
      private bool propGetIsSimple()
      {
        return wrapped().IsSimple != 0;
      }
      ///<summary>
      /// true if there is no complex content (escapes, binary sequences) in the content of the cell 
      /// 
      /// Also true if there is no content in the cell at all.
      ///</summary>
      public bool IsSimple { get { return propGetIsSimple(); } }

    }

    ///<summary>
    /// Encapsulates a component
    ///</summary>
    public class Component : HL7Connect.V2.Cell
    {

      internal Component(IHL7Component com) : base(com) {} 

      internal new HCHL7Component wrapped() { return (HCHL7Component) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Component GetSubComponent(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.Component(wrapped().GetSubComponent(AIndex));
      }

      ///<summary>
      /// Add a subcomponent manually to the Component, and return a handle to it. Will add intervening subcomponents if they do not exist. SubComponent format is unlimited string. If the subcomponent already exists, just return it. If subcomponent requested is > 100, return nil.
      ///</summary>
      public HL7Connect.V2.Component AddSubComponent(int ANum)
      {
        return HL7Connect.V2.WrapperFactory.Component(wrapped().AddSubComponent(ANum));
      }

      ///<summary>
      ///</summary>
      private HL7Connect.V2.DataElement propGetField()
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().Field);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.V2.DataElement Field { get { return propGetField(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.V2.Cell propGetParent()
      {
        return HL7Connect.V2.WrapperFactory.Cell(wrapped().Parent);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.V2.Cell Parent { get { return propGetParent(); } }

      ///<summary>
      /// Dictionary information about this component
      ///</summary>
      private HL7Connect.V2.DictComponent propGetDefinition()
      {
        return HL7Connect.V2.WrapperFactory.DictComponent(wrapped().Definition);
      }
      ///<summary>
      /// Dictionary information about this component
      ///</summary>
      public HL7Connect.V2.DictComponent Definition { get { return propGetDefinition(); } }

      ///<summary>
      /// The number of subcomponents
      ///</summary>
      private int propGetSubComponentCount()
      {
        return wrapped().SubComponentCount;
      }
      ///<summary>
      /// The number of subcomponents
      ///</summary>
      public int SubComponentCount { get { return propGetSubComponentCount(); } }

    }

    ///<summary>
    /// Encapsulates a Data Element (or Field)
    ///</summary>
    public class DataElement : HL7Connect.V2.Cell
    {

      internal DataElement(IHL7DataElement com) : base(com) {} 

      internal new HCHL7DataElement wrapped() { return (HCHL7DataElement) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Component GetComponent(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.Component(wrapped().GetComponent(AIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DataElement GetRepeats(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().GetRepeats(AIndex));
      }

      ///<summary>
      /// Repeat 0 is the element itself, repeat 1 is the first of the actual repeats. This should be named "Repeat" to be consistent with the naming scheme but "Repeat" is a reserved word
      ///</summary>
      public HL7Connect.V2.DataElement Repeats(int i)
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().Repeats(i));
      }

      ///<summary>
      /// HasRepeat will scan the repeat list looking for "Value" (not case sensitive) in "Location" and returns true if there is a match 
      /// 
      /// A typical use for this is like this:    if msg['PID-3'].HasRepeat('Identifier type code', 'MC') Then
      ///</summary>
      public bool HasRepeat(string ALocation, string AValue)
      {
        return wrapped().HasRepeat(ALocation, AValue) != 0;
      }

      ///<summary>
      /// HasRepeat will scan the repeat list looking for "Value" (not case sensitive) in "Location" and returns -1 if there is no match, or the index of the match (starting at 0, the base cell)
      ///</summary>
      public int FindRepeat(string ALocation, string AValue)
      {
        return wrapped().FindRepeat(ALocation, AValue);
      }

      ///<summary>
      /// choose repeat will scan the repeat list looking for "Value" (not case sensitive) in "Location". If location is '' then the base element is returned. However it is expected that a component will be Specified. A typical use for this is like this:   msg['PID-3'].ChooseRepeat('5', 'MC')['1'].AsString or  msg['PID-3'].ChooseRepeat('Identifier type code', 'MC')['ID'].AsString which will return the patients medicare number if available, or ''
      ///</summary>
      public HL7Connect.V2.DataElement ChooseRepeat(string ALocation, string AValue)
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().ChooseRepeat(ALocation, AValue));
      }

      ///<summary>
      /// Populate the field with components etc from the database. Since this is done automatically when a segment is added to the message, it is not usually required to call this method
      ///</summary>
      public void MakeForBuild()
      {
        wrapped().MakeForBuild();
      }

      ///<summary>
      /// Add a component manually to the field, and return a handle to it. Will add intervening components if they do not exist. Component format is unlimited string. If the component already exists, just return it. If component requested is > 100, return nil.
      ///</summary>
      public HL7Connect.V2.Component AddComponent(int ANum)
      {
        return HL7Connect.V2.WrapperFactory.Component(wrapped().AddComponent(ANum));
      }

      ///<summary>
      /// Add a repeat, and return the cell that is the new repeat.
      ///</summary>
      public HL7Connect.V2.DataElement AddRepeat(bool bFirstIfEmpty)
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().AddRepeat(bFirstIfEmpty ? (sbyte) 0 : (sbyte) -1));
      }

      ///<summary>
      /// Delete the nth repeat (repeats are 1 based. 0 means to delete the first repeat which is considered to be cell itself, not a repeat)
      ///</summary>
      public void DeleteRepeat(int AIndex)
      {
        wrapped().DeleteRepeat(AIndex);
      }

      ///<summary>
      /// Clone the data element. This is not usually called directly, it is called from Segment.CloneSegment 
      /// 
      /// sOptions - space separated list of   AllowUnknownContent  If this is not defined, non-dictionary content will be ignored   OverwriteEmpty       If this is defined, empty fields in the source will overwrite any existing content in the destination   OverwriteUnDefined   If this is defined, undefined fields in the source will overwrite any existing content in the destination
      ///</summary>
      public void CloneDataElement(HL7Connect.V2.DataElement ASourceDataElement, string sOptions)
      {
        wrapped().CloneDataElement(ASourceDataElement.wrapped(), sOptions);
      }

      ///<summary>
      ///</summary>
      private HL7Connect.V2.Segment propGetSegment()
      {
        return HL7Connect.V2.WrapperFactory.Segment(wrapped().Segment);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.V2.Segment Segment { get { return propGetSegment(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.V2.DataElement propGetPrimary()
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().Primary);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.V2.DataElement Primary { get { return propGetPrimary(); } }

      ///<summary>
      /// Dictionary information about this data element
      ///</summary>
      private HL7Connect.V2.DictSegmentField propGetDefinition()
      {
        return HL7Connect.V2.WrapperFactory.DictSegmentField(wrapped().Definition);
      }
      ///<summary>
      /// Dictionary information about this data element
      ///</summary>
      public HL7Connect.V2.DictSegmentField Definition { get { return propGetDefinition(); } }

      ///<summary>
      /// Number of Components
      ///</summary>
      private int propGetComponentCount()
      {
        return wrapped().ComponentCount;
      }
      ///<summary>
      /// Number of Components
      ///</summary>
      public int ComponentCount { get { return propGetComponentCount(); } }

      ///<summary>
      /// Number of repeats. Since the first instance of the field is repeat 0, the RepeatCount is always at least 1
      ///</summary>
      private int propGetRepeatCount()
      {
        return wrapped().RepeatCount;
      }
      ///<summary>
      /// Number of repeats. Since the first instance of the field is repeat 0, the RepeatCount is always at least 1
      ///</summary>
      public int RepeatCount { get { return propGetRepeatCount(); } }

      ///<summary>
      /// String that identifies the data type, if known
      ///</summary>
      private string propGetDataType()
      {
        return wrapped().DataType;
      }
      ///<summary>
      /// String that identifies the data type, if known
      ///</summary>
      public string DataType { get { return propGetDataType(); } }

    }

    ///<summary>
    /// Encapsulates a Segment
    ///</summary>
    public class Segment : HL7Connect.V2.DataObject
    {

      internal Segment(IHL7Segment com) : base(com) {} 

      internal new HCHL7Segment wrapped() { return (HCHL7Segment) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.DataElement GetField(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().GetField(AIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Cell GetElement(string sCode)
      {
        return HL7Connect.V2.WrapperFactory.Cell(wrapped().GetElement(sCode));
      }

      ///<summary>
      /// Populate the segment with fields from the database. Since this is done automatically when a segment is added to the message, it is not usually required to call this method
      ///</summary>
      public void BuildFields()
      {
        wrapped().BuildFields();
      }

      ///<summary>
      /// Get a element or component.   "1" will get data element 1   "2.3" will get component 3 of data element 2 will return nil if requested cell not found. You can also use "-" instead of "."
      ///</summary>
      public HL7Connect.V2.Cell Element(string ACode)
      {
        return HL7Connect.V2.WrapperFactory.Cell(wrapped().Element(ACode));
      }

      ///<summary>
      /// Uses the same syntax as element, but will create the element if it does not exist.
      ///</summary>
      public void ForceElement(string sCode)
      {
        wrapped().ForceElement(sCode);
      }

      ///<summary>
      /// returns true if the segment is identified by the name provided. The syntax of name follows that of Element, with the difference that if the syntax does not specify a repeat index for segment or field, then any repeat will match
      ///</summary>
      public bool IsElement(string AName)
      {
        return wrapped().IsElement(AName) != 0;
      }

      ///<summary>
      /// Add a Data Element manually to the Segment, and return a handle to it. Will add intervening fields if they do not exist. field format is unlimited string. If the field already exists, just return it. If field requested is > 100, return nil.
      ///</summary>
      public HL7Connect.V2.DataElement AddField(int AFieldNum)
      {
        return HL7Connect.V2.WrapperFactory.DataElement(wrapped().AddField(AFieldNum));
      }

      ///<summary>
      /// CloneSegment is used to copy the contents of a segment in one message into another message. Cloning should be able to deal with custom content, and with version translation issues, although this may be limited by lack of information. 
      /// 
      /// sOptions - space separated list of   AllowUnknownContent  If this is not defined, non-dictionary content will be ignored   OverwriteEmpty       If this is defined, empty fields in the source will overwrite any existing content in the destination   OverwriteUnDefined   If this is defined, undefined fields in the source will overwrite any existing content in the destination
      ///</summary>
      public void CloneSegment(HL7Connect.V2.Segment ASourceSegment, string sOptions)
      {
        wrapped().CloneSegment(ASourceSegment.wrapped(), sOptions);
      }

      ///<summary>
      /// Decode the fragment over the top of the existing content - segment must be the same type sFormat = ER7 or XML
      ///</summary>
      public void Decode(string sContent, string sFormat, bool bWipeContent)
      {
        wrapped().Decode(sContent, sFormat, bWipeContent ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// This segment as encoded in ER7 or XML
      ///</summary>
      public string EnCode(string sFormat)
      {
        return wrapped().EnCode(sFormat);
      }

      ///<summary>
      ///</summary>
      private string propGetEncoded()
      {
        return wrapped().Encoded;
      }
      ///<summary>
      ///</summary>
      public string Encoded { get { return propGetEncoded(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.V2.Message propGetOwner()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Owner);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.V2.Message Owner { get { return propGetOwner(); } }

      ///<summary>
      /// Number of fields
      ///</summary>
      private int propGetFieldCount()
      {
        return wrapped().FieldCount;
      }
      ///<summary>
      /// Number of fields
      ///</summary>
      public int FieldCount { get { return propGetFieldCount(); } }

      ///<summary>
      /// returns the numerical ID of the segment in the message
      ///</summary>
      private int propGetSegmentIndex()
      {
        return wrapped().SegmentIndex;
      }
      ///<summary>
      /// returns the numerical ID of the segment in the message
      ///</summary>
      public int SegmentIndex { get { return propGetSegmentIndex(); } }

      ///<summary>
      /// Dictionary information about this segment
      ///</summary>
      private HL7Connect.V2.DictSegment propGetDefinition()
      {
        return HL7Connect.V2.WrapperFactory.DictSegment(wrapped().Definition);
      }
      ///<summary>
      /// Dictionary information about this segment
      ///</summary>
      public HL7Connect.V2.DictSegment Definition { get { return propGetDefinition(); } }

      ///<summary>
      /// 3 letter code identifying the segment type
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      ///<summary>
      /// 3 letter code identifying the segment type
      ///</summary>
      public string Code { get { return propGetCode(); } }

    }

    public class SegmentList : HL7Connect.Utils.Base, IList<Segment>
    {
      public SegmentList(IHL7SegmentList com) : base(com) {}
      internal new HCHL7SegmentList wrapped() { return (HCHL7SegmentList) com; }
  
      public Segment this[int index]
      {
        get { return new Segment(wrapped().Item(index)); }
        set { throw new NotSupportedException("List is readonly"); }
      }
  
      public int IndexOf(Segment item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public void Insert(int index, Segment item)
      {
        throw new NotSupportedException("List is readonly");
      }
  
      public void RemoveAt(int index)
      {
        throw new NotSupportedException("List is readonly");
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return true; } }
  
      public void Add(Segment item)
      {
        throw new NotSupportedException("List is readonly");
      }
  
      public void Clear()
      {
        throw new NotSupportedException("List is readonly");
      }
  
      public bool Contains(Segment item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Segment[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Segment(wrapped().Item(i));
      }
  
      public bool Remove(Segment item)
      {
        throw new NotSupportedException("List is readonly");
      }
  
      public class SegmentListEnumerator : IEnumerator<Segment>
      {
        private IHL7SegmentList com;
        int index = -1;
  
        public SegmentListEnumerator(IHL7SegmentList com)
        {
          this.com = com;
        }
  
        public Segment Current { get { return new Segment(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Segment(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Segment> GetEnumerator()
      {
        return new SegmentListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SegmentListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// Encapsulates a single logical HL7Message. 
    /// 
    /// To read an existing message, create an HL7Message and then decode a source message. To create a reply, create an HL7Message, and then use BuildAsReply. To create a new message, create a message, set it's version, and then add the segments that you require and populate them with values. When finished, call Encode
    ///</summary>
    public class Message : HL7Connect.V2.DataObject
    {

      internal Message(IHL7Message com) : base(com) {} 

      internal new HCHL7Message wrapped() { return (HCHL7Message) com; }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Segment GetSegmentByIndex(int AIndex)
      {
        return HL7Connect.V2.WrapperFactory.Segment(wrapped().GetSegmentByIndex(AIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Segment GetSegment(string ACode, int i)
      {
        return HL7Connect.V2.WrapperFactory.Segment(wrapped().GetSegment(ACode, i));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.V2.Cell GetElement(string sCode)
      {
        return HL7Connect.V2.WrapperFactory.Cell(wrapped().GetElement(sCode));
      }

      ///<summary>
      /// Change the Version of the message to the version specified. ChangeVersion is not very elegant - use with care. 
      /// 
      /// if DeleteInvalidContent is true, anything in the message but not in the dictionary for the specified version is deleted. There is many issues with this procedure that are yet to be determined, including: { downgrading a message into a version where the event or message type does not exist;  upgrading a message into a version which contains compulsory segments; }not defined in the initial version. (If this happens anywhere in the standard?)
      ///</summary>
      public void ChangeVersion(string ANewVersion, bool ADeleteInvalidContent)
      {
        wrapped().ChangeVersion(ANewVersion, ADeleteInvalidContent ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// Retrieve a given segment (3 letter code). There may be multiple xxx segments in a message. Segment 0 is the first instance of a given segment.
      ///</summary>
      public HL7Connect.V2.Segment Segment(string ACode, int i)
      {
        return HL7Connect.V2.WrapperFactory.Segment(wrapped().Segment(ACode, i));
      }

      ///<summary>
      /// Retrieve a set of segments 
      /// 
      /// If the query is empty, all the segments in the message are returned. The query specifies which set of segments to retrieve:  XXX: a three letter code means all segments with the specified code  X* : the asterisk is a wild card - all segments whose code starts with the specified letter { : all segments; }
      ///</summary>
      public HL7Connect.V2.SegmentList SegmentQuery(string query)
      {
        return HL7Connect.V2.WrapperFactory.SegmentList(wrapped().SegmentQuery(query));
      }

      ///<summary>
      /// Element is the most convenient way to retrieve content Code is a string with format SEG[]-N[].O.P   Seg - 3 letter code of segment   N   - Data Element index (starts at 1)   O   - Component Element index (starts at 1) [optional]   P   - Subcomponent index  [optional] 
      /// 
      /// SEG-N-O-P is also accepted both SEG and N can be followed by a condition to specify which repeat to use. In the absence of such a condition:   for segments:      First matching segment   for data elements: First Repeat (actually the 0th repeat, the field that isn't a repeat) if a condition is specified, it can be a simple number - choose the nth instance. (note that the first segment is 1 and the first field is 0). Alternatively, the condition can be an expression using any combination of the following items:   =    case sensitive equals   ==   non case sensitive equals   !=   not equals   +    addition - numerical if both operands a numeric, else string concatenation   ++   forced numerical addition (will be an error if one or both operands are not numerical)   -    numerical subtraction (will be an error if one or both operands are not numerical)   &    string concatenation   and  logical and   or   logical or   xor  logical xor   @    a nested query. The context for the nexted query will be the segment or field to which the condition is attached   ""   string constants Special Variables:   @index  The index of this instance in the list Support for () as precendence operators is planned, but they are not currently supported. if a condition simply consists of a number, it will be taken to be a reference to the index i.e. PID[2] is the same as PID[@index=2] Examples:   EVN-1                                  Event Type   MSH-9-3                                Structure identifier   PID[1]-3-1                             UR number in second PID segment (i.e. in an A17 message) - counting is from zero   PID-11[@7="H"].1                       1st Street line of Home Address   PID-13[@2 = "PRN" and @3="PH"].1       Phone number for home phone   OBX[@3.1="HEIGHT" or @3.2="HEIGHT"]-5  Value from OBX segment for Weight
      ///</summary>
      public HL7Connect.V2.Cell Element(string ACode)
      {
        return HL7Connect.V2.WrapperFactory.Cell(wrapped().Element(ACode));
      }

      ///<summary>
      /// Uses the similar syntax as element, but will create the element if it does not exist. The segment must exist. 
      /// 
      /// The acceptable syntax is SEG[]-N[]-O-P where the contents in the [] can be real numbers - no conditions allowed
      ///</summary>
      public void ForceElement(string sCode)
      {
        wrapped().ForceElement(sCode);
      }

      ///<summary>
      /// decode converts a message into a DOM type tree integrated with the dictionary. 
      /// 
      /// If VersionOverride is provided, a version of HL7 different to that claimed by the message will be used - a way to handle exceptions to the standard. If a segmentlimit is provided, only the first few segments will be decoded up to the specified limit. This is to support high-throughput applications only interested in the MSH (and perhaps the EVN). Note that PID's can be scattered through the message so it is dangerous to examine the PID segment if a segment limit has been set You can also nominate the Format. The library will choose the right class for all messages currently observed, so this is not usually necessary. Valid Values are XML or ER7 You can also set ASuppressErrors. If this is true the library will do it's best to suppress errors encountered reading messages. You need to be very careful if you set this to true as the library will do it's level best to ignore errors when reading messages in this case. This is mostly used with XML messages to deal with cases where the library needs to deal with XML messages that do not use the right data types. See also decodeOptions which provides more control
      ///</summary>
      public void Decode(string APacket, string AVersionOverride, int ASegmentLimit, string sFormat, bool ASuppressErrors)
      {
        wrapped().Decode(APacket, AVersionOverride, ASegmentLimit, sFormat, ASuppressErrors ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// decode converts a message into a DOM type tree integrated with the dictionary. 
      /// 
      /// The options must be one or more of the following words, separated by whitespace:   v[X]     Where X is 2.v (i.e. 2.3 or 2.3.1). v can be any of the supported versions.     Parse as if the specified version, irrespective of what the message says   s[n]     Where n is an integer. Parse up the first n segments only. If n is 0, or     this option is not specified, the entire message will be parsed.   xml     Treat as xml without first trying to figure out what it is   er7     Treat as vertical bar message without first trying to figure out what it is   noErrors     Tell the parser to do it's best to suppress errors encountered reading     messages. Mostly this relates to XML parsing where the apparent semantics     in the instance don't match the specified semantics in the standard   NoOddBinaries     Don't allow odd length \Xdd\ escape sequences to have a '0' prepended to them. (causes an exception instead)     i.e. \X9\ is not treated as \X09\
      ///</summary>
      public void DecodeOptions(string APacket, string options)
      {
        wrapped().DecodeOptions(APacket, options);
      }

      ///<summary>
      /// Encode and return the encoded message, using the ITS specified by the parameters. Valid values are   ER7    (the famous vertical bars)   XML The default value is ER7 
      /// 
      /// sOptions: any space separated combination of:   OptimisticMapping:     when writing XML, how the segments are mapped against the segment structure. If     this is not defined, then the list of segments must match the expected list. If     this is not defined, then the mapping code will attempt to deal with unexpected     segments. Note that in optimistic mapping, things can go quite badly wrong     if they do go wrong   AllowMappingToFail:     If this is set, then if mapping fails, any remaining segments not     mapped will be mapped into the root segment. If this is not set,     and mapping fails, then an exception will be raised and encoding     will fail. Relevent for XML   EscapeExtendedCharacters:     When this is set extended characters (ascii 127+) will automatically     be escaped in ER7 format.   ExtraFieldDelimiter:     for stupid OACIS system that requires an extra Field Delimiter at     the end of every segment   NoAddStructureName:     suppress the automatic addition of a structure name (MSH-9-3)
      ///</summary>
      public string Encode(string sFormat, string sOptions)
      {
        return wrapped().EnCode(sFormat, sOptions);
      }

      ///<summary>
      /// Build this message as a reply to the given message. Add sequence numbering info if provided
      ///</summary>
      public void BuildAsReply(HL7Connect.V2.Message AMsg, bool AUseSequenceNum, int ASequenceNum)
      {
        wrapped().BuildAsReply(AMsg.wrapped(), AUseSequenceNum ? (sbyte) 0 : (sbyte) -1, ASequenceNum);
      }

      ///<summary>
      /// Populate NACK message using the String in MSA-3. The message will be an AE unless MakeReject is true, in which case it will be an AR. BuildAsReply must have been used already
      ///</summary>
      public void SetExceptionMessage(string AMsg, bool AMakeReject)
      {
        wrapped().SetExceptionMessage(AMsg, AMakeReject ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// Add the specifed segment to the message and build it's Data Elements and components
      ///</summary>
      public HL7Connect.V2.Segment AddSegment(string ACode)
      {
        return HL7Connect.V2.WrapperFactory.Segment(wrapped().AddSegment(ACode));
      }

      ///<summary>
      /// Add the specifed to the segment to the message at the point nominated and build it's Data Elements and components If Index is 0, the string is inserted at the beginning of the list. If Index is 1, the string is put in the second position of the list, and so on.
      ///</summary>
      public HL7Connect.V2.Segment InsertSegment(int AIndex, string ACode)
      {
        return HL7Connect.V2.WrapperFactory.Segment(wrapped().InsertSegment(AIndex, ACode));
      }

      ///<summary>
      /// Drop any segments with the given code from the message
      ///</summary>
      public void DropSegments(string ACode)
      {
        wrapped().DropSegments(ACode);
      }

      ///<summary>
      /// Delete the segment from the message. Do not refer to the segment after it is deleted
      ///</summary>
      public void DeleteSegment(HL7Connect.V2.Segment ASegment)
      {
        wrapped().DeleteSegment(ASegment.wrapped());
      }

      ///<summary>
      /// Copy a segment from another message - add it to this message as a new segment. All information whether in dictionary or not will be copied across
      ///</summary>
      public void CloneSegment(HL7Connect.V2.Segment ASegment)
      {
        wrapped().CloneSegment(ASegment.wrapped());
      }

      ///<summary>
      /// special case - this puts an MSH in place and populates it as much as possible from known information
      ///</summary>
      public void AddMSHForBuild()
      {
        wrapped().AddMSHForBuild();
      }

      ///<summary>
      /// number of segments of given type
      ///</summary>
      public int CountSegment(string ACode)
      {
        return wrapped().CountSegment(ACode);
      }

      ///<summary>
      /// Clear all segments and message information
      ///</summary>
      public void Clear()
      {
        wrapped().Clear();
      }

      ///<summary>
      /// incredible as it may seem, some very large vendors send HL7 that contains empty repeats. This is often in contexts where the presence of non-empty repeats has meaning. This procedure will find and delete any repeats with empty content. 
      /// 
      /// If a field is encoded as |content~content| then the repeat will stand. if the content is encode as any of the following:   |Content~|   |Content~^^^|   |Content~^&|   |Content~~content|   etc then the empty repeat will be deleted. This is not empty:   |Content~""| finally, regarding this situation:   |~Content| The first instance of the field (it's unclear whether this is usually called a "repeat") will be dropped and the content promoted in it's place if ALeading is true, and nothing will happen if ALeading is false
      ///</summary>
      public void StripEmptyRepeats(bool ALeading)
      {
        wrapped().StripEmptyRepeats(ALeading ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// generate an exact copy of this message
      ///</summary>
      public HL7Connect.V2.Message Clone()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Clone());
      }

      ///<summary>
      /// update the internal source so that it reflects the current state of the message (using message.encode). 
      /// 
      /// This doesn't do anything - it's deprecated, but remains declared because many scripts use it for historical reasons
      ///</summary>
      public void UpdateSource()
      {
        wrapped().UpdateSource();
      }

      ///<summary>
      /// The encoding for this message. If the message has been decoded, then this is the encoding that was read. If the message is encoded, this encoding will be used unless something different is specified when the message is encoded. 
      /// 
      /// Valid Values = XML or ER7
      ///</summary>
      private string propGetEncoding()
      {
        return wrapped().Encoding;
      }
      private void propSetEncoding(string value)
      {
        wrapped().Encoding = value;
      }
      ///<summary>
      /// The encoding for this message. If the message has been decoded, then this is the encoding that was read. If the message is encoded, this encoding will be used unless something different is specified when the message is encoded. 
      /// 
      /// Valid Values = XML or ER7
      ///</summary>
      public string Encoding { get { return propGetEncoding(); } set { propSetEncoding(value); } }

      ///<summary>
      /// Version of message. This should be treated as read-only except when building a message before any segments have been added. 
      /// 
      /// If you want to change the version after the message has segments, use ChangeVersion
      ///</summary>
      private string propGetVersion()
      {
        return wrapped().Version;
      }
      private void propSetVersion(string value)
      {
        wrapped().Version = value;
      }
      ///<summary>
      /// Version of message. This should be treated as read-only except when building a message before any segments have been added. 
      /// 
      /// If you want to change the version after the message has segments, use ChangeVersion
      ///</summary>
      public string Version { get { return propGetVersion(); } set { propSetVersion(value); } }

      ///<summary>
      /// The event for this message
      ///</summary>
      private string propGetEvent()
      {
        return wrapped().Event;
      }
      private void propSetEvent(string value)
      {
        wrapped().Event = value;
      }
      ///<summary>
      /// The event for this message
      ///</summary>
      public string Event { get { return propGetEvent(); } set { propSetEvent(value); } }

      ///<summary>
      /// The Message type for this message. Setting this will alter the value of the MSH segment if one exists
      ///</summary>
      private string propGetMessageType()
      {
        return wrapped().MessageType;
      }
      private void propSetMessageType(string value)
      {
        wrapped().MessageType = value;
      }
      ///<summary>
      /// The Message type for this message. Setting this will alter the value of the MSH segment if one exists
      ///</summary>
      public string MessageType { get { return propGetMessageType(); } set { propSetMessageType(value); } }

      ///<summary>
      /// The Name of the Message type for this message. Setting this will alter the value of the MSH segment if one exists
      ///</summary>
      private string propGetStructName()
      {
        return wrapped().StructName;
      }
      private void propSetStructName(string value)
      {
        wrapped().StructName = value;
      }
      ///<summary>
      /// The Name of the Message type for this message. Setting this will alter the value of the MSH segment if one exists
      ///</summary>
      public string StructName { get { return propGetStructName(); } set { propSetStructName(value); } }

      ///<summary>
      /// The message ID of this message. This should be treated as read-only except when building a message before any segments have been added. Setting this will alter the value of the MSH segment if one exists.
      ///</summary>
      private string propGetMsgID()
      {
        return wrapped().MsgID;
      }
      private void propSetMsgID(string value)
      {
        wrapped().MsgID = value;
      }
      ///<summary>
      /// The message ID of this message. This should be treated as read-only except when building a message before any segments have been added. Setting this will alter the value of the MSH segment if one exists.
      ///</summary>
      public string MsgID { get { return propGetMsgID(); } set { propSetMsgID(value); } }

      ///<summary>
      /// Dictionary information about the structure for this message
      ///</summary>
      private HL7Connect.V2.DictMessageStructure propGetStructure()
      {
        return HL7Connect.V2.WrapperFactory.DictMessageStructure(wrapped().Structure);
      }
      ///<summary>
      /// Dictionary information about the structure for this message
      ///</summary>
      public HL7Connect.V2.DictMessageStructure Structure { get { return propGetStructure(); } }

      ///<summary>
      /// The number of segments in the message.
      ///</summary>
      private int propGetSegmentCount()
      {
        return wrapped().SegmentCount;
      }
      ///<summary>
      /// The number of segments in the message.
      ///</summary>
      public int SegmentCount { get { return propGetSegmentCount(); } }

      ///<summary>
      /// Full source for the original message (when reading)
      ///</summary>
      private string propGetSource()
      {
        return wrapped().Source;
      }
      ///<summary>
      /// Full source for the original message (when reading)
      ///</summary>
      public string Source { get { return propGetSource(); } }

      ///<summary>
      /// The character used as the Field delimiter. 1 character long only.
      ///</summary>
      private string propGetFieldDelimiter()
      {
        return wrapped().FieldDelimiter;
      }
      private void propSetFieldDelimiter(string value)
      {
        wrapped().FieldDelimiter = value;
      }
      ///<summary>
      /// The character used as the Field delimiter. 1 character long only.
      ///</summary>
      public string FieldDelimiter { get { return propGetFieldDelimiter(); } set { propSetFieldDelimiter(value); } }

      ///<summary>
      /// The character used as the Component delimiter. 1 character long only.
      ///</summary>
      private string propGetComponentDelimiter()
      {
        return wrapped().ComponentDelimiter;
      }
      private void propSetComponentDelimiter(string value)
      {
        wrapped().ComponentDelimiter = value;
      }
      ///<summary>
      /// The character used as the Component delimiter. 1 character long only.
      ///</summary>
      public string ComponentDelimiter { get { return propGetComponentDelimiter(); } set { propSetComponentDelimiter(value); } }

      ///<summary>
      /// The character used as the SubComponent delimiter. 1 character long only.
      ///</summary>
      private string propGetSubComponentDelimiter()
      {
        return wrapped().SubComponentDelimiter;
      }
      private void propSetSubComponentDelimiter(string value)
      {
        wrapped().SubComponentDelimiter = value;
      }
      ///<summary>
      /// The character used as the SubComponent delimiter. 1 character long only.
      ///</summary>
      public string SubComponentDelimiter { get { return propGetSubComponentDelimiter(); } set { propSetSubComponentDelimiter(value); } }

      ///<summary>
      /// The character used as the Repeat delimiter. 1 character long only.
      ///</summary>
      private string propGetRepeatDelimiter()
      {
        return wrapped().RepeatDelimiter;
      }
      private void propSetRepeatDelimiter(string value)
      {
        wrapped().RepeatDelimiter = value;
      }
      ///<summary>
      /// The character used as the Repeat delimiter. 1 character long only.
      ///</summary>
      public string RepeatDelimiter { get { return propGetRepeatDelimiter(); } set { propSetRepeatDelimiter(value); } }

      ///<summary>
      /// The character used as the Escape delimiter. 1 character long only.
      ///</summary>
      private string propGetEscapeDelimiter()
      {
        return wrapped().EscapeDelimiter;
      }
      private void propSetEscapeDelimiter(string value)
      {
        wrapped().EscapeDelimiter = value;
      }
      ///<summary>
      /// The character used as the Escape delimiter. 1 character long only.
      ///</summary>
      public string EscapeDelimiter { get { return propGetEscapeDelimiter(); } set { propSetEscapeDelimiter(value); } }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.V2.Base Base(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCHL7TableItem)
          return /*4*/HL7Connect.V2.WrapperFactory.DictTableItem(wrapped);
        else if (wrapped is HCHL7DictTable)
          return /*4*/HL7Connect.V2.WrapperFactory.DictTable(wrapped);
        else if (wrapped is HCHL7DictDataType)
          return /*4*/HL7Connect.V2.WrapperFactory.DictDataType(wrapped);
        else if (wrapped is HCHL7DictComponent)
          return /*4*/HL7Connect.V2.WrapperFactory.DictComponent(wrapped);
        else if (wrapped is HCHL7DictStructure)
          return /*4*/HL7Connect.V2.WrapperFactory.DictStructure(wrapped);
        else if (wrapped is HCHL7DictDataElement)
          return /*4*/HL7Connect.V2.WrapperFactory.DictDataElement(wrapped);
        else if (wrapped is HCHL7DictSegmentField)
          return /*4*/HL7Connect.V2.WrapperFactory.DictSegmentField(wrapped);
        else if (wrapped is HCHL7DictSegment)
          return /*4*/HL7Connect.V2.WrapperFactory.DictSegment(wrapped);
        else if (wrapped is HCHL7DictSegmentGroup)
          return /*4*/HL7Connect.V2.WrapperFactory.DictSegmentGroup(wrapped);
        else if (wrapped is HCHL7DictMessageStruct)
          return /*4*/HL7Connect.V2.WrapperFactory.DictMessageStructure(wrapped);
        else if (wrapped is HCHL7Content)
          return /*4*/HL7Connect.V2.WrapperFactory.Content(wrapped);
        else if (wrapped is HCHL7DataObject)
          return /*4*/HL7Connect.V2.WrapperFactory.DataObject(wrapped);
        else
          return new HL7Connect.V2.Base((IHL7MSSEObject) wrapped);
      }

      internal static HL7Connect.V2.DictTableItem DictTableItem(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictTableItem((IHL7TableItem) wrapped);
      }

      internal static HL7Connect.V2.DictTable DictTable(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictTable((IHL7DictTable) wrapped);
      }

      internal static HL7Connect.V2.DictDataType DictDataType(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictDataType((IHL7DictDataType) wrapped);
      }

      internal static HL7Connect.V2.DictComponent DictComponent(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictComponent((IHL7DictComponent) wrapped);
      }

      internal static HL7Connect.V2.DictStructure DictStructure(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictStructure((IHL7DictStructure) wrapped);
      }

      internal static HL7Connect.V2.DictDataElement DictDataElement(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictDataElement((IHL7DictDataElement) wrapped);
      }

      internal static HL7Connect.V2.DictSegmentField DictSegmentField(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictSegmentField((IHL7DictSegmentField) wrapped);
      }

      internal static HL7Connect.V2.DictSegment DictSegment(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictSegment((IHL7DictSegment) wrapped);
      }

      internal static HL7Connect.V2.DictSegmentGroup DictSegmentGroup(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictSegmentGroup((IHL7DictSegmentGroup) wrapped);
      }

      internal static HL7Connect.V2.DictMessageStructure DictMessageStructure(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DictMessageStructure((IHL7DictMessageStruct) wrapped);
      }

      internal static HL7Connect.V2.Content Content(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.Content((IHL7Content) wrapped);
      }

      internal static HL7Connect.V2.DataObject DataObject(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCHL7CommonDataCell)
          return /*4*/HL7Connect.V2.WrapperFactory.Cell(wrapped);
        else if (wrapped is HCHL7Segment)
          return /*4*/HL7Connect.V2.WrapperFactory.Segment(wrapped);
        else if (wrapped is HCHL7Message)
          return /*4*/HL7Connect.V2.WrapperFactory.Message(wrapped);
        else
          return new HL7Connect.V2.DataObject((IHL7DataObject) wrapped);
      }

      internal static HL7Connect.V2.Cell Cell(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCHL7Component)
          return /*4*/HL7Connect.V2.WrapperFactory.Component(wrapped);
        else if (wrapped is HCHL7DataElement)
          return /*4*/HL7Connect.V2.WrapperFactory.DataElement(wrapped);
        else
          return new HL7Connect.V2.Cell((IHL7CommonDataCell) wrapped);
      }

      internal static HL7Connect.V2.Component Component(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.Component((IHL7Component) wrapped);
      }

      internal static HL7Connect.V2.DataElement DataElement(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.DataElement((IHL7DataElement) wrapped);
      }

      internal static HL7Connect.V2.Segment Segment(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.Segment((IHL7Segment) wrapped);
      }

      internal static HL7Connect.V2.SegmentList SegmentList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.SegmentList((IHL7SegmentList) wrapped);
      }

      internal static HL7Connect.V2.Message Message(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.V2.Message((IHL7Message) wrapped);
      }

    }
  }
  namespace Exchange
  {
    ///<summary>
    /// {** note: DICOM Support is under development. DICOM events and types are already present in the; }API for declarative purposes, DICOM is not supported, and the API should be expected to change without notice *** 
    /// 
    /// The outcome of processing a Dicom Message. The Dicom Message may be accepted or rejected. If rejected, then the rejection *may* indicate whether the rejection is believed to be due to internal transient conditions, whether the condition is related to the content of the Dicom message itself, or whether it is caused by some business rules (policy). Note that it can be very hard to tell these conditions apart in the presence of an unexpected error, so the value should never be taken as gospel. Some text description is expected to explain why the Dicom is rejected (Explanation). This won't make it into an actual DICOM Abort PDU, but it will appear in various HL7Connect records and logs. If a sending script chooses not to fill the response out, it *should* populate this field.
    ///</summary>
    public class DicomResponse : HL7Connect.Utils.Base
    {

      internal DicomResponse(IDicomResponse com) : base(com) {} 

      internal new HCDicomResponse wrapped() { return (HCDicomResponse) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// One line string suitable for inclusion in logs etc that sumamrises the response
      ///</summary>
      public string TextSummary()
      {
        return wrapped().TextSummary();
      }

      ///<summary>
      /// The result of processing the Dicom. Before the script executes, this is set to droUnknown. If the script doesn't change this value, the Dicom will be processed as expected (either received or sent). 
      /// 
      /// Other values are droAccepted, droTimeout, or droRejected. If a script sets the value to droRejected, it should populate the code and comment too. -- List of possible document responses droUnknowndroTimeoutdroAccepteddroRejected
      ///</summary>
      private TDocumentResponseOutcome propGetOutcome()
      {
        return wrapped().Outcome;
      }
      private void propSetOutcome(TDocumentResponseOutcome value)
      {
        wrapped().Outcome = value;
      }
      ///<summary>
      /// The result of processing the Dicom. Before the script executes, this is set to droUnknown. If the script doesn't change this value, the Dicom will be processed as expected (either received or sent). 
      /// 
      /// Other values are droAccepted, droTimeout, or droRejected. If a script sets the value to droRejected, it should populate the code and comment too. -- List of possible document responses droUnknowndroTimeoutdroAccepteddroRejected
      ///</summary>
      public TDocumentResponseOutcome Outcome { get { return propGetOutcome(); } set { propSetOutcome(value); } }

      ///<summary>
      /// An optional application-specific error code with value 1 - 65535 (0 is no error) 
      /// 
      /// Goes in Dicom Element (0000,0903)
      ///</summary>
      private int propGetCode()
      {
        return wrapped().Code;
      }
      private void propSetCode(int value)
      {
        wrapped().Code = value;
      }
      ///<summary>
      /// An optional application-specific error code with value 1 - 65535 (0 is no error) 
      /// 
      /// Goes in Dicom Element (0000,0903)
      ///</summary>
      public int Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// Text explanation for a failure or timeout. 
      /// 
      /// Goes in Dicom Element (0000,0902)
      ///</summary>
      private string propGetComment()
      {
        return wrapped().Comment;
      }
      private void propSetComment(string value)
      {
        wrapped().Comment = value;
      }
      ///<summary>
      /// Text explanation for a failure or timeout. 
      /// 
      /// Goes in Dicom Element (0000,0902)
      ///</summary>
      public string Comment { get { return propGetComment(); } set { propSetComment(value); } }

    }

    ///<summary>
    /// The outcome of a response to sending/processing the document. The document may be accepted or rejected. 
    /// 
    /// If rejected, then the rejection *may* indicate whether the rejection is believed to be due to internal transient conditions, whether the condition is related to the content of the document itself, or whether it is caused by some business rules (policy). Note that it can be very hard to tell these conditions apart in the presence of an unexpected error, so the value should never be taken as gospel. If the document is rejected, some text description is expected to explain why the document is rejected. HL7Connect will always populate the text message; if a sending script chooses not to send a document, it *should* populate this field.
    ///</summary>
    public class DocumentResponse : HL7Connect.Utils.Base
    {

      internal DocumentResponse(IDocumentResponse com) : base(com) {} 

      internal new HCDocumentResponse wrapped() { return (HCDocumentResponse) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// One line string suitable for inclusion in logs etc that sumamrises the response
      ///</summary>
      public string TextSummary()
      {
        return wrapped().TextSummary();
      }

      ///<summary>
      /// The result of processing the document. Before the script executes, this is set to droUnknown. If the script doesn't change this value, the document will be processed as expected (either received or sent). 
      /// 
      /// Other values are droAccepted, droTimeout, or droRejected. -- List of possible document responses droUnknowndroTimeoutdroAccepteddroRejected
      ///</summary>
      private TDocumentResponseOutcome propGetOutcome()
      {
        return wrapped().Outcome;
      }
      private void propSetOutcome(TDocumentResponseOutcome value)
      {
        wrapped().Outcome = value;
      }
      ///<summary>
      /// The result of processing the document. Before the script executes, this is set to droUnknown. If the script doesn't change this value, the document will be processed as expected (either received or sent). 
      /// 
      /// Other values are droAccepted, droTimeout, or droRejected. -- List of possible document responses droUnknowndroTimeoutdroAccepteddroRejected
      ///</summary>
      public TDocumentResponseOutcome Outcome { get { return propGetOutcome(); } set { propSetOutcome(value); } }

      ///<summary>
      /// If a document is rejected, it may be unclear why - in particular, is it worth sending again? the cause is an optional property that may assist a sender to decide whether to resend the document. Note that not all transports report the case back to the sender. 
      /// 
      /// Possible values: drrcUnknown, drrcTransient, drrcDocument, drrcPolicy -- List of possible rejection causes drrcUnknowndrrcTransientdrrcDocumentdrrcPolicy
      ///</summary>
      private TDocumentResponseRejectionCause propGetCause()
      {
        return wrapped().Cause;
      }
      private void propSetCause(TDocumentResponseRejectionCause value)
      {
        wrapped().Cause = value;
      }
      ///<summary>
      /// If a document is rejected, it may be unclear why - in particular, is it worth sending again? the cause is an optional property that may assist a sender to decide whether to resend the document. Note that not all transports report the case back to the sender. 
      /// 
      /// Possible values: drrcUnknown, drrcTransient, drrcDocument, drrcPolicy -- List of possible rejection causes drrcUnknowndrrcTransientdrrcDocumentdrrcPolicy
      ///</summary>
      public TDocumentResponseRejectionCause Cause { get { return propGetCause(); } set { propSetCause(value); } }

      ///<summary>
      /// Text explanation for a failure or timeout.
      ///</summary>
      private string propGetReason()
      {
        return wrapped().Reason;
      }
      private void propSetReason(string value)
      {
        wrapped().Reason = value;
      }
      ///<summary>
      /// Text explanation for a failure or timeout.
      ///</summary>
      public string Reason { get { return propGetReason(); } set { propSetReason(value); } }

    }

    ///<summary>
    /// Information about a message instance in the HL7Connect kernel
    ///</summary>
    public class Message : HL7Connect.Utils.Base
    {

      internal Message(IHL7ConnectMessage com) : base(com) {} 

      internal new HCHL7ConnectMessage wrapped() { return (HCHL7ConnectMessage) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// ReadOnly: whether the message has been stored. The message will not have been stored if the message has just been created using Kernel.createNewMessage or if the message is incoming, or if this is a reply
      ///</summary>
      public bool Stored()
      {
        return wrapped().Stored() != 0;
      }

      ///<summary>
      /// ReadOnly: Returns False.
      ///</summary>
      public bool Storable()
      {
        return wrapped().Storable() != 0;
      }

      ///<summary>
      /// no longer supported - use Kernel.NewMessage instead
      ///</summary>
      public void Store(int Source)
      {
        wrapped().Store(Source);
      }

      ///<summary>
      /// ReadOnly: if the message is stored, what the primary key is
      ///</summary>
      public int PrimaryKey()
      {
        return wrapped().PrimaryKey();
      }

      ///<summary>
      /// ReadOnly: what format the message has. Currently only HL7 is supported. Other formats will be supported in the future 
      /// 
      /// -- other formats will be added in the future mfHL7
      ///</summary>
      public THL7ConnectMessageFormat MsgFormat()
      {
        return wrapped().MsgFormat();
      }

      ///<summary>
      /// ReadOnly: if the message is HL7 (always true at present) this is a IHL7Message that describes the HL7 content
      ///</summary>
      public HL7Connect.V2.Message HL7()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().HL7());
      }

      ///<summary>
      /// ReadOnly: String containing text description of the source of the message.
      ///</summary>
      public string Source()
      {
        return wrapped().Source();
      }

      ///<summary>
      /// Get the message annotation value for the given name.
      ///</summary>
      public string GetAnnotation(string sName)
      {
        return wrapped().GetAnnotation(sName);
      }

      ///<summary>
      /// Set the annotation value for the given name. 
      /// 
      /// Name must be &lt; 250 chars. Value may be any length, but lengths &gt; 32 are not searchable in the web interface You can set annotations on any messages, but annotations are only stored when a message is saved after being received or when a message status is updated after a reply is received.
      ///</summary>
      public void SetAnnotation(string sName, string sValue)
      {
        wrapped().SetAnnotation(sName, sValue);
      }

    }

    ///<summary>
    /// Information about a Document instance in the HL7Connect kernel
    ///</summary>
    public class Document : HL7Connect.Utils.Base
    {

      internal Document(IHL7ConnectDocument com) : base(com) {} 

      internal new HCHL7ConnectDocument wrapped() { return (HCHL7ConnectDocument) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// ReadOnly: whether the Document has been stored. The Document will not have been stored if the Document has just been created using Kernel.createNewDocument or if the Document is incoming (and/or just passing through)
      ///</summary>
      public bool Stored()
      {
        return wrapped().Stored() != 0;
      }

      ///<summary>
      /// ReadOnly: if the Document is stored, what the primary key is
      ///</summary>
      public int PrimaryKey()
      {
        return wrapped().PrimaryKey();
      }

      ///<summary>
      /// ReadOnly: a IcdaClinicalDocument that describes the CDA content
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument CDA()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().CDA());
      }

      ///<summary>
      /// Select a set of objects by an XPath expression. 
      /// 
      /// The first parameter is the root for the XPath expression. To start at the root of the document, pass the CDA property, or nil. The second parameter is an XPath statement such as //v3:recordTarget/v3:patientRole/v3:id The namespace 'v3' is required on elements or the xpath won't work. Other namespaces that can be used in the XPath are xsi and the xml namespace itself. The return value is a list of the objects that match the selected XPath statement. The objects may be any of the Cda, structured text or data types. Only objects that have an element can be selected. Although you can execute xpath statements that match text, attributes, comments etc, these will never be able to be matched to any matching object, and nothing will be returned. For instance, executing the xpath above with the CDA document itself as the root will return the list of Iv3II identifiers for the patient. Note that the XPath statements operate on the original parsed XML, and the XML is not updated as the object model itself is changed. So if you add an identifier to the list of patient identifiers in a script, then execute the XPath above, the new identifier will not be returned. Further, deleting an identifier from the list, then rerunning the XPath statement, and trying to access the deleted object will cause unpredictable results (technically, the link from the XML back to the object model is not reference counted) Technical Note: The XPath expression is evaluated by the MSXML engine.
      ///</summary>
      public HL7Connect.Cda.BaseList XPath(HL7Connect.Cda.Base oRoot, string sExpression)
      {
        return HL7Connect.Cda.WrapperFactory.BaseList(wrapped().XPath(oRoot.wrapped(), sExpression));
      }

      ///<summary>
      /// ReadOnly: String containing text description of the source of the Document.
      ///</summary>
      public string Source()
      {
        return wrapped().Source();
      }

      ///<summary>
      /// Get the Document annotation value for the given name.
      ///</summary>
      public string GetAnnotation(string sName)
      {
        return wrapped().GetAnnotation(sName);
      }

      ///<summary>
      /// Set the annotation value for the given name. 
      /// 
      /// Name must be &lt; 250 chars. Value may be any length, but lengths &gt; 32 are not searchable in the web interface You can set annotations on any Documents, but annotations are only stored when a Document is saved after being received or when a Document status is updated after a reply is received.
      ///</summary>
      public void SetAnnotation(string sName, string sValue)
      {
        wrapped().SetAnnotation(sName, sValue);
      }

    }

    ///<summary>
    /// {** note: DICOM Support is under development. DICOM events and types are already present in the; }API for declarative purposes, DICOM is not supported, and the API should be expected to change without notice *** 
    /// 
    ///  Information about a Document instance in the HL7Connect kernel
    ///</summary>
    public class DicomMessage : HL7Connect.Utils.Base
    {

      internal DicomMessage(IHL7ConnectDicomMessage com) : base(com) {} 

      internal new HCHL7ConnectDicomMessage wrapped() { return (HCHL7ConnectDicomMessage) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// ReadOnly: whether the DICOM Message has been stored. The message will not have been stored if the message has just been created using Kernel.createNewDicomMessage or if the message is incoming (and/or just passing through)
      ///</summary>
      public bool Stored()
      {
        return wrapped().Stored() != 0;
      }

      ///<summary>
      /// ReadOnly: if the Document is stored, what the primary key is
      ///</summary>
      public int PrimaryKey()
      {
        return wrapped().PrimaryKey();
      }

      ///<summary>
      /// ReadOnly: a IDicomMessage that describes the DICOM content
      ///</summary>
      public HL7Connect.Dicom.Message Dicom()
      {
        return HL7Connect.Dicom.WrapperFactory.Message(wrapped().Dicom());
      }

      ///<summary>
      /// ReadOnly: String containing text description of the source of the DICOM message.
      ///</summary>
      public string Source()
      {
        return wrapped().Source();
      }

      ///<summary>
      /// Get the message annotation value for the given name.
      ///</summary>
      public string GetAnnotation(string sName)
      {
        return wrapped().GetAnnotation(sName);
      }

      ///<summary>
      /// Set the annotation value for the given name. 
      /// 
      /// Name must be &lt; 250 chars. Value may be any length, but lengths &gt; 32 are not searchable in the web interface You can set annotations on any messages, but annotations are only stored when a messages is saved after being received or when a message status is updated after a reply is received.
      ///</summary>
      public void SetAnnotation(string sName, string sValue)
      {
        wrapped().SetAnnotation(sName, sValue);
      }

    }

    ///<summary>
    /// A list of message or document annotations. Annotations can be set when sending a message or document, and read when receiving. Any annotations set when receiving a message will not be saved. 
    /// 
    /// There can only be one annotation value for each name.
    ///</summary>
    public class Annotations : HL7Connect.Utils.Base
    {

      internal Annotations(IAnnotations com) : base(com) {} 

      internal new HCAnnotations wrapped() { return (HCAnnotations) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Get the name of the ith annotation
      ///</summary>
      public string GetNameByIndex(int index)
      {
        return wrapped().GetNameByIndex(index);
      }

      ///<summary>
      /// THe number of annotations in the list
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public string GetAnnotation(string name)
      {
        return wrapped().GetAnnotation(name);
      }

      ///<summary>
      ///</summary>
      public void SetAnnotation(string name, string Value)
      {
        wrapped().SetAnnotation(name, Value);
      }

    }

    ///<summary>
    /// A message passed to or from HL7Connect. 
    /// 
    /// Whenever HL7Connect passes a message to across a COM interface, both the source and the message will be populated. In most contexts, the source is authoritative - it may occasionally have content (such as XML comments) that is not represented in the message model. Whenever a message is passed across a COM interface to HL7Connect, HL7Connect will use the source if available (for the reason described above); else it will build the source from the Message. If neither property is assigned, an error will occur
    ///</summary>
    public class TransferredMessage : HL7Connect.Utils.Base
    {

      internal TransferredMessage(ITransferredMessage com) : base(com) {} 

      internal new HCTransferredMessage wrapped() { return (HCTransferredMessage) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The binary source of the message
      ///</summary>
      private byte[] propGetSource()
      {
        return HL7Connect.Utils.IStreamWrapper.IStreamToBytes(wrapped().Source);
      }
      private void propSetSource(byte[] value)
      {
        wrapped().Source = new HL7Connect.Utils.StreamWrapper(new MemoryStream(value));
      }
      ///<summary>
      /// The binary source of the message
      ///</summary>
      public byte[] Source { get { return propGetSource(); } set { propSetSource(value); } }

      ///<summary>
      /// The message as an object model
      ///</summary>
      private HL7Connect.V2.Message propGetMessage()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Message);
      }
      private void propSetMessage(HL7Connect.V2.Message value)
      {
        wrapped().Message = value.wrapped();
      }
      ///<summary>
      /// The message as an object model
      ///</summary>
      public HL7Connect.V2.Message Message { get { return propGetMessage(); } set { propSetMessage(value); } }

      ///<summary>
      /// Annotations for the message
      ///</summary>
      private HL7Connect.Exchange.Annotations propGetAnnotations()
      {
        return HL7Connect.Exchange.WrapperFactory.Annotations(wrapped().Annotations);
      }
      private void propSetAnnotations(HL7Connect.Exchange.Annotations value)
      {
        wrapped().Annotations = value.wrapped();
      }
      ///<summary>
      /// Annotations for the message
      ///</summary>
      public HL7Connect.Exchange.Annotations Annotations { get { return propGetAnnotations(); } set { propSetAnnotations(value); } }

    }

    ///<summary>
    /// A Document passed to or from HL7Connect. 
    /// 
    /// Whenever HL7Connect passes a Document to across a COM interface, both the source and the Document will be populated. In most contexts, the source is authoritative - it may occasionally have content (such as XML comments) that is not represented in the Document model. Whenever a Document is passed across a COM interface to HL7Connect, HL7Connect will use the source if available (for the reason described above); else it will build the source from the Document. If neither property is assigned, an error will occur
    ///</summary>
    public class TransferredDocument : HL7Connect.Utils.Base
    {

      internal TransferredDocument(ITransferredDocument com) : base(com) {} 

      internal new HCTransferredDocument wrapped() { return (HCTransferredDocument) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The binary source of the document
      ///</summary>
      private byte[] propGetSource()
      {
        return HL7Connect.Utils.IStreamWrapper.IStreamToBytes(wrapped().Source);
      }
      private void propSetSource(byte[] value)
      {
        wrapped().Source = new HL7Connect.Utils.StreamWrapper(new MemoryStream(value));
      }
      ///<summary>
      /// The binary source of the document
      ///</summary>
      public byte[] Source { get { return propGetSource(); } set { propSetSource(value); } }

      ///<summary>
      /// The document as an object model
      ///</summary>
      private HL7Connect.Cda.ClinicalDocument propGetDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().Document);
      }
      private void propSetDocument(HL7Connect.Cda.ClinicalDocument value)
      {
        wrapped().Document = value.wrapped();
      }
      ///<summary>
      /// The document as an object model
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument Document { get { return propGetDocument(); } set { propSetDocument(value); } }

      ///<summary>
      /// Annotations for the document
      ///</summary>
      private HL7Connect.Exchange.Annotations propGetAnnotations()
      {
        return HL7Connect.Exchange.WrapperFactory.Annotations(wrapped().Annotations);
      }
      private void propSetAnnotations(HL7Connect.Exchange.Annotations value)
      {
        wrapped().Annotations = value.wrapped();
      }
      ///<summary>
      /// Annotations for the document
      ///</summary>
      public HL7Connect.Exchange.Annotations Annotations { get { return propGetAnnotations(); } set { propSetAnnotations(value); } }

    }

    ///<summary>
    /// Used to send a message to HL7Connect, and to get a v2 acknowledgement back.
    ///
    /// In some circumstances, this class is constructed by HL7Connect. In other circumstances, consumer applications create a subclass that uses the protected constructor, and overrides all the public methods. 
    /// If you do not override any of the public methods, and HL7Connect calls them, you'll get an error
    ///</summary>
    public class MessageIn : HL7Connect.Utils.Base, HCHL7ConnectMessageTransferIn
    {

      internal MessageIn(IHL7ConnectMessageTransferIn com) : base(com) {} 

      protected MessageIn() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectMessageTransferIn wrapped() { return com == null ? this : (HCHL7ConnectMessageTransferIn) com; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public virtual int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Will return either tsContinue (interface is started) or tsHold if interface is stopped. (must check with the server using webservices first) 
      /// 
      /// -- Status of the use of the transfer interface- should use go on, should use be held, or is the system shutting down? tsContinuetsHoldtsEnd
      ///</summary>
      public virtual TTransferStatus CheckStatus()
      {
        return wrapped().CheckStatus();
      }

      ///<summary>
      /// Send a message to Hl7Connect, and to get a v2 acknowledgement back. If HL7Connect is configured not to return a reply, reply will be null. This method is not expected to return an exception
      ///</summary>
      public virtual void SendMessage(HL7Connect.Exchange.TransferredMessage msg, HL7Connect.Exchange.TransferredMessage reply)
      {
        wrapped().SendMessage(msg.wrapped(), reply.wrapped());
      }

      int HL7Connect.Interop.IHL7ConnectMessageTransferIn.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectMessageTransferIn.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectMessageTransferIn.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectMessageTransferIn.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectMessageTransferIn.SendMessage(HCTransferredMessage msg, HCTransferredMessage reply)
      {
        SendMessage(HL7Connect.Exchange.WrapperFactory.TransferredMessage(msg), HL7Connect.Exchange.WrapperFactory.TransferredMessage(reply));
        Marshal.ReleaseComObject(msg);
        Marshal.ReleaseComObject(reply);
       }

    }

    ///<summary>
    /// Used when HL7Connect sends a message to the application.
    ///
    /// In some circumstances, this class is constructed by HL7Connect. In other circumstances, consumer applications create a subclass that uses the protected constructor, and overrides all the public methods. 
    /// If you do not override any of the public methods, and HL7Connect calls them, you'll get an error
    ///</summary>
    public class MessageOut : HL7Connect.Utils.Base, HCHL7ConnectMessageTransferOut
    {

      internal MessageOut(IHL7ConnectMessageTransferOut com) : base(com) {} 

      protected MessageOut() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectMessageTransferOut wrapped() { return com == null ? this : (HCHL7ConnectMessageTransferOut) com; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public virtual int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// HL7Connect will call CheckStatus every 500ms or so. See comments for BeMessageReceiver or IHL7ConnectServerMessageReceiverPlugin. 
      /// 
      /// -- Status of the use of the transfer interface- should use go on, should use be held, or is the system shutting down? tsContinuetsHoldtsEnd
      ///</summary>
      public virtual TTransferStatus CheckStatus()
      {
        return wrapped().CheckStatus();
      }

      ///<summary>
      /// HL7Connects sends a message, and the application replies. The reply is already constructed as a message object model which is a reply to the message. The application can either leave the reply as is to accept the message, modify the message contents using the model, or provide a different reponse as a binary. if the handler method throws an exception, the reply will be used as the response with an AE written over any existing value 
      /// 
      /// A reply is required. By default, Hl7Connect will wait the the configured timeout for a response from the interface, not knowing the status. Set the timeout too short, and HL7Connect will abandon the message before you've processed it, if processing takes too long. Set the timeout too long, and HL7Connect will take ages to give up on the client when the client is not available. One way to resolve this is for to notify Hl7Connect with an estimate of how long processing will take. To do this, pass the iId parameter to the NotifyWait procedure (External COM mode only)
      ///</summary>
      public virtual void SendMessage(HL7Connect.Exchange.TransferredMessage msg, int iId, HL7Connect.Exchange.TransferredMessage reply)
      {
        wrapped().SendMessage(msg.wrapped(), iId, reply.wrapped());
      }

      int HL7Connect.Interop.IHL7ConnectMessageTransferOut.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectMessageTransferOut.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectMessageTransferOut.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectMessageTransferOut.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectMessageTransferOut.SendMessage(HCTransferredMessage msg, int iId, HCTransferredMessage reply)
      {
        SendMessage(HL7Connect.Exchange.WrapperFactory.TransferredMessage(msg), iId, HL7Connect.Exchange.WrapperFactory.TransferredMessage(reply));
        Marshal.ReleaseComObject(msg);
        Marshal.ReleaseComObject(reply);
       }

    }

    ///<summary>
    /// Used to send a document to HL7Connect,  and to get a response back
    ///
    /// In some circumstances, this class is constructed by HL7Connect. In other circumstances, consumer applications create a subclass that uses the protected constructor, and overrides all the public methods. 
    /// If you do not override any of the public methods, and HL7Connect calls them, you'll get an error
    ///</summary>
    public class DocumentIn : HL7Connect.Utils.Base, HCHL7ConnectDocumentTransferIn
    {

      internal DocumentIn(IHL7ConnectDocumentTransferIn com) : base(com) {} 

      protected DocumentIn() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectDocumentTransferIn wrapped() { return com == null ? this : (HCHL7ConnectDocumentTransferIn) com; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public virtual int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Will return either tsContinue (interface is started) or tsHold if interface is stopped. 
      /// 
      /// -- Status of the use of the transfer interface- should use go on, should use be held, or is the system shutting down? tsContinuetsHoldtsEnd
      ///</summary>
      public virtual TTransferStatus CheckStatus()
      {
        return wrapped().CheckStatus();
      }

      ///<summary>
      /// send a CDA R2 Document to HL7Connect, and get a response back. This method is not expected to return an exception
      ///</summary>
      public virtual void SendDocument(HL7Connect.Exchange.TransferredDocument doc, HL7Connect.Exchange.DocumentResponse response)
      {
        wrapped().SendDocument(doc.wrapped(), response.wrapped());
      }

      int HL7Connect.Interop.IHL7ConnectDocumentTransferIn.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectDocumentTransferIn.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectDocumentTransferIn.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectDocumentTransferIn.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectDocumentTransferIn.SendDocument(HCTransferredDocument doc, HCDocumentResponse response)
      {
        SendDocument(HL7Connect.Exchange.WrapperFactory.TransferredDocument(doc), HL7Connect.Exchange.WrapperFactory.DocumentResponse(response));
        Marshal.ReleaseComObject(doc);
        Marshal.ReleaseComObject(response);
       }

    }

    ///<summary>
    /// Used when HL7Connect sends a document to the application.
    ///
    /// In some circumstances, this class is constructed by HL7Connect. In other circumstances, consumer applications create a subclass that uses the protected constructor, and overrides all the public methods. 
    /// If you do not override any of the public methods, and HL7Connect calls them, you'll get an error
    ///</summary>
    public class DocumentOut : HL7Connect.Utils.Base, HCHL7ConnectDocumentTransferOut
    {

      internal DocumentOut(IHL7ConnectDocumentTransferOut com) : base(com) {} 

      protected DocumentOut() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectDocumentTransferOut wrapped() { return com == null ? this : (HCHL7ConnectDocumentTransferOut) com; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public virtual int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public virtual void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// HL7Connect will call CheckStatus every 500ms or so. See comments for BeDocumentReceiver or IHL7ConnectServerDocumentReceiverPlugin. 
      /// 
      /// -- Status of the use of the transfer interface- should use go on, should use be held, or is the system shutting down? tsContinuetsHoldtsEnd
      ///</summary>
      public virtual TTransferStatus CheckStatus()
      {
        return wrapped().CheckStatus();
      }

      ///<summary>
      /// HL7Connects sends a CDA R2 Document, and gets a status response back. 
      /// 
      /// By default, Hl7Connect will wait the the configured timeout for a response from the interface, not knowing the status. Set the timeout too short, and HL7Connect will abandon the document before you've processed it, if processing takes too long. Set the timeout too long, and HL7Connect will take ages to give up on the client when the client is not available. One way to resolve this is for to notify Hl7Connect with an estimate of how long processing will take. To do this, pass the iId parameter to the NotifyWait procedure (External COM mode only)
      ///</summary>
      public virtual void SendDocument(HL7Connect.Exchange.TransferredDocument doc, int iId, HL7Connect.Exchange.DocumentResponse response)
      {
        wrapped().SendDocument(doc.wrapped(), iId, response.wrapped());
      }

      int HL7Connect.Interop.IHL7ConnectDocumentTransferOut.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectDocumentTransferOut.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectDocumentTransferOut.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectDocumentTransferOut.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectDocumentTransferOut.SendDocument(HCTransferredDocument doc, int iId, HCDocumentResponse response)
      {
        SendDocument(HL7Connect.Exchange.WrapperFactory.TransferredDocument(doc), iId, HL7Connect.Exchange.WrapperFactory.DocumentResponse(response));
        Marshal.ReleaseComObject(doc);
        Marshal.ReleaseComObject(response);
       }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Exchange.DicomResponse DicomResponse(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.DicomResponse((IDicomResponse) wrapped);
      }

      internal static HL7Connect.Exchange.DocumentResponse DocumentResponse(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.DocumentResponse((IDocumentResponse) wrapped);
      }

      internal static HL7Connect.Exchange.Message Message(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.Message((IHL7ConnectMessage) wrapped);
      }

      internal static HL7Connect.Exchange.Document Document(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.Document((IHL7ConnectDocument) wrapped);
      }

      internal static HL7Connect.Exchange.DicomMessage DicomMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.DicomMessage((IHL7ConnectDicomMessage) wrapped);
      }

      internal static HL7Connect.Exchange.Annotations Annotations(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.Annotations((IAnnotations) wrapped);
      }

      internal static HL7Connect.Exchange.TransferredMessage TransferredMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.TransferredMessage((ITransferredMessage) wrapped);
      }

      internal static HL7Connect.Exchange.TransferredDocument TransferredDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.TransferredDocument((ITransferredDocument) wrapped);
      }

      internal static HL7Connect.Exchange.MessageIn MessageIn(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.MessageIn((IHL7ConnectMessageTransferIn) wrapped);
      }

      internal static HL7Connect.Exchange.MessageOut MessageOut(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.MessageOut((IHL7ConnectMessageTransferOut) wrapped);
      }

      internal static HL7Connect.Exchange.DocumentIn DocumentIn(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.DocumentIn((IHL7ConnectDocumentTransferIn) wrapped);
      }

      internal static HL7Connect.Exchange.DocumentOut DocumentOut(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Exchange.DocumentOut((IHL7ConnectDocumentTransferOut) wrapped);
      }

    }
  }
  namespace Kernel
  {
    ///<summary>
    /// Encapsulates a windows RAS Connection
    ///</summary>
    public class RASConnection : HL7Connect.Utils.Base
    {

      internal RASConnection(IRASConnection com) : base(com) {} 

      internal new HCRASConnection wrapped() { return (HCRASConnection) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// returns true if the interface is connected
      ///</summary>
      public bool Connected()
      {
        return wrapped().Connected() != 0;
      }

      ///<summary>
      /// the name of the connection
      ///</summary>
      public string Name()
      {
        return wrapped().Name();
      }

      ///<summary>
      /// dial the connection. will return when dialling process is complete
      ///</summary>
      public bool Dial()
      {
        return wrapped().Dial() != 0;
      }

      ///<summary>
      /// hang up (if connected). Will return once the hangup process is complete
      ///</summary>
      public void HangUp()
      {
        wrapped().HangUp();
      }

    }

    ///<summary>
    /// handle to a HL7Connect Interface
    ///</summary>
    public class Interface : HL7Connect.Utils.Base
    {

      internal Interface(IHL7ConnectInterface com) : base(com) {} 

      internal new HCHL7ConnectInterface wrapped() { return (HCHL7ConnectInterface) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Read-Only: Name of interface as shown in HL7Connect Status Page
      ///</summary>
      public string Name()
      {
        return wrapped().Name();
      }

      ///<summary>
      /// Read-Only: Unique Name of interface as shown in HL7Connect logs etc
      ///</summary>
      public string UniqueName()
      {
        return wrapped().UniqueName();
      }

      ///<summary>
      /// ReadOnly: Name of
      ///</summary>
      public int DBKey()
      {
        return wrapped().DBKey();
      }

      ///<summary>
      /// ReadOnly: true if the interface is started. This means that the interface is trying to be operational but that it is waiting for the remote system
      ///</summary>
      public bool Started()
      {
        return wrapped().Started() != 0;
      }

      ///<summary>
      /// ReadOnly: true if the interface is fully operational
      ///</summary>
      public bool Connected()
      {
        return wrapped().Connected() != 0;
      }

      ///<summary>
      /// ReadOnly: true if the interface is a sender. alse if it is a receiver. (Cannot be both)
      ///</summary>
      public bool Sender()
      {
        return wrapped().Sender() != 0;
      }

      ///<summary>
      /// ReadOnly: string description of the Transport layer. can be one of:    TCP/IP    File    DLL    HTTP    Email
      ///</summary>
      public string CarrierType()
      {
        return wrapped().CarrierType();
      }

      ///<summary>
      /// ReadOnly: The status description returned by the transport layer
      ///</summary>
      public string StatusDesc()
      {
        return wrapped().StatusDesc();
      }

      ///<summary>
      /// Start the interface. There is no way to find whether the interface has started (this problem is under consideration)
      ///</summary>
      public void Start()
      {
        wrapped().Start();
      }

      ///<summary>
      /// Stop the interface. All scripts associated with the interface will need to stop before the interface actually stops. Do not wait for the interface to be stopped (i.e. Started = false) if you are in an interface script. 
      /// 
      /// Some information about the stop must be provided. Is it ok for HL7Connect to restart the interface after the configured auto restart period? How should the stop reason be recorded? For Code, you can use one of these values: 'Script-Error', 'Kernel-Stop', 'Drop-Interface', 'Start-Failed', 'Synchronization-Failed', 'Unhandled-Error', 'Auto-Restart', 'Licence-Issue', or the reason is interpreted as 'Script-Request'
      ///</summary>
      public void Stop(bool AllowRestart, string Code, string Description)
      {
        wrapped().Stop(AllowRestart ? (sbyte) 0 : (sbyte) -1, Code, Description);
      }

      ///<summary>
      /// Restart the interface. All scripts associated with the interface will need to stop before the interface actually stops. Do not wait for the interface this if you are in a interface script. 
      /// 
      /// Some information about the restart must be provided. How should the restart reason be recorded? For Code, you can use one of these values: 'Script-Error', 'Kernel-Stop', 'Drop-Interface', 'Start-Failed', 'Synchronization-Failed', 'Unhandled-Error', 'Auto-Restart', 'Licence-Issue', or the reason is interpreted as 'Script-Request'
      ///</summary>
      public void Restart(string Code, string Description)
      {
        wrapped().Restart(Code, Description);
      }

      ///<summary>
      /// Take all the messages or documents currently waiting in the Virtual Queue "Name", with an optional partition, and send them to the interface. A blank partition means any messages. If partition is not blank, bLike specifies whether an exact match or an SQL like match is used. If bLike is true, the partition needs to contain the appropriate SQL wild cards (* or %) 
      /// 
      /// The interface must be an outgoing interface with the same type as the queue. The messages or documents will be added to the sender interface queue, in the order they were added to the virtual queue. If a message/ocument is in the virtual queue more than once, it will be sent more than once. The messages/documents will be marked as handled in the Virtual Queue Return the number of messages sent Equivalent to IHL7ConnectVirtualQueue.SendToInterface
      ///</summary>
      public int SendFromQueue(string Name, string Partition, bool bLike)
      {
        return wrapped().SendFromQueue(Name, Partition, bLike ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// ReadOnly: the number of messages processed OK by the interface
      ///</summary>
      public int MsgCount()
      {
        return wrapped().MsgCount();
      }

      ///<summary>
      /// ReadOnly: the number of AE's for the interface
      ///</summary>
      public int ErrCount()
      {
        return wrapped().ErrCount();
      }

      ///<summary>
      /// ReadOnly: the number of AR's for the interface
      ///</summary>
      public int RejCount()
      {
        return wrapped().RejCount();
      }

      ///<summary>
      /// ReadOnly: the number of internal transport errors for the interface
      ///</summary>
      public int IntErrCount()
      {
        return wrapped().IntErrCount();
      }

      ///<summary>
      /// ReadOnly: Date of last message
      ///</summary>
      public DateTime LastUse()
      {
        return wrapped().LastUse();
      }

      ///<summary>
      /// Write an error to the interface. The error will appear in the intenral error section of the interface
      ///</summary>
      public void LogError(string Error)
      {
        wrapped().LogError(Error);
      }

    }

    ///<summary>
    ///</summary>
    public class IdServices : HL7Connect.Utils.Base
    {

      internal IdServices(IIdServices com) : base(com) {} 

      internal new HCIdServices wrapped() { return (HCIdServices) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Look up the given name in the identity spaces table and get the identifier (GUID / OID). If the name is not found, an exception will be raised.
      ///</summary>
      public string IdByName(string Name)
      {
        return wrapped().IdByName(Name);
      }

      ///<summary>
      /// Get the OID for snomed
      ///</summary>
      public string Snomed()
      {
        return wrapped().Snomed();
      }

      ///<summary>
      /// Get the OID for snomed
      ///</summary>
      public string LOINC()
      {
        return wrapped().LOINC();
      }

      ///<summary>
      /// Get the OID that uniquely identifies this instance of HL7Connect
      ///</summary>
      public string HL7Connect()
      {
        return wrapped().HL7Connect();
      }

    }

    ///<summary>
    /// Interface to handle any of the events that occur in HL7Connect. The different events may be differentiated either by their class or by their EventName property 
    /// 
    /// Once loaded, the event handler will be kept loaded until all the contexts in which it is used are closed. (i.e. interfaces stopped, and/or kernel shut down). Event handlers generally need to be thread safe - see discussion on the Start method
    ///
    /// To use this class, create a subclass that uses the protected constructor, and override all the abstract methods.
    ///</summary>
    public abstract class EventHandler : HL7Connect.Utils.Base, HCHL7ConnectEventHandler
    {

      protected EventHandler() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectEventHandler wrapped() { return this; }

      /// <summary>
      ///   The ThreadMode is available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public TEventHandlerThreadMode ThreadMode { get; private set; }

      /// <summary>
      ///   The Services are available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Services.Access Services { get; private set; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public abstract int Handle();

      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public abstract string GetProperty(string Name);

      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public abstract void SetProperty(string Name, string Value);

      ///<summary>
      /// Initialises the interface that will be handling events. Usually called when the kernel starts or when an interface starts. Start will only be called once for each instance - there will be a separate instance of the COM Interface for each event/Interface combination on HL7Connect. 
      /// 
      /// The threadmode defines how the interface will be used in regard to threads. There is three possibilities: { etmSingleThread (0): the interface will only ever be used from one thread (Start, Execute and Stop are all called from the same thread);  etmLimitedThreading = (1): the interface will only ever be called by one thread at once, but it may not be the same thread;  etmMultithread = (2): the interface may be used by multiple threads concurrently; }Kernel start and stop are single threaded, as is the User Initiated Event. Interface start and Stop are limited multithread because start, stop and Execute occur in different threads. Events in outbound interfaces are limited multithread: start and stop are called on a different thread to the Execute method, but there is only a single thread servicing the outbound interface. Inbound threads may be actually be limited multi-thread (files, scripts) or fully multithreaded (HTTP, Web, XDR, etc) or it may depend on the configuration (TCP/IP - whether multiple clients are allowed), but all this depends on the configuration of the interface which may change over the lifecycle of the interface, so they are always stated to be fully multithreaded. The rest of the server interfaces (IHL7ConnectServerMessageReceiverPlugin, etc) are effectively limited multithread. Note that all of the interfaces are defined as fully multi-threaded to COM. Note also that when run test cases are run, threadmode is always single threaded.
      ///</summary>
      public abstract void Start(TEventHandlerThreadMode threadMode, HL7Connect.Services.Access services);

      ///<summary>
      /// Called when the event occurs, as configured in HL7Connect.
      ///</summary>
      public abstract void Execute(HL7Connect.Events.Base event_);

      ///<summary>
      /// Called when the interface or kernel is stopping as appropriate for the event type.
      ///</summary>
      public abstract void Stop();

      int HL7Connect.Interop.IHL7ConnectEventHandler.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectEventHandler.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectEventHandler.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      void IHL7ConnectEventHandler.Start(TEventHandlerThreadMode threadMode, HCHL7ConnectServices services)
      {
        ThreadMode = threadMode;
        Services = HL7Connect.Services.WrapperFactory.Access(services);
        Start(ThreadMode, Services);
       }

      void IHL7ConnectEventHandler.Execute(HCScriptEvent event_)
      {
        Execute(HL7Connect.Events.WrapperFactory.Base(event_));
        Marshal.ReleaseComObject(event_);
       }

      void IHL7ConnectEventHandler.Stop()
      {
        Stop();
        Marshal.ReleaseComObject(Services.com);
        Services = null;
       }

    }

    ///<summary>
    /// When HL7Connect hosts a COM plugin that receives messages from HL7Connect, it will create an object that must implement this interface. HL7Connect will always send both source and message object.
    ///
    /// To use this class, create a subclass that uses the protected constructor, and override all the abstract methods.
    ///</summary>
    public abstract class MessageReceiver : HL7Connect.Exchange.MessageOut, HCHL7ConnectServerMessageReceiverPlugin
    {

      protected MessageReceiver() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectServerMessageReceiverPlugin wrapped() { return this; }

      /// <summary>
      ///   The Services are available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Services.Access Services { get; private set; }

      ///<summary>
      /// Allows the implementation to initialise itself. Start is always called first after the interface is created;
      ///</summary>
      public abstract void Start(HL7Connect.Services.Access services);

      ///<summary>
      /// notification that Stop will shortly be called. No further messages will be sent after pre-stop is called
      ///</summary>
      public abstract void Prestop();

      ///<summary>
      /// Allows the implementation to clean up. Stop is not usually called while a message is being processed, but this may happen if a message is taking unusually long to process (>30seconds) or there is some other error condition. No further calls will be made to the interface under any conditions. The interface is always released after Stop is called.
      ///</summary>
      public abstract void Stop();

      int HL7Connect.Interop.IHL7ConnectServerMessageReceiverPlugin.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectServerMessageReceiverPlugin.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectServerMessageReceiverPlugin.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectServerMessageReceiverPlugin.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectServerMessageReceiverPlugin.SendMessage(HCTransferredMessage msg, int iId, HCTransferredMessage reply)
      {
        SendMessage(HL7Connect.Exchange.WrapperFactory.TransferredMessage(msg), iId, HL7Connect.Exchange.WrapperFactory.TransferredMessage(reply));
        Marshal.ReleaseComObject(msg);
        Marshal.ReleaseComObject(reply);
       }

      void IHL7ConnectServerMessageReceiverPlugin.Start(HCHL7ConnectServices services)
      {
        Services = HL7Connect.Services.WrapperFactory.Access(services);
        Start(Services);
       }

      void IHL7ConnectServerMessageReceiverPlugin.Prestop()
      {
        Prestop();
       }

      void IHL7ConnectServerMessageReceiverPlugin.Stop()
      {
        Stop();
        Marshal.ReleaseComObject(Services.com);
        Services = null;
       }

      int HL7Connect.Interop.IHL7ConnectMessageTransferOut.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectMessageTransferOut.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectMessageTransferOut.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectMessageTransferOut.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectMessageTransferOut.SendMessage(HCTransferredMessage msg, int iId, HCTransferredMessage reply)
      {
        SendMessage(HL7Connect.Exchange.WrapperFactory.TransferredMessage(msg), iId, HL7Connect.Exchange.WrapperFactory.TransferredMessage(reply));
        Marshal.ReleaseComObject(msg);
        Marshal.ReleaseComObject(reply);
       }

    }

    ///<summary>
    /// When HL7Connect hosts a COM plugin that receives documents from HL7Connect, it will create an object that must implement this interface. HL7Connect will always send both source and document object.
    ///
    /// To use this class, create a subclass that uses the protected constructor, and override all the abstract methods.
    ///</summary>
    public abstract class DocumentReceiver : HL7Connect.Exchange.DocumentOut, HCHL7ConnectServerDocumentReceiverPlugin
    {

      protected DocumentReceiver() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectServerDocumentReceiverPlugin wrapped() { return this; }

      /// <summary>
      ///   The Services are available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Services.Access Services { get; private set; }

      ///<summary>
      /// Allows the implementation to initialise itself. Start is always called first after the interface is created.
      ///</summary>
      public abstract void Start(HL7Connect.Services.Access services);

      ///<summary>
      /// notification that Stop will shortly be called. No further documents will be sent after pre-stop is called
      ///</summary>
      public abstract void Prestop();

      ///<summary>
      /// Allows the implementation to clean up. Stop is not usually called while a document is being processed, but this may happen if a document is taking unusually long to process (>30seconds) or there is some other error condition. No further calls will be made to the interface under any conditions. The interface is always released after Stop is called.
      ///</summary>
      public abstract void Stop();

      int HL7Connect.Interop.IHL7ConnectServerDocumentReceiverPlugin.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectServerDocumentReceiverPlugin.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectServerDocumentReceiverPlugin.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectServerDocumentReceiverPlugin.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectServerDocumentReceiverPlugin.SendDocument(HCTransferredDocument doc, int iId, HCDocumentResponse response)
      {
        SendDocument(HL7Connect.Exchange.WrapperFactory.TransferredDocument(doc), iId, HL7Connect.Exchange.WrapperFactory.DocumentResponse(response));
        Marshal.ReleaseComObject(doc);
        Marshal.ReleaseComObject(response);
       }

      void IHL7ConnectServerDocumentReceiverPlugin.Start(HCHL7ConnectServices services)
      {
        Services = HL7Connect.Services.WrapperFactory.Access(services);
        Start(Services);
       }

      void IHL7ConnectServerDocumentReceiverPlugin.Prestop()
      {
        Prestop();
       }

      void IHL7ConnectServerDocumentReceiverPlugin.Stop()
      {
        Stop();
        Marshal.ReleaseComObject(Services.com);
        Services = null;
       }

      int HL7Connect.Interop.IHL7ConnectDocumentTransferOut.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectDocumentTransferOut.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectDocumentTransferOut.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      TTransferStatus IHL7ConnectDocumentTransferOut.CheckStatus()
      {
        return CheckStatus();
       }

      void IHL7ConnectDocumentTransferOut.SendDocument(HCTransferredDocument doc, int iId, HCDocumentResponse response)
      {
        SendDocument(HL7Connect.Exchange.WrapperFactory.TransferredDocument(doc), iId, HL7Connect.Exchange.WrapperFactory.DocumentResponse(response));
        Marshal.ReleaseComObject(doc);
        Marshal.ReleaseComObject(response);
       }

    }

    ///<summary>
    /// When HL7Connect hosts the COM plugin that sends messages to HL7Connect, it will create an object that must implement this interface. When sending, you can send either source or a message model, or both. If you send both, HL7Connect will use the source by preference
    ///
    /// To use this class, create a subclass that uses the protected constructor, and override all the abstract methods.
    ///</summary>
    public abstract class MessageSender : HL7Connect.Utils.Base, HCHL7ConnectServerMessageSenderPlugin
    {

      protected MessageSender() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectServerMessageSenderPlugin wrapped() { return this; }

      /// <summary>
      ///   The Services are available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Services.Access Services { get; private set; }

      /// <summary>
      ///   The Handler is available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Exchange.MessageIn Handler { get; private set; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public abstract int Handle();

      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public abstract string GetProperty(string Name);

      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public abstract void SetProperty(string Name, string Value);

      ///<summary>
      /// Allows the implementation to initialise itself. Start is always called first after the interface is created. The handler is what the implementation can call to send messages to HL7Connect. 
      /// 
      /// COM: The implementation is responsible for releasing the handler when it is finished with it. DotNet: The API will free the handler when Stop is called
      ///</summary>
      public abstract void Start(HL7Connect.Services.Access services, HL7Connect.Exchange.MessageIn handler);

      ///<summary>
      /// notification that Stop will shortly be called. No further messages will be accepted on the handler after pre-stop is called.
      ///</summary>
      public abstract void Prestop();

      ///<summary>
      /// Allows the implementation to clean up. Prior to calling Stop, HL7Connect will wait for any messages being processed by the handler when prestop is called to complete. The interface is always released after Stop is called.
      ///</summary>
      public abstract void Stop();

      int HL7Connect.Interop.IHL7ConnectServerMessageSenderPlugin.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectServerMessageSenderPlugin.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectServerMessageSenderPlugin.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      void IHL7ConnectServerMessageSenderPlugin.Start(HCHL7ConnectServices services, HCHL7ConnectMessageTransferIn handler)
      {
        Services = HL7Connect.Services.WrapperFactory.Access(services);
        Handler = HL7Connect.Exchange.WrapperFactory.MessageIn(handler);
        Start(Services, Handler);
       }

      void IHL7ConnectServerMessageSenderPlugin.Prestop()
      {
        Prestop();
       }

      void IHL7ConnectServerMessageSenderPlugin.Stop()
      {
        Stop();
        Marshal.ReleaseComObject(Services.com);
        Marshal.ReleaseComObject(Handler.com);
        Services = null;
        Handler = null;
       }

    }

    ///<summary>
    /// When HL7Connect hosts the a COM plugin that sends documents to HL7Connect, it will create an object that must implement this interface. When sending, you can send either source or a document model, or both. If you send both, HL7Connect will use the source by preference
    ///
    /// To use this class, create a subclass that uses the protected constructor, and override all the abstract methods.
    ///</summary>
    public abstract class DocumentSender : HL7Connect.Utils.Base, HCHL7ConnectServerDocumentSenderPlugin
    {

      protected DocumentSender() : base(null)
      {
        // defined to be called from subclasses that implement this interface
      } 

      internal new HCHL7ConnectServerDocumentSenderPlugin wrapped() { return this; }

      /// <summary>
      ///   The Services are available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Services.Access Services { get; private set; }

      /// <summary>
      ///   The Handler is available during and between the Start and Stop methods (Start parameter stored as a property for convenience).
      /// <summary>
      public HL7Connect.Exchange.DocumentIn Handler { get; private set; }

      /// <summary>
      ///   returns 0 in this context; applications should return 0 when subclassing this class (Handle() is not used in these contexts).
      /// <summary>
      public abstract int Handle();

      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public abstract string GetProperty(string Name);

      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public abstract void SetProperty(string Name, string Value);

      ///<summary>
      /// Allows the implementation to initialise itself. Start is always called first after the interface is created. The handler is what the implementation can call to send documents to HL7Connect. 
      /// 
      /// COM: The implementation is responsible for releasing the handler when it is finished with it. DotNet: The API will free the handler when Stop is called
      ///</summary>
      public abstract void Start(HL7Connect.Services.Access services, HL7Connect.Exchange.DocumentIn handler);

      ///<summary>
      /// notification that Stop will shortly be called. No further documents will be accepted on the handler after pre-stop is called.
      ///</summary>
      public abstract void Prestop();

      ///<summary>
      /// Allows the implementation to clean up. Prior to calling Stop, HL7Connect will wait for any document being processed by the handler when prestop is called to complete. The interface is always released after Stop is called.
      ///</summary>
      public abstract void Stop();

      int HL7Connect.Interop.IHL7ConnectServerDocumentSenderPlugin.Handle()
      {
        return 0; // Handle(); because HL7Connect doesn't use this feature on these types of interfaces
      }

      string HL7Connect.Interop.IHL7ConnectServerDocumentSenderPlugin.GetCOMProperty(string Name)
      {
        return GetProperty(Name);
      }

      void HL7Connect.Interop.IHL7ConnectServerDocumentSenderPlugin.SetCOMProperty(string Name, string Value)
      {
        SetProperty(Name, Value);
      }

      void IHL7ConnectServerDocumentSenderPlugin.Start(HCHL7ConnectServices services, HCHL7ConnectDocumentTransferIn handler)
      {
        Services = HL7Connect.Services.WrapperFactory.Access(services);
        Handler = HL7Connect.Exchange.WrapperFactory.DocumentIn(handler);
        Start(Services, Handler);
       }

      void IHL7ConnectServerDocumentSenderPlugin.Prestop()
      {
        Prestop();
       }

      void IHL7ConnectServerDocumentSenderPlugin.Stop()
      {
        Stop();
        Marshal.ReleaseComObject(Services.com);
        Marshal.ReleaseComObject(Handler.com);
        Services = null;
        Handler = null;
       }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Kernel.RASConnection RASConnection(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Kernel.RASConnection((IRASConnection) wrapped);
      }

      internal static HL7Connect.Kernel.Interface Interface(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Kernel.Interface((IHL7ConnectInterface) wrapped);
      }

      internal static HL7Connect.Kernel.IdServices IdServices(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Kernel.IdServices((IIdServices) wrapped);
      }

    }
  }
  namespace Ucum
  {
    ///<summary>
    /// Basic UCUM services
    ///</summary>
    public class Manager : HL7Connect.Utils.Base
    {

      internal Manager(IUcumManager com) : base(com) {} 

      internal new HCUcumManager wrapped() { return (HCUcumManager) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Create the value "1"
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateOne(string value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateOne(value));
      }

      ///<summary>
      /// Create the value "0"
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateZero(string value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateZero(value));
      }

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromString(string value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromString(value));
      }

      ///<summary>
      /// Create a Decimal from an integer. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromInteger(long value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromInteger(value));
      }

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromReal(double value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromReal(value));
      }

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromCOMDecimal(decimal value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromCOMDecimal(value));
      }

      ///<summary>
      /// The current version of UCUM that is in use.
      ///</summary>
      public string Version()
      {
        return wrapped().Version();
      }

      ///<summary>
      /// return a list of the defined types of units in this UCUM version (csv strings)
      ///</summary>
      public string Properties()
      {
        return wrapped().Properties();
      }

      ///<summary>
      /// given a unit, return a formal description of what the units stand for using full names
      ///</summary>
      public string Analyse(string code)
      {
        return wrapped().Analyse(code);
      }

      ///<summary>
      /// validate whether a unit code is a valid UCUM unit. returns a blank string/null if valid, or an error message describing the problem
      ///</summary>
      public string Validate(string code)
      {
        return wrapped().Validate(code);
      }

      ///<summary>
      /// validate whether a units are valid UCUM units and additionally require that the units from a particular property. blank/null if valid, or an error message describing the problem
      ///</summary>
      public string ValidateInProperty(string code, string propertyType)
      {
        return wrapped().ValidateInProperty(code, propertyType);
      }

      ///<summary>
      /// validate whether a units are valid UCUM units and additionally require that the units match a particular base canonical unit. blank/null if valid, or an error message describing the problem. You can get the canonical units using CanonicalUnits
      ///</summary>
      public string ValidateCanonicalUnits(string code, string canonical)
      {
        return wrapped().ValidateCanonicalUnits(code, canonical);
      }

      ///<summary>
      /// given a set of units, return their canonical form. The canonical unit is a private construct that is used in ValidateCanonicalUnits, it might change in future releases.
      ///</summary>
      public string CanonicalUnits(string code)
      {
        return wrapped().CanonicalUnits(code);
      }

      ///<summary>
      /// For a given canonical unit, return all the defined units that have the same canonical unit. Note that the list of possible units is usually infinite - this returns the any base units defined in UCUM. (csv strings)
      ///</summary>
      public string DefinedForms(string code)
      {
        return wrapped().DefinedForms(code);
      }

      ///<summary>
      /// given a value and source unit, return the value in the given dest unit. An exception is thrown if the conversion is not possible
      ///</summary>
      public HL7Connect.Ucum.QDecimal Convert(HL7Connect.Ucum.QDecimal value, string sourceUnit, string destUnit)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Convert(value.wrapped(), sourceUnit, destUnit));
      }

    }

    ///<summary>
    /// Precision aware Decimal implementation. Any size number with any number of significant digits is supported. 
    /// 
    /// Note that operations are precision aware operations. Note that whole numbers are assumed to have unlimited precision. For example:   2 x 2 = 4   2.0 x 2.0 = 4.0   2.00 x 2.0 = 4.0 and  10 / 3 = 3.33333333333333333333333333333333333333333333333  10.0 / 3 = 3.33  10.00 / 3 = 3.333  10.00 / 3.0 = 3.3  10 / 3.0 = 3.3 Addition   2 + 0.001 = 2.001   2.0 + 0.001 = 2.0 Note that the string representation is precision limited, but the internal representation is not. why QDecimal as a name in the DotNet API? It's for quantities, but just calling it Decimal clashes with System.Decimal which is always in scope
    ///</summary>
    public class QDecimal : HL7Connect.Utils.Base
    {

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public QDecimal(string value) : base(Cda.WrapperFactory.WorkingFactory.wrapped().CreateDecimalFromString(value)) {} 

      ///<summary>
      /// Create a Decimal from an integer. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public QDecimal(long value) : base(Cda.WrapperFactory.WorkingFactory.wrapped().CreateDecimalFromInteger(value)) {} 

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public QDecimal(double value) : base(Cda.WrapperFactory.WorkingFactory.wrapped().CreateDecimalFromReal(value)) {} 

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public QDecimal(decimal value) : base(Cda.WrapperFactory.WorkingFactory.wrapped().CreateDecimalFromCOMDecimal(value)) {} 

      internal QDecimal(ISmartDecimal com) : base(com) {} 

      internal new HCSmartDecimal wrapped() { return (HCSmartDecimal) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// true if this value is zero (also implies isWholeNumber = true)
      ///</summary>
      public bool IsZero()
      {
        return wrapped().IsZero() != 0;
      }

      ///<summary>
      /// true if this value is zero (also implies isWholeNumber = true)
      ///</summary>
      public bool IsOne()
      {
        return wrapped().IsOne() != 0;
      }

      ///<summary>
      /// true if this value is a whole number
      ///</summary>
      public bool IsWholeNumber()
      {
        return wrapped().IsWholeNumber() != 0;
      }

      ///<summary>
      /// retrun this number with any decimal places removed
      ///</summary>
      public HL7Connect.Ucum.QDecimal Trunc()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Trunc());
      }

      ///<summary>
      /// return this value multiplied by other value.
      ///</summary>
      public HL7Connect.Ucum.QDecimal Multiply(HL7Connect.Ucum.QDecimal oOther)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Multiply(oOther.wrapped()));
      }

      ///<summary>
      /// return this value divided by other value.
      ///</summary>
      public HL7Connect.Ucum.QDecimal Divide(HL7Connect.Ucum.QDecimal oOther)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Divide(oOther.wrapped()));
      }

      ///<summary>
      /// return the number of times other will "fit into" this number. This is usually called Integer Division, but in this implementation, neither this nor other needs to be a whole number; however the result of this operation will always be a whole number
      ///</summary>
      public HL7Connect.Ucum.QDecimal DivInt(HL7Connect.Ucum.QDecimal oOther)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().DivInt(oOther.wrapped()));
      }

      ///<summary>
      /// modulus - the left over when fitting other into this. 
      /// 
      /// this modulo other = this - (other * (this divint other))
      ///</summary>
      public HL7Connect.Ucum.QDecimal Modulo(HL7Connect.Ucum.QDecimal oOther)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Modulo(oOther.wrapped()));
      }

      ///<summary>
      /// return the result of adding this to other
      ///</summary>
      public HL7Connect.Ucum.QDecimal Add(HL7Connect.Ucum.QDecimal oOther)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Add(oOther.wrapped()));
      }

      ///<summary>
      /// return the result of subtracting other from this
      ///</summary>
      public HL7Connect.Ucum.QDecimal Subtract(HL7Connect.Ucum.QDecimal oOther)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Subtract(oOther.wrapped()));
      }

      ///<summary>
      /// Represent the decimal in the native COM decimal format. Precision is lost in this representation.
      ///</summary>
      public decimal AsCOMDecimal()
      {
        return wrapped().AsCOMDecimal();
      }

      ///<summary>
      /// Represent the decimal in the native COM decimal format. Precision is lost in this representation.
      ///</summary>
      public long AsInt64()
      {
        return wrapped().AsInt64();
      }

      ///<summary>
      /// whether to use a scientific representation (i.e. 1e10). This value is carried across operations
      ///</summary>
      private bool propGetIsScientific()
      {
        return wrapped().IsScientific != 0;
      }
      private void propSetIsScientific(bool value)
      {
        wrapped().IsScientific = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// whether to use a scientific representation (i.e. 1e10). This value is carried across operations
      ///</summary>
      public bool IsScientific { get { return propGetIsScientific(); } set { propSetIsScientific(value); } }

      ///<summary>
      /// the precision of the value. You can change the precision if you want.
      ///</summary>
      private int propGetPrecision()
      {
        return wrapped().Precision;
      }
      private void propSetPrecision(int value)
      {
        wrapped().Precision = value;
      }
      ///<summary>
      /// the precision of the value. You can change the precision if you want.
      ///</summary>
      public int Precision { get { return propGetPrecision(); } set { propSetPrecision(value); } }

      ///<summary>
      /// String representation of the value - will use scientific or decimal notation as specified by the IsScientific property
      ///</summary>
      private string propGetAsString()
      {
        return wrapped().AsString;
      }
      ///<summary>
      /// String representation of the value - will use scientific or decimal notation as specified by the IsScientific property
      ///</summary>
      public string AsString { get { return propGetAsString(); } }

      ///<summary>
      /// String representation using scientific notiation
      ///</summary>
      private string propGetAsScientific()
      {
        return wrapped().AsScientific;
      }
      ///<summary>
      /// String representation using scientific notiation
      ///</summary>
      public string AsScientific { get { return propGetAsScientific(); } }

      ///<summary>
      /// String representation using decimal notiation
      ///</summary>
      private string propGetAsDecimal()
      {
        return wrapped().AsDecimal;
      }
      ///<summary>
      /// String representation using decimal notiation
      ///</summary>
      public string AsDecimal { get { return propGetAsDecimal(); } }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Ucum.Manager Manager(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ucum.Manager((IUcumManager) wrapped);
      }

      internal static HL7Connect.Ucum.QDecimal QDecimal(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ucum.QDecimal((ISmartDecimal) wrapped);
      }

    }
  }
  namespace Loinc
  {
    ///<summary>
    /// Basic Loinc services
    ///</summary>
    public class Manager : HL7Connect.Utils.Base
    {

      internal Manager(ILoincManager com) : base(com) {} 

      internal new HCLoincManager wrapped() { return (HCLoincManager) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The current version of Loinc that is in use.
      ///</summary>
      public string Version()
      {
        return wrapped().Version();
      }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Loinc.Manager Manager(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Loinc.Manager((ILoincManager) wrapped);
      }

    }
  }
  namespace Util
  {
    ///<summary>
    /// A list of bytes
    ///</summary>
    public class Buffer : HL7Connect.Utils.Base
    {

      internal Buffer(IAdvBuffer com) : base(com) {} 

      internal new HCAdvBuffer wrapped() { return (HCAdvBuffer) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Make the buffer empty. 
      /// 
      /// note that valid buffers must have content
      ///</summary>
      public void Clear()
      {
        wrapped().Clear();
      }

      ///<summary>
      /// Fill the buffer with contents from the named file
      ///</summary>
      public void LoadFromFileName(string sFilename)
      {
        wrapped().LoadFromFileName(sFilename);
      }

      ///<summary>
      /// Save the buffer contents to the named file
      ///</summary>
      public void SaveToFileName(string sFilename)
      {
        wrapped().SaveToFileName(sFilename);
      }

      ///<summary>
      /// The number of bytes in the buffer
      ///</summary>
      private int propGetSize()
      {
        return wrapped().Size;
      }
      private void propSetSize(int value)
      {
        wrapped().Size = value;
      }
      ///<summary>
      /// The number of bytes in the buffer
      ///</summary>
      public int Size { get { return propGetSize(); } set { propSetSize(value); } }

      ///<summary>
      /// The contents of the buffer as a string, one byte per character. The content may include the ascii characters with value &lt; 32 including character 0.
      ///</summary>
      private string propGetAsAscii()
      {
        return wrapped().AsAscii;
      }
      private void propSetAsAscii(string value)
      {
        wrapped().AsAscii = value;
      }
      ///<summary>
      /// The contents of the buffer as a string, one byte per character. The content may include the ascii characters with value &lt; 32 including character 0.
      ///</summary>
      public string AsAscii { get { return propGetAsAscii(); } set { propSetAsAscii(value); } }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Util.Buffer Buffer(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Util.Buffer((IAdvBuffer) wrapped);
      }

    }
  }
  namespace Cda
  {
    ///<summary>
    /// base class for all CDA types
    ///</summary>
    public class Base : HL7Connect.Utils.Base
    {

      ///<summary>
      /// Create a type by it's type name
      ///</summary>
      public Base(string sName) : base(Cda.WrapperFactory.WorkingFactory.wrapped().CreateByName(sName)) {} 

      internal Base(Iv3Base com) : base(com) {} 

      internal new HCv3Base wrapped() { return (HCv3Base) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The name of the type in the RIM. For data types and structured types, RIMClassName = CDAClassName
      ///</summary>
      public string RIMClassName()
      {
        return wrapped().RIMClassName();
      }

      ///<summary>
      /// The name of the type in the CDA specification
      ///</summary>
      public string CDAClassName()
      {
        return wrapped().CDAClassName();
      }

      ///<summary>
      /// if this is equal to other according the CDA/Data types Specification. CDA (RIM) classes are only equal if they are the same instance. Narrative is equal if their content model is the same Data type equality is evaluated according to the rules in ISO 21090.
      ///</summary>
      public bool Equals(HL7Connect.Cda.Base oOther)
      {
        return wrapped().Equals(oOther.wrapped()) != 0;
      }

      ///<summary>
      /// Reset all the properties to their default values
      ///</summary>
      public void Clear()
      {
        wrapped().Clear();
      }

    }

    public class BaseList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Base>
    {
      public BaseList(Iv3BaseList com) : base(com) {}
      internal new HCv3BaseList wrapped() { return (HCv3BaseList) com; }
  
      public Base this[int index]
      {
        get { return (Base) HL7Connect.Cda.WrapperFactory.Base(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Base item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Base Append()
      {
        return (Base) HL7Connect.Cda.WrapperFactory.Base(wrapped().Append());
      }
  
      public void Insert(int index, Base item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Base item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Base item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Base[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (Base) HL7Connect.Cda.WrapperFactory.Base(wrapped().Item(i));
      }
  
      public bool Remove(Base item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class BaseListEnumerator : IEnumerator<Base>
      {
        private Iv3BaseList com;
        int index = -1;
  
        public BaseListEnumerator(Iv3BaseList com)
        {
          this.com = com;
        }
  
        public Base Current { get { return (Base) HL7Connect.Cda.WrapperFactory.Base(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (Base) HL7Connect.Cda.WrapperFactory.Base(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Base> GetEnumerator()
      {
        return new BaseListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new BaseListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// &nbsp
    ///</summary>
    public class DataValue : HL7Connect.Cda.Base
    {

      internal DataValue(Iv3DataValue com) : base(com) {} 

      internal new HCv3DataValue wrapped() { return (HCv3DataValue) com; }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class DataTypeCollection : HL7Connect.Utils.Base
    {

      internal DataTypeCollection(Iv3DataTypeCollection com) : base(com) {} 

      internal new HCv3DataTypeCollection wrapped() { return (HCv3DataTypeCollection) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
    }

    ///<summary>
    /// Information about the history of this value: period of validity and a reference to an identified event that established this value as valid.
    /// 
    ///   Because of the way that the types are defined, a number of attributes of the datatypes have values with a type derived from HXIT. In these cases the HXIT attributes are constrained to null. The only case where the HXIT attributes are allowed within a datatype is on items in a collection (DSET, LIST, BAG, HIST). The use of these attributes is generally subject to further constraints in the specifications that make use of these types
    ///</summary>
    public class HXIT : HL7Connect.Cda.DataValue
    {

      internal HXIT(Iv3HXIT com) : base(com) {} 

      internal new HCv3HXIT wrapped() { return (HCv3HXIT) com; }

      ///<summary>
      /// The time that the given information became or will become valid. 
      /// 
      ///   This is not the time that any system first observed the value, but the time that the actual value became correct (i.e. when a patient changes their name)
      ///</summary>
      private string propGetValidTimeLow()
      {
        return wrapped().validTimeLow;
      }
      private void propSetValidTimeLow(string value)
      {
        wrapped().validTimeLow = value;
      }
      ///<summary>
      /// The time that the given information became or will become valid. 
      /// 
      ///   This is not the time that any system first observed the value, but the time that the actual value became correct (i.e. when a patient changes their name)
      ///</summary>
      public string validTimeLow { get { return propGetValidTimeLow(); } set { propSetValidTimeLow(value); } }

      ///<summary>
      /// The time that the given information ceased or will cease to be correct.
      /// 
      ///   Both validTimeLow and validTimeHigh must be valid timestamps using the format described in  7.8.12.3.1 (TS.value).
      ///</summary>
      private string propGetValidTimeHigh()
      {
        return wrapped().validTimeHigh;
      }
      private void propSetValidTimeHigh(string value)
      {
        wrapped().validTimeHigh = value;
      }
      ///<summary>
      /// The time that the given information ceased or will cease to be correct.
      /// 
      ///   Both validTimeLow and validTimeHigh must be valid timestamps using the format described in  7.8.12.3.1 (TS.value).
      ///</summary>
      public string validTimeHigh { get { return propGetValidTimeHigh(); } set { propSetValidTimeHigh(value); } }

      ///<summary>
      /// The root of the identifier of the event associated with setting the datatype to its specified value.
      ///</summary>
      private string propGetControlInformationRoot()
      {
        return wrapped().controlInformationRoot;
      }
      private void propSetControlInformationRoot(string value)
      {
        wrapped().controlInformationRoot = value;
      }
      ///<summary>
      /// The root of the identifier of the event associated with setting the datatype to its specified value.
      ///</summary>
      public string controlInformationRoot { get { return propGetControlInformationRoot(); } set { propSetControlInformationRoot(value); } }

      ///<summary>
      /// The extension of the identifier of the event associated with setting the datatype to its specified value.
      /// 
      ///   Together, the root and extension identify a particular record of a real world event that may supply additional information about the value such as who made the change, when it was made, why it was made, what system originated the change. These attributes exist because sometimes this information is required, but the value is being represented in an external context that does not contain a proper relationship to the control information for the value itself. The record need not be directly or easily resolvable. Conformance statements may make additional statements about these two properties, or about how such a reference should be resolved
      ///</summary>
      private string propGetControlInformationExtension()
      {
        return wrapped().controlInformationExtension;
      }
      private void propSetControlInformationExtension(string value)
      {
        wrapped().controlInformationExtension = value;
      }
      ///<summary>
      /// The extension of the identifier of the event associated with setting the datatype to its specified value.
      /// 
      ///   Together, the root and extension identify a particular record of a real world event that may supply additional information about the value such as who made the change, when it was made, why it was made, what system originated the change. These attributes exist because sometimes this information is required, but the value is being represented in an external context that does not contain a proper relationship to the control information for the value itself. The record need not be directly or easily resolvable. Conformance statements may make additional statements about these two properties, or about how such a reference should be resolved
      ///</summary>
      public string controlInformationExtension { get { return propGetControlInformationExtension(); } set { propSetControlInformationExtension(value); } }

    }

    ///<summary>
    /// Defines the basic properties of every data value. This is conceptually an abstract type, meaning that no proper value can be just a data value without belonging to any concrete type. Every public concrete type is a specialization of this general abstract DataValue type. 
    /// 
    ///   However exceptional values (nullFlavored values) may be of type ANY, except for the exceptional values that imply the nullFlavor INV, since this requires a type to be meaningful. Note that not all nullFlavors may be used with the type ANY (see section 7.1.4 for more details
    ///</summary>
    public class ANY : HL7Connect.Cda.HXIT
    {

      ///<summary>
      /// Create a v3 ANY
      ///</summary>
      public ANY() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newANY()) {} 

      ///<summary>
      /// Create a v3 ANY
      ///</summary>
      public ANY(Tv3NullFlavor nullFlavor) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newANYValue(nullFlavor)) {} 

      internal ANY(Iv3ANY com) : base(com) {} 

      internal new HCv3ANY wrapped() { return (HCv3ANY) com; }

      ///<summary>
      /// A literal string representation of the data, where one is defined in the specification
      ///</summary>
      public string Literal()
      {
        return wrapped().Literal();
      }

      ///<summary>
      /// Convenience property
      ///</summary>
      public bool isNonNull()
      {
        return wrapped().isNonNull() != 0;
      }

      ///<summary>
      /// Convenience property
      ///</summary>
      public bool isNull()
      {
        return wrapped().isNull() != 0;
      }

      ///<summary>
      /// If the value is not a proper value, indicates the reason.
      /// 
      ///   Though the nullFlavor concept has some relationship with the UML/OCL null, it is not the same thing, and the relationship and differences between the two must be understood to properly implement this specification. For further discussion, see section 7.1.4 (Null and NullFlavor). Note that nullFlavor includes the concept of a UML null value, and also includes potentially fully populated instances that do not conform to the requirements placed on the instance (also known as "exceptional instances"). Both nonNull and nullFlavored values SHALL always be valid according to the rules expressed in this specification.  If populated, the value of this attribute SHALL be taken from the HL7 NullFlavor code system.  -- NullFlavor that applies to the property. Note that nfNull means Not Null nfNullnfNI : No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value nfINV : Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variablenfOTH : Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)nfNINF : Negative Infinity : Negative infinity of numbersnfPINF : Positive Infinity : Positive infinity of numbersnfUNC : Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)nfDER : Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)nfUNK : Unknown : A proper value is applicable, but not known nfASKU : Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn't know) nfNAV : Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later nfQS : Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of waternfNASK : Not Asked : This information has not been sought (e.g., patient was not asked) nfTRC : Trace : The content is greater than zero, but too small to be quantifiednfMSK : Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detailnfNA : Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male)
      ///</summary>
      private Tv3NullFlavor propGetNullFlavor()
      {
        return wrapped().nullFlavor;
      }
      private void propSetNullFlavor(Tv3NullFlavor value)
      {
        wrapped().nullFlavor = value;
      }
      ///<summary>
      /// If the value is not a proper value, indicates the reason.
      /// 
      ///   Though the nullFlavor concept has some relationship with the UML/OCL null, it is not the same thing, and the relationship and differences between the two must be understood to properly implement this specification. For further discussion, see section 7.1.4 (Null and NullFlavor). Note that nullFlavor includes the concept of a UML null value, and also includes potentially fully populated instances that do not conform to the requirements placed on the instance (also known as "exceptional instances"). Both nonNull and nullFlavored values SHALL always be valid according to the rules expressed in this specification.  If populated, the value of this attribute SHALL be taken from the HL7 NullFlavor code system.  -- NullFlavor that applies to the property. Note that nfNull means Not Null nfNullnfNI : No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value nfINV : Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variablenfOTH : Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)nfNINF : Negative Infinity : Negative infinity of numbersnfPINF : Positive Infinity : Positive infinity of numbersnfUNC : Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)nfDER : Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)nfUNK : Unknown : A proper value is applicable, but not known nfASKU : Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn't know) nfNAV : Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later nfQS : Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of waternfNASK : Not Asked : This information has not been sought (e.g., patient was not asked) nfTRC : Trace : The content is greater than zero, but too small to be quantifiednfMSK : Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detailnfNA : Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male)
      ///</summary>
      public Tv3NullFlavor nullFlavor { get { return propGetNullFlavor(); } set { propSetNullFlavor(value); } }

      ///<summary>
      /// This property allows a sending system to identify the role that the attribute plays in processing the instance that is being represented.
      /// 
      ///   If populated, the value of this attribute SHALL be taken from the HL7 UpdateMode code system. -- Update mode. Should always be umNull in a CDA document umNullumA : Add : The item was (or is to be) added, having not been present immediately before. (If it is already present, this may be treated as an error condition.)umD : Remove : The item was (or is to be) removed (sometimes referred to as deleted). If the item is part of a collection, delete any matching items.umR : Replace : The item existed previously and has been (or is to be) revised. (If an item does not already exist, this may be treated as an error condition.)umAR : Add or Replace  : The item was (or is to be) either added or replaced. No assertion is made as to whether the item previously existedumN : No Change : There was (or is to be) no change to the item. This is primarily used when this element has not changed, but other attributes in the instance have changed.umU : Unknown : It is not specified whether or what kind of change has occurred to the item, or whether the item is present as a reference or identifying property.umK : Key : This item is part of the identifying information for the object that contains it
      ///</summary>
      private Tv3UpdateMode propGetUpdateMode()
      {
        return wrapped().updateMode;
      }
      private void propSetUpdateMode(Tv3UpdateMode value)
      {
        wrapped().updateMode = value;
      }
      ///<summary>
      /// This property allows a sending system to identify the role that the attribute plays in processing the instance that is being represented.
      /// 
      ///   If populated, the value of this attribute SHALL be taken from the HL7 UpdateMode code system. -- Update mode. Should always be umNull in a CDA document umNullumA : Add : The item was (or is to be) added, having not been present immediately before. (If it is already present, this may be treated as an error condition.)umD : Remove : The item was (or is to be) removed (sometimes referred to as deleted). If the item is part of a collection, delete any matching items.umR : Replace : The item existed previously and has been (or is to be) revised. (If an item does not already exist, this may be treated as an error condition.)umAR : Add or Replace  : The item was (or is to be) either added or replaced. No assertion is made as to whether the item previously existedumN : No Change : There was (or is to be) no change to the item. This is primarily used when this element has not changed, but other attributes in the instance have changed.umU : Unknown : It is not specified whether or what kind of change has occurred to the item, or whether the item is present as a reference or identifying property.umK : Key : This item is part of the identifying information for the object that contains it
      ///</summary>
      public Tv3UpdateMode updateMode { get { return propGetUpdateMode(); } set { propSetUpdateMode(value); } }

      ///<summary>
      /// Signals the imposition of one or more sets of constraints on the datatype. The sole purpose of specifying that a constraint that has been used to further constrain the datatype is to support validation of the instance: a validation engine can look up the rules expressed for the specified flavors and confirm that the instance conforms to the rules for the flavor. No other processing should depend on the content of the flavor attribute*. *
      /// 
      ///   No other semantic or computational use SHALL depend on the value of this property. If this value is populated, the datatype flavor(s) SHALL be a valid constraint on the type of the value.   There is further discussion about the use of Data Type flavors and flavorId in section A.
      ///</summary>
      private string propGetFlavorId()
      {
        return wrapped().flavorId;
      }
      private void propSetFlavorId(string value)
      {
        wrapped().flavorId = value;
      }
      ///<summary>
      /// Signals the imposition of one or more sets of constraints on the datatype. The sole purpose of specifying that a constraint that has been used to further constrain the datatype is to support validation of the instance: a validation engine can look up the rules expressed for the specified flavors and confirm that the instance conforms to the rules for the flavor. No other processing should depend on the content of the flavor attribute*. *
      /// 
      ///   No other semantic or computational use SHALL depend on the value of this property. If this value is populated, the datatype flavor(s) SHALL be a valid constraint on the type of the value.   There is further discussion about the use of Data Type flavors and flavorId in section A.
      ///</summary>
      public string flavorId { get { return propGetFlavorId(); } set { propSetFlavorId(value); } }

    }

    ///<summary>
    /// BL stands for the values of two-valued logic. A BL value can be either true or false, or may have a nullFlavor.
    ///</summary>
    public class BL : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 BL
      ///</summary>
      public BL() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newBL()) {} 

      ///<summary>
      /// Create a v3 BL
      ///</summary>
      public BL(bool aValue) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newBLValue(aValue ? (sbyte) 0 : (sbyte) -1)) {} 

      internal BL(Iv3BL com) : base(com) {} 

      internal new HCv3BL wrapped() { return (HCv3BL) com; }

      ///<summary>
      /// The value of the BL.
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more detail
      ///</summary>
      private bool propGetValue()
      {
        return wrapped().Value != 0;
      }
      private void propSetValue(bool value)
      {
        wrapped().Value = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// The value of the BL.
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more detail
      ///</summary>
      public bool value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// false if value is null, true if value is either true or false
      ///</summary>
      private bool propGetHasValue()
      {
        return wrapped().HasValue != 0;
      }
      ///<summary>
      /// false if value is null, true if value is either true or false
      ///</summary>
      public bool HasValue { get { return propGetHasValue(); } }

    }

    ///<summary>
    /// Data that is primarily intended for human interpretation or for further machine processing outside the scope of this specification. This includes unformatted or formatted written language, multimedia data, or structured information as defined by a different standard (e.g., XML-signatures.) 
    /// 
    ///  Encapsulated data can be present in two forms, inline or by reference. The content is the same whether it is located inline or remote.Inline data is communicated or moved as part of the encapsulated data value, whereas by-reference data may reside at a different  location: a URL/URI that provides reference to the information required to locate the data. Inline data may be provided in one of 3 different ways: {  as a plain sequence of characters (value);  as a binary (a sequence of bytes) (data);  as xml content (xml); } Content SHALL be provided if the ED has no nullFlavor. The content may be provided in-line (using only one of value, data or xml), or it may be provided as a reference.Content may be provided in-line and a reference also may be given; in these cases, it is expected that the content of the reference will be exactly the same as the in-line content. Information Processing Entities are not required to check this, but may regard it as an error condition if the content does not matc
    ///</summary>
    public class ED : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 ED
      ///</summary>
      public ED() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newED()) {} 

      internal ED(Iv3ED com) : base(com) {} 

      internal new HCv3ED wrapped() { return (HCv3ED) com; }

      ///<summary>
      /// Fill out the data from a file. If text or xml is populated, they will be set to null
      ///</summary>
      public void LoadDataFromFile(string sFilename)
      {
        wrapped().LoadDataFromFile(sFilename);
      }

      ///<summary>
      /// Save the data to a file. If the data property is not populated, test or xml will be used
      ///</summary>
      public void SaveDataToFile(string sFilename)
      {
        wrapped().SaveDataToFile(sFilename);
      }

      ///<summary>
      /// Fill out the data from a stream (such as a sql.ColMemory). If text or xml is populated, they will be set to null
      ///</summary>
      public void LoadDataFromStream(Stream oStream)
      {
        wrapped().LoadDataFromStream(new HL7Connect.Utils.StreamWrapper(oStream));
      }

      ///<summary>
      /// Save the data to a stream (use with BindBlob). If the data property is not populated, test or xml will be used
      ///</summary>
      public void SaveDataToStream(Stream oStream)
      {
        wrapped().SaveDataToStream(new HL7Connect.Utils.StreamWrapper(oStream));
      }

      ///<summary>
      /// Shortcut method. Add an ED to the list of translations.
      ///</summary>
      public HL7Connect.Cda.ED AddTranslation()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().AddTranslation());
      }

      ///<summary>
      /// A simple sequence of characters that contains the content. 
      /// 
      ///   If value is used, the mediatype is fixed to text/plain and the charset must be consistent with the String Character Set. Refer to section 6.7.5 for more detail
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(string value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// A simple sequence of characters that contains the content. 
      /// 
      ///   If value is used, the mediatype is fixed to text/plain and the charset must be consistent with the String Character Set. Refer to section 6.7.5 for more detail
      ///</summary>
      public string value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// Access the raw bytes of data as a string. This may not work on all platforms
      ///</summary>
      private string propGetDataAsString()
      {
        return wrapped().dataAsString;
      }
      private void propSetDataAsString(string value)
      {
        wrapped().dataAsString = value;
      }
      ///<summary>
      /// Access the raw bytes of data as a string. This may not work on all platforms
      ///</summary>
      public string dataAsString { get { return propGetDataAsString(); } set { propSetDataAsString(value); } }

      ///<summary>
      /// A URL the target of which provides the binary content.
      /// 
      ///   The semantic value of an encapsulated data value is the same, regardless whether the content is present as inline content or just by reference. However, an encapsulated data value without inline content behaves differently, since any attempt to examine the content requires the data to be downloaded from the reference. An encapsulated data value may have both inline content and a reference.  If data is provded in the value, data or xml attributes, the reference SHALL point to the same data. It is an error if the data resolved through the reference does not match either the integrity check, data as provided, or data that had earlier been retrieved through the reference and then cached. The mediatype of the ED SHALL match the type returned by accessing the reference.   The reference may contain a usablePeriod to indicate that the data may only be available for a limited period of time. Whether the reference is limited by a usablePeriod or not, the content of the reference SHALL be fixed for all time. Any application using the reference SHALL always receive the same data, or an error. The reference cannot be reused to send a different version of the same data, or different dat
      ///</summary>
      private HL7Connect.Cda.TEL propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.TEL(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.TEL value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// A URL the target of which provides the binary content.
      /// 
      ///   The semantic value of an encapsulated data value is the same, regardless whether the content is present as inline content or just by reference. However, an encapsulated data value without inline content behaves differently, since any attempt to examine the content requires the data to be downloaded from the reference. An encapsulated data value may have both inline content and a reference.  If data is provded in the value, data or xml attributes, the reference SHALL point to the same data. It is an error if the data resolved through the reference does not match either the integrity check, data as provided, or data that had earlier been retrieved through the reference and then cached. The mediatype of the ED SHALL match the type returned by accessing the reference.   The reference may contain a usablePeriod to indicate that the data may only be available for a limited period of time. Whether the reference is limited by a usablePeriod or not, the content of the reference SHALL be fixed for all time. Any application using the reference SHALL always receive the same data, or an error. The reference cannot be reused to send a different version of the same data, or different dat
      ///</summary>
      public HL7Connect.Cda.TEL reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// Identifies the type of the encapsulated data and can be used to determine a method to interpret or render the content. 
      /// 
      ///   The IANA defined domain of media types is established by the IETF RFCs 2045 and 2046. mediaType has a default value of text/plain and cannot be null. If the media type is different to text/plain, the mediaType attribute SHALL be populated.  If the content is compressed using a specified compression algorithm, the mediaType SHALL refer the mediaType of the uncompressed data, whether the data is accessed by reference or not.
      ///</summary>
      private string propGetMediaType()
      {
        return wrapped().mediaType;
      }
      private void propSetMediaType(string value)
      {
        wrapped().mediaType = value;
      }
      ///<summary>
      /// Identifies the type of the encapsulated data and can be used to determine a method to interpret or render the content. 
      /// 
      ///   The IANA defined domain of media types is established by the IETF RFCs 2045 and 2046. mediaType has a default value of text/plain and cannot be null. If the media type is different to text/plain, the mediaType attribute SHALL be populated.  If the content is compressed using a specified compression algorithm, the mediaType SHALL refer the mediaType of the uncompressed data, whether the data is accessed by reference or not.
      ///</summary>
      public string mediaType { get { return propGetMediaType(); } set { propSetMediaType(value); } }

      ///<summary>
      /// An Internet Assigned Numbers Authority (IANA) Charset Registered character set and character encoding for character-based encoding types*. *
      /// 
      ///   Whenever the content of the ED is character type data in any form, the charset property needs to be known. If the content is provided directly in the value attribute, then the charset SHALL be a known character set consistent with the String Character Set. Refer to section 6.7.5 for more details. If the content is provided as a reference, and the access method does not provide the charset for the content (such as by a mime header), then the charset SHALL be conveyed as part of the E
      ///</summary>
      private string propGetCharset()
      {
        return wrapped().charset;
      }
      private void propSetCharset(string value)
      {
        wrapped().charset = value;
      }
      ///<summary>
      /// An Internet Assigned Numbers Authority (IANA) Charset Registered character set and character encoding for character-based encoding types*. *
      /// 
      ///   Whenever the content of the ED is character type data in any form, the charset property needs to be known. If the content is provided directly in the value attribute, then the charset SHALL be a known character set consistent with the String Character Set. Refer to section 6.7.5 for more details. If the content is provided as a reference, and the access method does not provide the charset for the content (such as by a mime header), then the charset SHALL be conveyed as part of the E
      ///</summary>
      public string charset { get { return propGetCharset(); } set { propSetCharset(value); } }

      ///<summary>
      /// The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
      /// 
      ///   Conformance profiles SHOULD define defaulting rules for language for a given usage environment of this specification.  Note: While language attribute usually alters the interpretation of the text, the language attribute does not alter the meaning of the characters in the text
      ///</summary>
      private string propGetLanguage()
      {
        return wrapped().language;
      }
      private void propSetLanguage(string value)
      {
        wrapped().language = value;
      }
      ///<summary>
      /// The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
      /// 
      ///   Conformance profiles SHOULD define defaulting rules for language for a given usage environment of this specification.  Note: While language attribute usually alters the interpretation of the text, the language attribute does not alter the meaning of the characters in the text
      ///</summary>
      public string language { get { return propGetLanguage(); } set { propSetLanguage(value); } }

      ///<summary>
      /// The compression algorithm, if any, used on the raw byte data.
      /// 
      ///   If the attribute is null, the data is not compressed. Compression only applies to the binary form of the content.  If populated, the value of this attribute SHALL be taken from the HL7 CompressionAlgorithm code system.  Some compression formats allow multiple archive files to be embedded within a single compressed volume. Applications SHALL ensure that the decompressed form of the data conforms to the stated media type -- Possible compression types for content cNullcDF : Deflate : The deflate compressed data format as specified in IETF RFC 1951cGZ : GZIP : A compressed data format that is compatible with the widely used GZIP utility as specified in IETF RFC 1952(uses the deflate algorithm)cZL : ZLIB : A compressed data format that also uses the deflate algorithm. Specified as IETF RFC 1950cZ : Compress : Original UNIX compress algorithm and file format using the LZC algorithm (a variant of LZW). Patent encumbered and less efficient than deflate cBZ : BZIP : bzip-2 compression format. See [http://www.bzip.org/] for more information.cZ7 : Z7 : 7z compression file format. See [http://www.7-zip.org/7z.html] for more information.
      ///</summary>
      private Tv3Compression propGetCompression()
      {
        return wrapped().compression;
      }
      private void propSetCompression(Tv3Compression value)
      {
        wrapped().compression = value;
      }
      ///<summary>
      /// The compression algorithm, if any, used on the raw byte data.
      /// 
      ///   If the attribute is null, the data is not compressed. Compression only applies to the binary form of the content.  If populated, the value of this attribute SHALL be taken from the HL7 CompressionAlgorithm code system.  Some compression formats allow multiple archive files to be embedded within a single compressed volume. Applications SHALL ensure that the decompressed form of the data conforms to the stated media type -- Possible compression types for content cNullcDF : Deflate : The deflate compressed data format as specified in IETF RFC 1951cGZ : GZIP : A compressed data format that is compatible with the widely used GZIP utility as specified in IETF RFC 1952(uses the deflate algorithm)cZL : ZLIB : A compressed data format that also uses the deflate algorithm. Specified as IETF RFC 1950cZ : Compress : Original UNIX compress algorithm and file format using the LZC algorithm (a variant of LZW). Patent encumbered and less efficient than deflate cBZ : BZIP : bzip-2 compression format. See [http://www.bzip.org/] for more information.cZ7 : Z7 : 7z compression file format. See [http://www.7-zip.org/7z.html] for more information.
      ///</summary>
      public Tv3Compression compression { get { return propGetCompression(); } set { propSetCompression(value); } }

      ///<summary>
      /// A checksum calculated over the binary data
      /// 
      ///   The purpose of this property, when communicated with a reference is for anyone to validate later whether the reference still resolved to the same content that the reference resolved to when the encapsulated data value with reference was created. If the attribute is null, there is no integrityCheck. It is an error if the data resolved through the reference does not match the integrity check.  The integrity check is calculated according to the integrityCheckAlgorithm. By default, the Secure Hash Algorithm-1 (SHA-1) shall be used. The integrity check is binary encoded according to the rules of the integrity check algorithm.  The integrity check is calculated over the raw binary data that is contained in the data component, or that is accessible through the reference. No transformations are made before the integrity check is calculated. If the data is compressed, the Integrity Check is calculated over the compressed data.
      ///</summary>
      private byte[] propGetIntegrityCheck()
      {
        return HL7Connect.Utils.IStreamWrapper.IStreamToBytes(wrapped().integrityCheck);
      }
      private void propSetIntegrityCheck(byte[] value)
      {
        wrapped().integrityCheck = new HL7Connect.Utils.StreamWrapper(new MemoryStream(value));
      }
      ///<summary>
      /// A checksum calculated over the binary data
      /// 
      ///   The purpose of this property, when communicated with a reference is for anyone to validate later whether the reference still resolved to the same content that the reference resolved to when the encapsulated data value with reference was created. If the attribute is null, there is no integrityCheck. It is an error if the data resolved through the reference does not match the integrity check.  The integrity check is calculated according to the integrityCheckAlgorithm. By default, the Secure Hash Algorithm-1 (SHA-1) shall be used. The integrity check is binary encoded according to the rules of the integrity check algorithm.  The integrity check is calculated over the raw binary data that is contained in the data component, or that is accessible through the reference. No transformations are made before the integrity check is calculated. If the data is compressed, the Integrity Check is calculated over the compressed data.
      ///</summary>
      public byte[] integrityCheck { get { return propGetIntegrityCheck(); } set { propSetIntegrityCheck(value); } }

      ///<summary>
      /// The algorithm used to compute the integrityCheck value.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 IntegrityCheckAlgorithm code system. -- Possible integrity check alorithms for referenced data icaNullicaSHA1 : Secure Hash Algorithm - 1 : This algorithm is defined in FIPS PUB 180-1: Secure Hash Standard. As of April 17, 1995 icaSHA256 : Secure Hash Algorithm - 256 : This algorithm is defined in FIPS PUB 180-2: Secure Hash Standard
      ///</summary>
      private Tv3IntegrityCheckAlgorithm propGetIntegrityCheckAlgorithm()
      {
        return wrapped().integrityCheckAlgorithm;
      }
      private void propSetIntegrityCheckAlgorithm(Tv3IntegrityCheckAlgorithm value)
      {
        wrapped().integrityCheckAlgorithm = value;
      }
      ///<summary>
      /// The algorithm used to compute the integrityCheck value.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 IntegrityCheckAlgorithm code system. -- Possible integrity check alorithms for referenced data icaNullicaSHA1 : Secure Hash Algorithm - 1 : This algorithm is defined in FIPS PUB 180-1: Secure Hash Standard. As of April 17, 1995 icaSHA256 : Secure Hash Algorithm - 256 : This algorithm is defined in FIPS PUB 180-2: Secure Hash Standard
      ///</summary>
      public Tv3IntegrityCheckAlgorithm integrityCheckAlgorithm { get { return propGetIntegrityCheckAlgorithm(); } set { propSetIntegrityCheckAlgorithm(value); } }

      ///<summary>
      /// An alternative description of the media where the media is not able to be rendered. 
      /// 
      ///   E.g. Short text description of an image or sound clip, etc. This attribute is not intended to be a complete substitute for the original. For complete substitutes, use the "translation" property.  The intent of this property is to allow compliance with disability requirements such as those expressed in American's with Disability Act (also known as "Section 508"), where there is a requirement to provide a short text description of included media in some form that can be read by a screen reader. This is similar to a very short thumbnail with mediaType = text/plain
      ///</summary>
      private HL7Connect.Cda.ST propGetDescription()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().Description);
      }
      private void propSetDescription(HL7Connect.Cda.ST value)
      {
        wrapped().Description = value.wrapped();
      }
      ///<summary>
      /// An alternative description of the media where the media is not able to be rendered. 
      /// 
      ///   E.g. Short text description of an image or sound clip, etc. This attribute is not intended to be a complete substitute for the original. For complete substitutes, use the "translation" property.  The intent of this property is to allow compliance with disability requirements such as those expressed in American's with Disability Act (also known as "Section 508"), where there is a requirement to provide a short text description of included media in some form that can be read by a screen reader. This is similar to a very short thumbnail with mediaType = text/plain
      ///</summary>
      public HL7Connect.Cda.ST description { get { return propGetDescription(); } set { propSetDescription(value); } }

      ///<summary>
      /// An abbreviated rendition of the full content. 
      /// 
      ///   A thumbnail requires significantly fewer resources than the full content, while still maintaining some distinctive similarity with the full content. A thumbnail is typically used with by-reference encapsulated data. It allows a user to select the appropriate content more efficiently before actually downloading through the reference.  Originally, the term thumbnail refers to an image in a lower resolution (or smaller size) than another image. However, the thumbnail concept can be metaphorically used for media types other than images. For example, a movie may be represented by a shorter clip; an audio-clip may be represented by another audio-clip that is shorter, has a lower sampling rate, or a lossy compression; or an abstract provided for a long document.  A thumbnail itself SHALL NOT contain a thumbnail
      ///</summary>
      private HL7Connect.Cda.ED propGetThumbnail()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().thumbnail);
      }
      private void propSetThumbnail(HL7Connect.Cda.ED value)
      {
        wrapped().thumbnail = value.wrapped();
      }
      ///<summary>
      /// An abbreviated rendition of the full content. 
      /// 
      ///   A thumbnail requires significantly fewer resources than the full content, while still maintaining some distinctive similarity with the full content. A thumbnail is typically used with by-reference encapsulated data. It allows a user to select the appropriate content more efficiently before actually downloading through the reference.  Originally, the term thumbnail refers to an image in a lower resolution (or smaller size) than another image. However, the thumbnail concept can be metaphorically used for media types other than images. For example, a movie may be represented by a shorter clip; an audio-clip may be represented by another audio-clip that is shorter, has a lower sampling rate, or a lossy compression; or an abstract provided for a long document.  A thumbnail itself SHALL NOT contain a thumbnail
      ///</summary>
      public HL7Connect.Cda.ED thumbnail { get { return propGetThumbnail(); } set { propSetThumbnail(value); } }

      ///<summary>
      /// Alternate renditions of the same content translated into a different language or a different mediaType. 
      /// 
      ///  The translations SHALL convey the same information, but in a different language or mediaType. Translations SHALL not contain translations. The translations do not take part in the test for equality, so SHALL NOT introduce any new semantics to the value.
      ///</summary>
      private HL7Connect.Cda.SetED propGetTranslation()
      {
        return HL7Connect.Cda.WrapperFactory.SetED(wrapped().translation);
      }
      private void propSetTranslation(HL7Connect.Cda.SetED value)
      {
        wrapped().translation = value.wrapped();
      }
      ///<summary>
      /// Alternate renditions of the same content translated into a different language or a different mediaType. 
      /// 
      ///  The translations SHALL convey the same information, but in a different language or mediaType. Translations SHALL not contain translations. The translations do not take part in the test for equality, so SHALL NOT introduce any new semantics to the value.
      ///</summary>
      public HL7Connect.Cda.SetED translation { get { return propGetTranslation(); } set { propSetTranslation(value); } }

    }

    ///<summary>
    /// The character string datatype stands for text data, primarily intended for machine processing (e.g., sorting, querying, indexing, etc.) or direct display. Used for names, symbols, presentation and formal expressions.
    /// 
    ///   A ST SHALL have at least one character or else have a nullFlavo
    ///</summary>
    public class ST : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 ST
      ///</summary>
      public ST() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newST()) {} 

      ///<summary>
      /// Create a v3 ST
      ///</summary>
      public ST(string sValue) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSTValue(sValue)) {} 

      internal ST(Iv3ST com) : base(com) {} 

      internal new HCv3ST wrapped() { return (HCv3ST) com; }

      ///<summary>
      /// Shortcut method. Add an ST to the list of translations.
      ///</summary>
      public HL7Connect.Cda.ST AddTranslation()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().AddTranslation());
      }

      ///<summary>
      /// The actual content of the string. Refer to section 6.7.5 for discussion on String character encodings.
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more details
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(string value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// The actual content of the string. Refer to section 6.7.5 for discussion on String character encodings.
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more details
      ///</summary>
      public string value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
      /// 
      ///  Note: While Language tags usually alter the meaning of the text, the language does not alter the meaning of the characters in the text. Note: add a note that language is often defaulted to context
      ///</summary>
      private string propGetLanguage()
      {
        return wrapped().language;
      }
      private void propSetLanguage(string value)
      {
        wrapped().language = value;
      }
      ///<summary>
      /// The human language of the content. Valid codes are taken from the IETF RFC 3066. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
      /// 
      ///  Note: While Language tags usually alter the meaning of the text, the language does not alter the meaning of the characters in the text. Note: add a note that language is often defaulted to context
      ///</summary>
      public string language { get { return propGetLanguage(); } set { propSetLanguage(value); } }

      ///<summary>
      /// Alternate renditions of the same content translated into a different language. Translations may not contain translations.
      /// 
      ///   While Language tags usually alter the meaning of the text, the language does not alter the meaning of the characters in the text.  Note: add a note that language is often defaulted to context
      ///</summary>
      private HL7Connect.Cda.SetST propGetTranslation()
      {
        return HL7Connect.Cda.WrapperFactory.SetST(wrapped().translation);
      }
      private void propSetTranslation(HL7Connect.Cda.SetST value)
      {
        wrapped().translation = value.wrapped();
      }
      ///<summary>
      /// Alternate renditions of the same content translated into a different language. Translations may not contain translations.
      /// 
      ///   While Language tags usually alter the meaning of the text, the language does not alter the meaning of the characters in the text.  Note: add a note that language is often defaulted to context
      ///</summary>
      public HL7Connect.Cda.SetST translation { get { return propGetTranslation(); } set { propSetTranslation(value); } }

    }

    ///<summary>
    /// A character string that optionally may have a code attached. The text must always be present if a code is present. 
    /// 
    ///   The code is often a local code. SC is used in cases where coding is exceptional (e.g., user error messages are essentially text messages, and the text message is the important content. However sometimes messages come from a catalog of prepared messages, which SC allows to reference).  Any non-null SC value MAY have a code, however, a code SHALL NOT be given without the text.   The similarities and differences between SC and CD are discussed in Section  7.5.1.2, CD and S
    ///</summary>
    public class SC : HL7Connect.Cda.ST
    {

      ///<summary>
      /// Create a v3 SC
      ///</summary>
      public SC() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSC()) {} 

      internal SC(Iv3SC com) : base(com) {} 

      internal new HCv3SC wrapped() { return (HCv3SC) com; }

      ///<summary>
      /// The coded value associated with the string. If the value is or nullFlavored, there is no coded value associated with this string.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// The coded value associated with the string. If the value is or nullFlavored, there is no coded value associated with this string.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class CR : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 CR
      ///</summary>
      public CR() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCR()) {} 

      internal CR(Iv3CR com) : base(com) {} 

      internal new HCv3CR wrapped() { return (HCv3CR) com; }

      ///<summary>
      /// Specifies the manner in which the concept role value contributes to the meaning of a code phrase. For example, if SNOMED RT defines a concept "leg", a role relation "has-laterality", and another concept "left", the concept role relation allows to add
      ///</summary>
      private HL7Connect.Cda.CD propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.CD value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// Specifies the manner in which the concept role value contributes to the meaning of a code phrase. For example, if SNOMED RT defines a concept "leg", a role relation "has-laterality", and another concept "left", the concept role relation allows to add
      ///</summary>
      public HL7Connect.Cda.CD name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// The concept that modifies the primary code of a code phrase through the role relation. For example, if SNOMED RT defines a concept "leg", a role relation "has-laterality", and another concept "left", the concept role relation allows adding the qualif
      ///</summary>
      private HL7Connect.Cda.CD propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.CD value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// The concept that modifies the primary code of a code phrase through the role relation. For example, if SNOMED RT defines a concept "leg", a role relation "has-laterality", and another concept "left", the concept role relation allows adding the qualif
      ///</summary>
      public HL7Connect.Cda.CD value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// Indicates if the sense of name is inverted. This can be used in cases where the underlying code system defines inversion but does not provide reciprocal pairs of role names. By default, inverted is false.
      ///</summary>
      private bool propGetInverted()
      {
        return wrapped().inverted != 0;
      }
      private void propSetInverted(bool value)
      {
        wrapped().inverted = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Indicates if the sense of name is inverted. This can be used in cases where the underlying code system defines inversion but does not provide reciprocal pairs of role names. By default, inverted is false.
      ///</summary>
      public bool inverted { get { return propGetInverted(); } set { propSetInverted(value); } }

      ///<summary>
      /// false if inverted is null, true if inverted is either true or false
      ///</summary>
      private bool propGetHasInverted()
      {
        return wrapped().HasInverted != 0;
      }
      private void propSetHasInverted(bool value)
      {
        wrapped().HasInverted = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// false if inverted is null, true if inverted is either true or false
      ///</summary>
      public bool HasInverted { get { return propGetHasInverted(); } set { propSetHasInverted(value); } }

    }

    ///<summary>
    /// A CD is a reference to a concept defined in an external code system, terminology, or ontology. A CD may contain a simple code - that is, a reference to a concept defined directly by the referenced code system, or it may contain an expression in some syntax defined by the referenced code system that can be meaningfully evaluated. e.g., the concept of a "left foot" as a postcoordinated term built from the primary code "FOOT" and the qualifier "LEFT". 
    /// 
    ///   A CD may also contain an original text or phrase that served as the basis of the coding. This is preserved to allow for validation of the representation of the concept in various fashions.   A CD can contain one or more translations into multiple coding systems. The translations are all representations of the same concept in various code systems. There is only one concept, and only the first CD may contain an original text. It is possible to represent the translation chain - which CD was translated from which - if desired. Each CD may also carry a rationale to indicate why it is represented.  A CD with no nullFlavor attribute SHALL have a code attribute or nonNull originalText attribute. A CD that has a code, codeSystem or originalText attribute but does not meet external constraints of the applicable value set SHALL have a nullFlavor attribute with a value of "OTH".  Attributes with type CD are generally bound by externally specified constraints which constrain the coded concepts to which a CD may refer. These constraints may be qualified as "extensible" (CWE) or "not extensible" (CNE). If the constraint is not extensible (CNE), then a the CD that does not have a nullFlavor SHALL contain a code that conforms to the constraint. If the constraint is extensible (CWE) then a CD that does not have a nullFlavor SHALL contain either a code that exists in the domain with which the attribute is associated, a code from a locally defined code system, or just some originalText that describes the concept. If the code is taken from a locally defined code system, then the codeSystem property SHALL specify the local code system. For both CNE and CWE constraint types, the translations may contain nonNull codes from any source unless otherwise specified by the constraining model.   For code systems that define expression syntaxes, CNE constraints may be used, providing that the code system definitions define the appropriate support to enable value sets to make useful statements about how to control the expression syntax, and that the value set machinery used also has the appropriate suppor
    ///</summary>
    public class CD : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 CD
      ///</summary>
      public CD() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCD()) {} 

      ///<summary>
      /// Create a v3 CD
      ///</summary>
      public CD(string sCode, string sCodeSystem) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCDValue(sCode, sCodeSystem)) {} 

      internal CD(Iv3CD com) : base(com) {} 

      internal new HCv3CD wrapped() { return (HCv3CD) com; }

      ///<summary>
      /// Shortcut method. Add an ED to the list of translations.
      ///</summary>
      public HL7Connect.Cda.CD AddTranslation(string code, string codeSystem)
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().AddTranslation(code, codeSystem));
      }

      ///<summary>
      /// The plain code symbol defined by the code system, or an expression in a syntax defined by the code system which describes the concept. 
      /// 
      ///  If a code is provided, it SHALL be an exact match to a plain code symbol or expression defined by the code system. If the code system defines a code or expression that includes whitespace, the code SHALL include the whitespace. An expression can only be used where the codeSystem either defines an expression syntax, or there is a generally accepted syntax for the codeSystem. A code system may be defined that only defines an expression syntax with bindings to other code Systems for the elements of the expression.   It is at the discretion of the interpreting system whether to check for an expression instead of a simple code and evaluate the expression instead of treating the expression as a code. In some cases, it may be unclear or ambiguous whether the code represents a single symbol or an expression. This usually arises where the code system defines an expression language and then defines pre-coordinated concepts with symbols which match their expression, e.g. UCUM. In other cases, it is safe to treat the expression as a symbol. There is no guarantee that this is always safe: the definitions of the codeSystem should always be consulted to determine how to handle potential expressions.
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      private void propSetCode(string value)
      {
        wrapped().Code = value;
      }
      ///<summary>
      /// The plain code symbol defined by the code system, or an expression in a syntax defined by the code system which describes the concept. 
      /// 
      ///  If a code is provided, it SHALL be an exact match to a plain code symbol or expression defined by the code system. If the code system defines a code or expression that includes whitespace, the code SHALL include the whitespace. An expression can only be used where the codeSystem either defines an expression syntax, or there is a generally accepted syntax for the codeSystem. A code system may be defined that only defines an expression syntax with bindings to other code Systems for the elements of the expression.   It is at the discretion of the interpreting system whether to check for an expression instead of a simple code and evaluate the expression instead of treating the expression as a code. In some cases, it may be unclear or ambiguous whether the code represents a single symbol or an expression. This usually arises where the code system defines an expression language and then defines pre-coordinated concepts with symbols which match their expression, e.g. UCUM. In other cases, it is safe to treat the expression as a symbol. There is no guarantee that this is always safe: the definitions of the codeSystem should always be consulted to determine how to handle potential expressions.
      ///</summary>
      public string code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// The code system that defines the code, or if no code was found, the codeSystem in which no code was found. 
      /// 
      ///  Code systems SHALL be referred to by a UID, which allows unambiguous reference to standard code systems and other local codesystems. Where either ISO or HL7 have assigned UID to code Systems, then these UIDs SHALL be used. Otherwise implementations SHALL use an appropriate ISO Object Identifier (OID) or UUID to construct a globally unique local coding system identifier. A CD that has a code attribute SHALL have a codeSystem specifying the system of concepts that defines the code. An CD with a nullFlavor OTH indicates that a concept could not be coded in the coding system or value set specified. Thus, for these coding exceptions, the code system or value set that did not contain the appropriate concept SHALL be provided in codeSystem or valueSet
      ///</summary>
      private string propGetCodeSystem()
      {
        return wrapped().codeSystem;
      }
      private void propSetCodeSystem(string value)
      {
        wrapped().codeSystem = value;
      }
      ///<summary>
      /// The code system that defines the code, or if no code was found, the codeSystem in which no code was found. 
      /// 
      ///  Code systems SHALL be referred to by a UID, which allows unambiguous reference to standard code systems and other local codesystems. Where either ISO or HL7 have assigned UID to code Systems, then these UIDs SHALL be used. Otherwise implementations SHALL use an appropriate ISO Object Identifier (OID) or UUID to construct a globally unique local coding system identifier. A CD that has a code attribute SHALL have a codeSystem specifying the system of concepts that defines the code. An CD with a nullFlavor OTH indicates that a concept could not be coded in the coding system or value set specified. Thus, for these coding exceptions, the code system or value set that did not contain the appropriate concept SHALL be provided in codeSystem or valueSet
      ///</summary>
      public string codeSystem { get { return propGetCodeSystem(); } set { propSetCodeSystem(value); } }

      ///<summary>
      /// The common name of the coding system. 
      /// 
      ///   The code system name has no computational value. codeSystemName can never modify the meaning of codeSystem and cannot exist without codeSystem.  Information Processing Entities claiming direct or indirect conformance SHALL NOT functionally rely on codeSystemName. In addition, they MAY choose not to implement codeSystemName but SHALL NOT reject instances because codeSystemName is present.  Note:  The purpose of a code system name is to assist an unaided human interpreter of a code value to interpret codeSystem
      ///</summary>
      private string propGetCodeSystemName()
      {
        return wrapped().codeSystemName;
      }
      private void propSetCodeSystemName(string value)
      {
        wrapped().codeSystemName = value;
      }
      ///<summary>
      /// The common name of the coding system. 
      /// 
      ///   The code system name has no computational value. codeSystemName can never modify the meaning of codeSystem and cannot exist without codeSystem.  Information Processing Entities claiming direct or indirect conformance SHALL NOT functionally rely on codeSystemName. In addition, they MAY choose not to implement codeSystemName but SHALL NOT reject instances because codeSystemName is present.  Note:  The purpose of a code system name is to assist an unaided human interpreter of a code value to interpret codeSystem
      ///</summary>
      public string codeSystemName { get { return propGetCodeSystemName(); } set { propSetCodeSystemName(value); } }

      ///<summary>
      /// If applicable, a version descriptor defined specifically for the given code system.
      /// 
      ///   Different versions of one code system must be compatible. By definition a code symbol SHALL have the same meaning throughout all versions of a code system. Between versions, codes may be retired but not withdrawn or reused. Where the definition of the meaning of a code symbol changes, it must still be compatible (equal) between different code system versions.  Whenever a code system changes in an incompatible way, it will constitute a new code system, not simply a different version, regardless of how the vocabulary publisher calls it. For example, the publisher of ICD-9 and ICD-10 calls these code systems, "revision 9" and "revision 10" respectively. However, ICD-10 is a complete redesign of the ICD code, not a backward compatible version. Therefore, for the purpose of this datatype specification, ICD-9 and ICD-10 are different code systems, not just different versions. By contrast, when LOINC updates from revision "1.0j" to "1.0k", this would be considered as just another version of LOINC, since LOINC revisions are backwards compatible
      ///</summary>
      private string propGetCodeSystemVersion()
      {
        return wrapped().codeSystemVersion;
      }
      private void propSetCodeSystemVersion(string value)
      {
        wrapped().codeSystemVersion = value;
      }
      ///<summary>
      /// If applicable, a version descriptor defined specifically for the given code system.
      /// 
      ///   Different versions of one code system must be compatible. By definition a code symbol SHALL have the same meaning throughout all versions of a code system. Between versions, codes may be retired but not withdrawn or reused. Where the definition of the meaning of a code symbol changes, it must still be compatible (equal) between different code system versions.  Whenever a code system changes in an incompatible way, it will constitute a new code system, not simply a different version, regardless of how the vocabulary publisher calls it. For example, the publisher of ICD-9 and ICD-10 calls these code systems, "revision 9" and "revision 10" respectively. However, ICD-10 is a complete redesign of the ICD code, not a backward compatible version. Therefore, for the purpose of this datatype specification, ICD-9 and ICD-10 are different code systems, not just different versions. By contrast, when LOINC updates from revision "1.0j" to "1.0k", this would be considered as just another version of LOINC, since LOINC revisions are backwards compatible
      ///</summary>
      public string codeSystemVersion { get { return propGetCodeSystemVersion(); } set { propSetCodeSystemVersion(value); } }

      ///<summary>
      /// The value set that applied when this CD was created.
      /// 
      ///   Value sets shall be referred to by an identifier name which allows unambiguous reference to a value set. Where either ISO or HL7 have assigned an identifying name to a value set, then that name shall be used.   In many cases, a CD is created from a value set - either a code/code system pair is chosen from a valueSet, or one is not chosen and the CD has the exceptional value of NullFlavor.OTH. If no code is chosen, it is generally inappropriate to reference the code system from which the code was chosen as the value set may not match the code system (may include a subset of the codeSystem, or additional terms from other code systems); instead, the value set should be provided. In addition, there are some known use cases where the value set that a user or system was offered when choosing a code affects the interpretation of the code.   If a code is provided, the meaning of the code must come from the definition of the code in the code system. The meaning of the code SHALL NOT depend on the value set. Information Processing Entities claiming direct or indirect conformance SHALL NOT be required to interpret the code in light of the valueSet, and they SHALL NOT reject an instance because of the presence or absence of any or a particular value set.
      ///</summary>
      private string propGetValueSet()
      {
        return wrapped().valueSet;
      }
      private void propSetValueSet(string value)
      {
        wrapped().valueSet = value;
      }
      ///<summary>
      /// The value set that applied when this CD was created.
      /// 
      ///   Value sets shall be referred to by an identifier name which allows unambiguous reference to a value set. Where either ISO or HL7 have assigned an identifying name to a value set, then that name shall be used.   In many cases, a CD is created from a value set - either a code/code system pair is chosen from a valueSet, or one is not chosen and the CD has the exceptional value of NullFlavor.OTH. If no code is chosen, it is generally inappropriate to reference the code system from which the code was chosen as the value set may not match the code system (may include a subset of the codeSystem, or additional terms from other code systems); instead, the value set should be provided. In addition, there are some known use cases where the value set that a user or system was offered when choosing a code affects the interpretation of the code.   If a code is provided, the meaning of the code must come from the definition of the code in the code system. The meaning of the code SHALL NOT depend on the value set. Information Processing Entities claiming direct or indirect conformance SHALL NOT be required to interpret the code in light of the valueSet, and they SHALL NOT reject an instance because of the presence or absence of any or a particular value set.
      ///</summary>
      public string valueSet { get { return propGetValueSet(); } set { propSetValueSet(value); } }

      ///<summary>
      /// The version of the valueSet in which no code was found.
      /// 
      ///   valueSetVersion SHALL be provided when a valueSet is provided, and otherwise SHALL be null. The value of the valueSetVersion must properly identify a particular version of the value set following the rules defined by the value set or its publisher.   It is generally recommended that value set publishers specify that the version is identified by the date/time that the value set version is published, and that the publication process makes the date/time explicitly clearclear.
      ///</summary>
      private string propGetValueSetVersion()
      {
        return wrapped().valueSetVersion;
      }
      private void propSetValueSetVersion(string value)
      {
        wrapped().valueSetVersion = value;
      }
      ///<summary>
      /// The version of the valueSet in which no code was found.
      /// 
      ///   valueSetVersion SHALL be provided when a valueSet is provided, and otherwise SHALL be null. The value of the valueSetVersion must properly identify a particular version of the value set following the rules defined by the value set or its publisher.   It is generally recommended that value set publishers specify that the version is identified by the date/time that the value set version is published, and that the publication process makes the date/time explicitly clearclear.
      ///</summary>
      public string valueSetVersion { get { return propGetValueSetVersion(); } set { propSetValueSetVersion(value); } }

      ///<summary>
      /// A name, title, or representation for the code or expression as it exists in the code system.
      /// 
      ///   If populated, the displayName SHALL be a valid human readable representation of the concept as defined by the code system at the time of data entry. The displayName SHALL conform to any rules defined by the codingSystem; if the codeSystem does not define a human representation for the code or expression, then none can be provided. displayName is included both as a courtesy to an unaided human interpreter of a code value and as a documentation of the name used to display the concept to the user. The display name has no functional meaning; it SHALL never exist without a code; and it SHALL never modify the meaning of the code. A display name may not be present if the code is an expression for which no display name has been assigned or can be derived. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayName but SHALL NOT reject instances because displayName is present.  Display names SHALL not alter the meaning of the code value. Therefore, display names SHOULD NOT be presented to the user on a receiving application system without ascertaining that the display name adequately represents the concept referred to by the code value. Communication SHALL NOT simply rely on the display name. The display name's main purpose is to support implementation debugging
      ///</summary>
      private HL7Connect.Cda.ST propGetDisplayName()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().displayName);
      }
      private void propSetDisplayName(HL7Connect.Cda.ST value)
      {
        wrapped().displayName = value.wrapped();
      }
      ///<summary>
      /// A name, title, or representation for the code or expression as it exists in the code system.
      /// 
      ///   If populated, the displayName SHALL be a valid human readable representation of the concept as defined by the code system at the time of data entry. The displayName SHALL conform to any rules defined by the codingSystem; if the codeSystem does not define a human representation for the code or expression, then none can be provided. displayName is included both as a courtesy to an unaided human interpreter of a code value and as a documentation of the name used to display the concept to the user. The display name has no functional meaning; it SHALL never exist without a code; and it SHALL never modify the meaning of the code. A display name may not be present if the code is an expression for which no display name has been assigned or can be derived. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayName but SHALL NOT reject instances because displayName is present.  Display names SHALL not alter the meaning of the code value. Therefore, display names SHOULD NOT be presented to the user on a receiving application system without ascertaining that the display name adequately represents the concept referred to by the code value. Communication SHALL NOT simply rely on the display name. The display name's main purpose is to support implementation debugging
      ///</summary>
      public HL7Connect.Cda.ST displayName { get { return propGetDisplayName(); } set { propSetDisplayName(value); } }

      ///<summary>
      /// The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user. 
      /// 
      ///   Note: Local implementations may influence what is required to represent that original text.  Original text can be used in a structured user interface to capture what the user saw as a representation of the code on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user.   It is valid to use the CD datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a code. In a situation where the code is assigned sometime after the text was entered, originalText is the text or phrase used as the basis for assigning the code.   The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.  The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.  Values of type CD MAY have a original text despite not having a code. Any CD value with no code signifies a coding exception. In this case, originalText is a name or description of the concept that was not coded. Such CD values MAY also contain translations.   Translations directly encode the concept described in originalText. The originalText represents the originalText of the concept itself. Translations SHALL NOT have an originalText of their own
      ///</summary>
      private HL7Connect.Cda.ED propGetOriginalText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().originalText);
      }
      private void propSetOriginalText(HL7Connect.Cda.ED value)
      {
        wrapped().originalText = value.wrapped();
      }
      ///<summary>
      /// The text as seen and/or selected by the user who entered the data which represents the intended meaning of the user. 
      /// 
      ///   Note: Local implementations may influence what is required to represent that original text.  Original text can be used in a structured user interface to capture what the user saw as a representation of the code on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user.   It is valid to use the CD datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a code. In a situation where the code is assigned sometime after the text was entered, originalText is the text or phrase used as the basis for assigning the code.   The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification.  The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.  Values of type CD MAY have a original text despite not having a code. Any CD value with no code signifies a coding exception. In this case, originalText is a name or description of the concept that was not coded. Such CD values MAY also contain translations.   Translations directly encode the concept described in originalText. The originalText represents the originalText of the concept itself. Translations SHALL NOT have an originalText of their own
      ///</summary>
      public HL7Connect.Cda.ED originalText { get { return propGetOriginalText(); } set { propSetOriginalText(value); } }

      ///<summary>
      /// the reason why a particular CD has been provided, either as the root concept or as one of the translations.
      /// 
      ///   If populated, the value contained in this attribute SHALL be taken from this enumeration, composed from the HL7 CodingRationale code system -- Coding Rationale for why a code is provided (CD and PQ/PQR) crNullcrO : Original : Originally produced code crP : Post-coded : post-coded from free text source crR : Required : Required by the specification describing the use of the coded concept.The exact form of the requirement is not specified here; it may be required by the specification directly, or it may arise as an indirect result of other conformance tools. More than one different requirement may exist simultaineously, so more than one code in a CD complex may be requiredcrOR : Original &amp; Required :Originally produced code, required by the specification describing the use of the coded concept.crPR : Post-coded &amp; Requierd : post-coded from free text source, required by the specification describing the use of the coded concept
      ///</summary>
      private Tv3CodingRationale propGetCodingRationale()
      {
        return wrapped().codingRationale;
      }
      private void propSetCodingRationale(Tv3CodingRationale value)
      {
        wrapped().codingRationale = value;
      }
      ///<summary>
      /// the reason why a particular CD has been provided, either as the root concept or as one of the translations.
      /// 
      ///   If populated, the value contained in this attribute SHALL be taken from this enumeration, composed from the HL7 CodingRationale code system -- Coding Rationale for why a code is provided (CD and PQ/PQR) crNullcrO : Original : Originally produced code crP : Post-coded : post-coded from free text source crR : Required : Required by the specification describing the use of the coded concept.The exact form of the requirement is not specified here; it may be required by the specification directly, or it may arise as an indirect result of other conformance tools. More than one different requirement may exist simultaineously, so more than one code in a CD complex may be requiredcrOR : Original &amp; Required :Originally produced code, required by the specification describing the use of the coded concept.crPR : Post-coded &amp; Requierd : post-coded from free text source, required by the specification describing the use of the coded concept
      ///</summary>
      public Tv3CodingRationale codingRationale { get { return propGetCodingRationale(); } set { propSetCodingRationale(value); } }

      ///<summary>
      /// A set of other CDs that each represent a translation of this CD into equivalent codes within the same code system or into corresponding concepts from other code systems.
      /// 
      ///   The translations are quasi-synonyms of one real-world concept. Every translation in the set is supposed to express the same meaning "in other words." However, exact synonymy rarely exists between two structurally different coding systems. For this reason, not all of the translations will be equally exact.  Translations SHALL NOT contain translations. The root CD has one set of translations which lists all the translations. The root translation is generally the one that best meets the conformance criteria for the CD. No implication about lineage of the translations can be drawn from the selection of the root code. Instead the properties codingRationale and source is used to trace lineage.  In the absence of a constraining model that makes constraints on the value domain of the CD, any of the translations MAY be the root CD. If the constraining model makes constraints on the value domain of the CD and there is a translation that meets the constraints, that translation SHOULD be the root CD. If the constraining model makes constraints on the value domain of the CD and there is no translation that meets the constraints, then any of the translations MAY be the root, as long as they are assigned a nullFlavor. An alternative is to put none of the translations in the root, and give it a nullFlavor of choice, and put all the translations in the translation property of the root.
      ///</summary>
      private HL7Connect.Cda.SetCD propGetTranslation()
      {
        return HL7Connect.Cda.WrapperFactory.SetCD(wrapped().translation);
      }
      private void propSetTranslation(HL7Connect.Cda.SetCD value)
      {
        wrapped().translation = value.wrapped();
      }
      ///<summary>
      /// A set of other CDs that each represent a translation of this CD into equivalent codes within the same code system or into corresponding concepts from other code systems.
      /// 
      ///   The translations are quasi-synonyms of one real-world concept. Every translation in the set is supposed to express the same meaning "in other words." However, exact synonymy rarely exists between two structurally different coding systems. For this reason, not all of the translations will be equally exact.  Translations SHALL NOT contain translations. The root CD has one set of translations which lists all the translations. The root translation is generally the one that best meets the conformance criteria for the CD. No implication about lineage of the translations can be drawn from the selection of the root code. Instead the properties codingRationale and source is used to trace lineage.  In the absence of a constraining model that makes constraints on the value domain of the CD, any of the translations MAY be the root CD. If the constraining model makes constraints on the value domain of the CD and there is a translation that meets the constraints, that translation SHOULD be the root CD. If the constraining model makes constraints on the value domain of the CD and there is no translation that meets the constraints, then any of the translations MAY be the root, as long as they are assigned a nullFlavor. An alternative is to put none of the translations in the root, and give it a nullFlavor of choice, and put all the translations in the translation property of the root.
      ///</summary>
      public HL7Connect.Cda.SetCD translation { get { return propGetTranslation(); } set { propSetTranslation(value); } }

      ///<summary>
      /// Specifies additional codes that increase the specificity of the the primary code.
      ///</summary>
      private HL7Connect.Cda.ListCR propGetQualifier()
      {
        return HL7Connect.Cda.WrapperFactory.ListCR(wrapped().qualifier);
      }
      private void propSetQualifier(HL7Connect.Cda.ListCR value)
      {
        wrapped().qualifier = value.wrapped();
      }
      ///<summary>
      /// Specifies additional codes that increase the specificity of the the primary code.
      ///</summary>
      public HL7Connect.Cda.ListCR qualifier { get { return propGetQualifier(); } set { propSetQualifier(value); } }

    }

    ///<summary>
    /// Coded data in its simplest form, where only the code is not predetermined. 
    /// 
    ///   The code system and code system version are implied and fixed by the context in which the CS value occurs.    Due to its highly restricted functionality, CS SHALL only be used for simple structural attributes with highly controlled and stable terminologies where: {  all codes come from a single code system;  codes are not reused if their concept is deprecated;  the publication and extensibility properties of the code system are well described and understood.; }
    ///</summary>
    public class CS : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 CS
      ///</summary>
      public CS() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCS()) {} 

      ///<summary>
      /// Create a v3 CS
      ///</summary>
      public CS(string sCode) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCSValue(sCode)) {} 

      internal CS(Iv3CS com) : base(com) {} 

      internal new HCv3CS wrapped() { return (HCv3CS) com; }

      ///<summary>
      /// The plain code symbol defined by the code system. if the code value is empty or null, then there is no code in the code system that represents the concept.
      /// 
      ///  Code SHALL only contain characters that are either a letter, a digit, or one of '.', '-', '_' or ':'. Code systems that are used with CS SHALL NOT define code symbols or expression syntaxes that contain whitespace or any other characters not in this list.
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      private void propSetCode(string value)
      {
        wrapped().Code = value;
      }
      ///<summary>
      /// The plain code symbol defined by the code system. if the code value is empty or null, then there is no code in the code system that represents the concept.
      /// 
      ///  Code SHALL only contain characters that are either a letter, a digit, or one of '.', '-', '_' or ':'. Code systems that are used with CS SHALL NOT define code symbols or expression syntaxes that contain whitespace or any other characters not in this list.
      ///</summary>
      public string code { get { return propGetCode(); } set { propSetCode(value); } }

    }

    ///<summary>
    /// A locatable resource that is identified by a URI, such as a web page, a telephone number (voice, fax or some other resource mediated by telecommunication equipment), an e-mail address, or any other locatable resource that can be specified by a URL.
    /// 
    ///   The address is specified as a Universal Resource Locator (URL) qualified by time specification and use codes that help in deciding which address to use for a given time and purpose.  The value attribute is constrained to be a uniform resource locator specified according to IETF RFCs 1738 and 2806 when used in this datatype.   Note:  The intent of this datatype is to be a locator, not an identifier; this datatype is used to refer to a locatable resource using a URL, and knowing the URL allows one to locate the object. However some use cases have arisen where a URI is used to refer to a locatable resource. Though this datatype allows for URIs to be used, the resource identified SHOULD always be locatable. A common use of locatable URI's is to refer to SOAP attachments
    ///</summary>
    public class TEL : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 TEL
      ///</summary>
      public TEL() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTEL()) {} 

      ///<summary>
      /// Create a v3 TEL
      ///</summary>
      public TEL(string sAddress) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTELValue(sAddress)) {} 

      internal TEL(Iv3TEL com) : base(com) {} 

      internal new HCv3TEL wrapped() { return (HCv3TEL) com; }

      ///<summary>
      /// the canonical representation of the URL (consult ISO 21090 for further details)
      ///</summary>
      public string canonical()
      {
        return wrapped().canonical();
      }

      ///<summary>
      /// A uniform resource identifier specified according to IETF RFC 2396. 
      /// 
      ///   The URI specifies the protocol and the contact point defined by that protocol for the resource.   Examples:  Notable uses of the telecommunication address datatype are for telephone and telefax numbers, e-mail addresses, Hypertext references, FTP references, etc.  If the TEL has a nullFlavor, it is not necessary for the value to contain a valid URL. For instance, if the flavor is UNK, the value may be just "tel:" to indicate that what is unknown is a telephone number
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(string value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// A uniform resource identifier specified according to IETF RFC 2396. 
      /// 
      ///   The URI specifies the protocol and the contact point defined by that protocol for the resource.   Examples:  Notable uses of the telecommunication address datatype are for telephone and telefax numbers, e-mail addresses, Hypertext references, FTP references, etc.  If the TEL has a nullFlavor, it is not necessary for the value to contain a valid URL. For instance, if the flavor is UNK, the value may be just "tel:" to indicate that what is unknown is a telephone number
      ///</summary>
      public string value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// One or more codes advising system or user which telecommunication address in a set of like addresses to select for a given telecommunication need. 
      /// 
      ///   The telecommunication use code is not a complete classification for equipment types or locations. Its main purpose is to suggest or discourage the use of a particular telecommunication address. There are no easily defined rules that govern the selection of a telecommunication address. Conformance statements may clarify what rules may apply or how additional rules are applied.  If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationAddressUse code syste
      ///</summary>
      private ISet<Tv3TelecommunicationAddressUse> propGetUse()
      {
        int i = wrapped().use;
        HashSet<Tv3TelecommunicationAddressUse> result = new HashSet<Tv3TelecommunicationAddressUse>();
        foreach (Tv3TelecommunicationAddressUse a in Enum.GetValues(typeof(Tv3TelecommunicationAddressUse)))
        {
          if ((((int)a) & i) > 0)
            result.Add(a);
        }
        return result;
      }

      private void propSetUse(ISet<Tv3TelecommunicationAddressUse> value)
      {
        int i = 0;
        foreach (Tv3TelecommunicationAddressUse a in Enum.GetValues(typeof(Tv3TelecommunicationAddressUse)))
        {
          if (value.Contains(a))
            i = i | (int) a;
        }
        wrapped().use = i;
      }

      ///<summary>
      /// One or more codes advising system or user which telecommunication address in a set of like addresses to select for a given telecommunication need. 
      /// 
      ///   The telecommunication use code is not a complete classification for equipment types or locations. Its main purpose is to suggest or discourage the use of a particular telecommunication address. There are no easily defined rules that govern the selection of a telecommunication address. Conformance statements may clarify what rules may apply or how additional rules are applied.  If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationAddressUse code syste
      ///</summary>
      public ISet<Tv3TelecommunicationAddressUse> use { get { return propGetUse(); } set { propSetUse(value); } }

      ///<summary>
      /// One or more codes advising a system or user what telecommunication capabilities are known to be associated with the telecommunication address. 
      /// 
      ///   If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationCapability code syste
      ///</summary>
      private ISet<Tv3TelecommunicationCapability> propGetCapabilities()
      {
        int i = wrapped().capabilities;
        HashSet<Tv3TelecommunicationCapability> result = new HashSet<Tv3TelecommunicationCapability>();
        foreach (Tv3TelecommunicationCapability a in Enum.GetValues(typeof(Tv3TelecommunicationCapability)))
        {
          if ((((int)a) & i) > 0)
            result.Add(a);
        }
        return result;
      }

      private void propSetCapabilities(ISet<Tv3TelecommunicationCapability> value)
      {
        int i = 0;
        foreach (Tv3TelecommunicationCapability a in Enum.GetValues(typeof(Tv3TelecommunicationCapability)))
        {
          if (value.Contains(a))
            i = i | (int) a;
        }
        wrapped().capabilities = i;
      }

      ///<summary>
      /// One or more codes advising a system or user what telecommunication capabilities are known to be associated with the telecommunication address. 
      /// 
      ///   If populated, the values contained in this attribute SHALL be taken from the HL7 TelecommunicationCapability code syste
      ///</summary>
      public ISet<Tv3TelecommunicationCapability> capabilities { get { return propGetCapabilities(); } set { propSetCapabilities(value); } }

      ///<summary>
      /// The periods of time during which the telecommunication address can be used. 
      /// 
      ///   For a telephone number, this can indicate the time of day in which the party can be reached on that telephone. For a web address, it may specify a time range in which the web content is promised to be available under the given address
      ///</summary>
      private HL7Connect.Cda.QSET<HL7Connect.Cda.TS> propGetUseablePeriod()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<HL7Connect.Cda.TS>(wrapped().useablePeriod);
      }
      private void propSetUseablePeriod(HL7Connect.Cda.QSET<HL7Connect.Cda.TS> value)
      {
        wrapped().useablePeriod = value.wrapped();
      }
      ///<summary>
      /// The periods of time during which the telecommunication address can be used. 
      /// 
      ///   For a telephone number, this can indicate the time of day in which the party can be reached on that telephone. For a web address, it may specify a time range in which the web content is promised to be available under the given address
      ///</summary>
      public HL7Connect.Cda.QSET<HL7Connect.Cda.TS> useablePeriod { get { return propGetUseablePeriod(); } set { propSetUseablePeriod(value); } }

    }

    ///<summary>
    /// An identifier that uniquely identifies a thing or object. 
    /// 
    ///   Examples are object identifier for HL7 RIM objects, medical record number, order id, service catalog item id, Vehicle Identification Number (VIN), etc. Instance identifiers are usually defined based on ISO object identifiers.  An identifier allows someone to select one record, object or thing from a set of candidates. Usually an identifier alone without any context is not usable. Identifiers are distinguished from concept descriptors as concept descriptors never identify an individual thing, although there may sometimes be an individual record or object that represents the concept.  Information Processing Entities claiming direct or indirect conformance SHALL never assume that receiving applications can infer the identity of issuing authority or the type of the identifier from the identifier or components thereof
    ///</summary>
    public class II : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 II
      ///</summary>
      public II() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newII()) {} 

      ///<summary>
      /// Create a v3 II
      ///</summary>
      public II(string sRoot, string sExtension) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newIIValue(sRoot, sExtension)) {} 

      internal II(Iv3II com) : base(com) {} 

      internal new HCv3II wrapped() { return (HCv3II) com; }

      ///<summary>
      /// A unique identifier that guarantees the global uniqueness of the instance identifier. 
      /// 
      ///   If root is populated, and there is no nullFlavor or extension, then the root is a globally unique identifier in it's own right. In the presence of a non-null extension, the root is the unique identifier for the "namespace" of the identifier in the extension. Note that this does NOT necessarily correlate with the organization that manages the issuing of the identifiers. A given organization may manage multiple identifier namespaces, and control over a given namespace may transfer from organization to organization over time while the root remains the same.   This field can be either a DCE UUID, an Object Identifier (OID), or a special identifier taken from lists that may be published by ISO or HL7.   Comparison of root values is always case sensitive. UUID's SHALL be represented in upper case, so UUID case should always be preserved.   The root SHALL not be used to carry semantic meaning - all it does is ensure global computational uniquenes
      ///</summary>
      private string propGetRoot()
      {
        return wrapped().root;
      }
      private void propSetRoot(string value)
      {
        wrapped().root = value;
      }
      ///<summary>
      /// A unique identifier that guarantees the global uniqueness of the instance identifier. 
      /// 
      ///   If root is populated, and there is no nullFlavor or extension, then the root is a globally unique identifier in it's own right. In the presence of a non-null extension, the root is the unique identifier for the "namespace" of the identifier in the extension. Note that this does NOT necessarily correlate with the organization that manages the issuing of the identifiers. A given organization may manage multiple identifier namespaces, and control over a given namespace may transfer from organization to organization over time while the root remains the same.   This field can be either a DCE UUID, an Object Identifier (OID), or a special identifier taken from lists that may be published by ISO or HL7.   Comparison of root values is always case sensitive. UUID's SHALL be represented in upper case, so UUID case should always be preserved.   The root SHALL not be used to carry semantic meaning - all it does is ensure global computational uniquenes
      ///</summary>
      public string root { get { return propGetRoot(); } set { propSetRoot(value); } }

      ///<summary>
      /// A character string as a unique identifier within the scope of the identifier root. 
      /// 
      ///   The root and extension scheme means that the concatenation of root and extension SHALL be a globally unique identifier for the item that this II value identifies.  Some identifier schemes define certain style options to their code values. For example, the U.S. Social Security Number (SSN) is normally written with dashes that group the digits into a pattern "123-12-1234". However, the dashes are not meaningful and a SSN can also be represented as "123121234" without the dashes. In the case where identifier schemes provide for multiple representations, HL7 or ISO may make a ruling about which is the preferred form and document that ruling where that respective external identifier scheme is recognized.  If no extension attribute is provided in a non-null II, then the root is the complete unique identifier. If the root is not a complete unique identifier, and the extension is not known, then the II  SHALL have a nullFlavor even if the root is populated
      ///</summary>
      private string propGetExtension()
      {
        return wrapped().extension;
      }
      private void propSetExtension(string value)
      {
        wrapped().extension = value;
      }
      ///<summary>
      /// A character string as a unique identifier within the scope of the identifier root. 
      /// 
      ///   The root and extension scheme means that the concatenation of root and extension SHALL be a globally unique identifier for the item that this II value identifies.  Some identifier schemes define certain style options to their code values. For example, the U.S. Social Security Number (SSN) is normally written with dashes that group the digits into a pattern "123-12-1234". However, the dashes are not meaningful and a SSN can also be represented as "123121234" without the dashes. In the case where identifier schemes provide for multiple representations, HL7 or ISO may make a ruling about which is the preferred form and document that ruling where that respective external identifier scheme is recognized.  If no extension attribute is provided in a non-null II, then the root is the complete unique identifier. If the root is not a complete unique identifier, and the extension is not known, then the II  SHALL have a nullFlavor even if the root is populated
      ///</summary>
      public string extension { get { return propGetExtension(); } set { propSetExtension(value); } }

      ///<summary>
      /// This is a human-readable name for the namespace represented in the root. 
      /// 
      ///   Note:  It is a descriptive name for the actual namespace. e.g. "California, U.S. Driver's License Number, 1970-".  IdentifierName does NOT refer to the organization which issued the identifier (e.g. California Dept. of Motor Vehicles). It is intended for use as a human readable label when an identifier must be displayed to a human user where an OID would not be meaningful.   The Identifier Name has no computational value. IdentifierName can never modify the meaning of the root attribute. The purpose of the Identifer Name is to assist an unaided human interpreter of an II value to interpret the authority. Applications SHALL NOT attempt to perform any decision-making, matching, filtering or other processing based on the presence or value of this property. It is for display and development assistance only. All decision logic MUST be based solely on the root and extension properties. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement identifierName but SHALL NOT reject instances because identifierName is present.  Note: In general, it should only be used when an extension is present, allowing for a display such as "California, U.S. Driver's License Number, 1970-: 123456789". There are absolutely no guidelines for the contents of this text other than it should be completely descriptive of the namespace. E.g. "Driver's License" or even "California Driver's License" would not be ideal. However, formatting, capitalization, whitepace, language, etc. are completely up to the sender
      ///</summary>
      private string propGetIdentifierName()
      {
        return wrapped().identifierName;
      }
      private void propSetIdentifierName(string value)
      {
        wrapped().identifierName = value;
      }
      ///<summary>
      /// This is a human-readable name for the namespace represented in the root. 
      /// 
      ///   Note:  It is a descriptive name for the actual namespace. e.g. "California, U.S. Driver's License Number, 1970-".  IdentifierName does NOT refer to the organization which issued the identifier (e.g. California Dept. of Motor Vehicles). It is intended for use as a human readable label when an identifier must be displayed to a human user where an OID would not be meaningful.   The Identifier Name has no computational value. IdentifierName can never modify the meaning of the root attribute. The purpose of the Identifer Name is to assist an unaided human interpreter of an II value to interpret the authority. Applications SHALL NOT attempt to perform any decision-making, matching, filtering or other processing based on the presence or value of this property. It is for display and development assistance only. All decision logic MUST be based solely on the root and extension properties. Information Processing Entities claiming direct or indirect conformance MAY choose not to implement identifierName but SHALL NOT reject instances because identifierName is present.  Note: In general, it should only be used when an extension is present, allowing for a display such as "California, U.S. Driver's License Number, 1970-: 123456789". There are absolutely no guidelines for the contents of this text other than it should be completely descriptive of the namespace. E.g. "Driver's License" or even "California Driver's License" would not be ideal. However, formatting, capitalization, whitepace, language, etc. are completely up to the sender
      ///</summary>
      public string identifierName { get { return propGetIdentifierName(); } set { propSetIdentifierName(value); } }

      ///<summary>
      /// If the identifier is intended for human display and data entry (displayable = true) as opposed to pure machine interoperation (displayable = false).
      /// 
      ///  Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayable but SHALL NOT reject instances because displayable is present
      ///</summary>
      private bool propGetDisplayable()
      {
        return wrapped().displayable != 0;
      }
      private void propSetDisplayable(bool value)
      {
        wrapped().displayable = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// If the identifier is intended for human display and data entry (displayable = true) as opposed to pure machine interoperation (displayable = false).
      /// 
      ///  Information Processing Entities claiming direct or indirect conformance MAY choose not to implement displayable but SHALL NOT reject instances because displayable is present
      ///</summary>
      public bool displayable { get { return propGetDisplayable(); } set { propSetDisplayable(value); } }

      ///<summary>
      /// false if displayable is null, true if displayable is either true or false
      ///</summary>
      private bool propGetHasDisplayable()
      {
        return wrapped().HasDisplayable != 0;
      }
      ///<summary>
      /// false if displayable is null, true if displayable is either true or false
      ///</summary>
      public bool HasDisplayable { get { return propGetHasDisplayable(); } }

      ///<summary>
      /// The scope in which the identifier applies to the object with which it is associated.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 IdentifierScope code system -- Possible scopes for an identifier isNullisBUSN : Business identifier : An identifier whose scope is defined by business practices associated with the object. In contrast to the other scope identifiers, the scope of the use of the id is not necessarily restricted to a single object, but may be reused for other objects closely associated with the object due to business practiceisOBJ : Object identifier : The identifier associated with a particular object. It remains consistent as the object undergoes state transitionsisVER : Version Identifier : An identifier that references a particular object as it existed at a given point in time.  The identifier SHALL change with each state transition on the object. I.e. The version identifier of an object prior to a 'suspend' state transition is distinct from the identifier of the object after the state transition. Each version identifier can be tied to exactly one ControlAct event which brought that version into being (though the control act may never be instantiated). NOTE: Applications that do not support versioning of objects must ignore and not persist these ids to avoid confusion resulting from leaving the same identifier on an object that undergoes changesisVW : View specific identifier : An identifier for a particular snapshot of a version of the object.  This identifies a view of the business object at a particular point in time, and as such identifies a set of data items that can be digitally signed and/or attested. This is in contrast to the Version Identifier which identifies the object at a specific time, but not the amount of information being asserted about the object. This identifier would be changed when a transformation of the information is performed (eg to add code translations, to provide a simplified textual rendering, or to provide additional information about the object as it existed at the specific point in time)
      ///</summary>
      private Tv3IdentifierScope propGetScope()
      {
        return wrapped().scope;
      }
      private void propSetScope(Tv3IdentifierScope value)
      {
        wrapped().scope = value;
      }
      ///<summary>
      /// The scope in which the identifier applies to the object with which it is associated.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 IdentifierScope code system -- Possible scopes for an identifier isNullisBUSN : Business identifier : An identifier whose scope is defined by business practices associated with the object. In contrast to the other scope identifiers, the scope of the use of the id is not necessarily restricted to a single object, but may be reused for other objects closely associated with the object due to business practiceisOBJ : Object identifier : The identifier associated with a particular object. It remains consistent as the object undergoes state transitionsisVER : Version Identifier : An identifier that references a particular object as it existed at a given point in time.  The identifier SHALL change with each state transition on the object. I.e. The version identifier of an object prior to a 'suspend' state transition is distinct from the identifier of the object after the state transition. Each version identifier can be tied to exactly one ControlAct event which brought that version into being (though the control act may never be instantiated). NOTE: Applications that do not support versioning of objects must ignore and not persist these ids to avoid confusion resulting from leaving the same identifier on an object that undergoes changesisVW : View specific identifier : An identifier for a particular snapshot of a version of the object.  This identifies a view of the business object at a particular point in time, and as such identifies a set of data items that can be digitally signed and/or attested. This is in contrast to the Version Identifier which identifies the object at a specific time, but not the amount of information being asserted about the object. This identifier would be changed when a transformation of the information is performed (eg to add code translations, to provide a simplified textual rendering, or to provide additional information about the object as it existed at the specific point in time)
      ///</summary>
      public Tv3IdentifierScope scope { get { return propGetScope(); } set { propSetScope(value); } }

      ///<summary>
      /// The reliability with which this identifier is known. This attribute may be used to assist with identifier matching algorithms.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 IdentifierReliability code system. -- Possible reliability markers for an identifier irNullirISS : Issued by system : The identifier was issued by the system responsible for constructing the instanceirVRFirUNV : Unverified by system : The identifier was provided to the system that constructed the instance, but has not been verified. e.g. a Driver's licence entered manually into a system by a user
      ///</summary>
      private Tv3IdentifierReliability propGetReliability()
      {
        return wrapped().reliability;
      }
      private void propSetReliability(Tv3IdentifierReliability value)
      {
        wrapped().reliability = value;
      }
      ///<summary>
      /// The reliability with which this identifier is known. This attribute may be used to assist with identifier matching algorithms.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 IdentifierReliability code system. -- Possible reliability markers for an identifier irNullirISS : Issued by system : The identifier was issued by the system responsible for constructing the instanceirVRFirUNV : Unverified by system : The identifier was provided to the system that constructed the instance, but has not been verified. e.g. a Driver's licence entered manually into a system by a user
      ///</summary>
      public Tv3IdentifierReliability reliability { get { return propGetReliability(); } set { propSetReliability(value); } }

    }

    ///<summary>
    /// A part of a name or address. Each part is a character string that may be coded, and that also may have a nullFlavor. The string content must always be provided whether a code is provided or not.
    ///</summary>
    public class XP : HL7Connect.Cda.DataValue
    {

      ///<summary>
      /// Create a v3 XP
      ///</summary>
      public XP() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newXP()) {} 

      internal XP(Iv3XP com) : base(com) {} 

      internal new HCv3XP wrapped() { return (HCv3XP) com; }

      ///<summary>
      /// Convenience property
      ///</summary>
      public bool isNonNull()
      {
        return wrapped().isNonNull() != 0;
      }

      ///<summary>
      /// If the part is not a proper value, indicates the reason.
      /// 
      ///   For further information concerning nullFlavor, see 7.3.3.3.1 -- NullFlavor that applies to the property. Note that nfNull means Not Null nfNullnfNI : No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value nfINV : Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variablenfOTH : Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)nfNINF : Negative Infinity : Negative infinity of numbersnfPINF : Positive Infinity : Positive infinity of numbersnfUNC : Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)nfDER : Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)nfUNK : Unknown : A proper value is applicable, but not known nfASKU : Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn't know) nfNAV : Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later nfQS : Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of waternfNASK : Not Asked : This information has not been sought (e.g., patient was not asked) nfTRC : Trace : The content is greater than zero, but too small to be quantifiednfMSK : Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detailnfNA : Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male)
      ///</summary>
      private Tv3NullFlavor propGetNullFlavor()
      {
        return wrapped().nullFlavor;
      }
      private void propSetNullFlavor(Tv3NullFlavor value)
      {
        wrapped().nullFlavor = value;
      }
      ///<summary>
      /// If the part is not a proper value, indicates the reason.
      /// 
      ///   For further information concerning nullFlavor, see 7.3.3.3.1 -- NullFlavor that applies to the property. Note that nfNull means Not Null nfNullnfNI : No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value nfINV : Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variablenfOTH : Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)nfNINF : Negative Infinity : Negative infinity of numbersnfPINF : Positive Infinity : Positive infinity of numbersnfUNC : Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)nfDER : Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)nfUNK : Unknown : A proper value is applicable, but not known nfASKU : Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn't know) nfNAV : Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later nfQS : Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of waternfNASK : Not Asked : This information has not been sought (e.g., patient was not asked) nfTRC : Trace : The content is greater than zero, but too small to be quantifiednfMSK : Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detailnfNA : Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male)
      ///</summary>
      public Tv3NullFlavor nullFlavor { get { return propGetNullFlavor(); } set { propSetNullFlavor(value); } }

      ///<summary>
      /// The actual string value of the part. If no nullFlavor is provided, some content must be present in this attribute
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(string value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// The actual string value of the part. If no nullFlavor is provided, some content must be present in this attribute
      ///</summary>
      public string value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// A code assigned to the part by some coding system, if appropriate
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      private void propSetCode(string value)
      {
        wrapped().Code = value;
      }
      ///<summary>
      /// A code assigned to the part by some coding system, if appropriate
      ///</summary>
      public string code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// The code system from which the code is taken. 
      /// 
      ///   The choice of coding system depends on the part type defined in the concrete specializations. The codeSystem SHALL be populated if a code is populated
      ///</summary>
      private string propGetCodeSystem()
      {
        return wrapped().codeSystem;
      }
      private void propSetCodeSystem(string value)
      {
        wrapped().codeSystem = value;
      }
      ///<summary>
      /// The code system from which the code is taken. 
      /// 
      ///   The choice of coding system depends on the part type defined in the concrete specializations. The codeSystem SHALL be populated if a code is populated
      ///</summary>
      public string codeSystem { get { return propGetCodeSystem(); } set { propSetCodeSystem(value); } }

      ///<summary>
      /// The version of the coding system, if required.
      /// 
      ///   The codeSystem SHALL be populated if a codeSystemVersion is populated
      ///</summary>
      private string propGetCodeSystemVersion()
      {
        return wrapped().codeSystemVersion;
      }
      private void propSetCodeSystemVersion(string value)
      {
        wrapped().codeSystemVersion = value;
      }
      ///<summary>
      /// The version of the coding system, if required.
      /// 
      ///   The codeSystem SHALL be populated if a codeSystemVersion is populated
      ///</summary>
      public string codeSystemVersion { get { return propGetCodeSystemVersion(); } set { propSetCodeSystemVersion(value); } }

      ///<summary>
      /// The human language of the content. Valid codes are taken from the IETF &lt;a href="http://www.ietf.org/rfc/rfc3066.txt" \o "http://www.ietf.org/rfc/rfc3066.txt"&gt;RFC 3066&lt;/a&gt;. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
      /// 
      ///   While parts may be assigned a language, the meaning of the part is not dependent on the language, and applications SHALL not be required to indicate the linguistic origin of any name or address part
      ///</summary>
      private string propGetLanguage()
      {
        return wrapped().language;
      }
      private void propSetLanguage(string value)
      {
        wrapped().language = value;
      }
      ///<summary>
      /// The human language of the content. Valid codes are taken from the IETF &lt;a href="http://www.ietf.org/rfc/rfc3066.txt" \o "http://www.ietf.org/rfc/rfc3066.txt"&gt;RFC 3066&lt;/a&gt;. If this attribute is null, the language may be inferred from elsewhere, either from the context or from unicode language tags, for example.
      /// 
      ///   While parts may be assigned a language, the meaning of the part is not dependent on the language, and applications SHALL not be required to indicate the linguistic origin of any name or address part
      ///</summary>
      public string language { get { return propGetLanguage(); } set { propSetLanguage(value); } }

    }

    ///<summary>
    /// A part that may have a type-tag signifying its role in the address. Typical parts that exist in about every address are street, house number, or post box, postal code, city, country but other roles may be defined regionally, nationally, or on an enterprise level (e.g. in military addresses). 
    /// 
    ///   Addresses are usually broken up into lines, which may be indicated by special line-breaking delimiter elements (e.g., DEL).
    ///</summary>
    public class ADXP : HL7Connect.Cda.XP
    {

      ///<summary>
      /// Create a v3 ADXP
      ///</summary>
      public ADXP() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newADXP()) {} 

      internal ADXP(Iv3ADXP com) : base(com) {} 

      internal new HCv3ADXP wrapped() { return (HCv3ADXP) com; }

      ///<summary>
      /// Whether an address part names the street, city, country, postal code, post box, etc.
      /// 
      ///  If the type is NULL the address part is unclassified and would simply appear on an address label as is. If populated, the value of this attribute SHALL be taken from the HL7 AddressPartType code system. -- Possible address part types aptNullaptAL : Address Line : An address line is for either an additional locator, a delivery address or a street address. An address generally has only a delivery address line or a street address line, but not bothaptADL : Additional Locator : This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., "3rd floor, Appt. 342"). This can also be a designator pointing away from the location, rather than specifying a smaller location within some larger one (e.g., Dutch "t.o." means "opposite to" for house boats located across the street facing houses)aptUNID : Unit Identifier : The number or name of a specific unit contained within a building or complex, as assigned by that building or complexaptUNIT : Unit Designator : Indicates the type of specific unit contained within a building or complex. E.g. Apartment, Floor aptDAL : Delivery Address Line : A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc. An address generally has only a delivery address line or a street address line, but not both.aptDINST : Delivery Installation Type : Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.aptDINSTA : Delivery Installation Area : The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal routeaptDINSTQ : Delivery Installation Qualifier : A number, letter or name identifying a delivery installation. E.g., for Station A, the delivery installation qualifier would be 'A'.aptDMOD : Delivery Mode : Indicates the type of service offered, method of delivery. For example: post office box, rural route, general delivery, etc.aptDMODID : Delivery Mode Identifier: Represents the routing information such as a letter carrier route number. It is the identifying number of the designator (the box number or rural route number)aptSAL : Street Address Line : A street address line is frequently used instead of breaking out build number, street name, street type, etc. An address generally has only a delivery address line or a street address line, but not both.aptBNR : Building Number : The number of a building, house or lot alongside the street. Also known as "primary street number". This does not number the street but rather the buildingaptBNN : Building Number Numeric : The numeric portion of a building number aptBNS : Building Number Suffix : Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number aptSTR : Street Name : The name of the street, including the typeaptSTB : Street Name Base : The base name of a roadway or artery recognized by a municipality (excluding street type and direction) aptSTTYP : Street Type : The designation given to the street. (e.g. Street, Avenue, Crescent, etc.) aptDIR : Direction : Direction (e.g., N, S, W, E) aptINT : Intersection : An intersection denotes that the actual address is located at or close to the intersection of two or more streetsaptCAR : Care of : The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient.  Note: This is included only to support the convention of writing c/- address lines. This item is not appropriate for use when information is entrusted to one party on behalf of another in some significant way.aptCEN : Census Tract : A geographic sub-unit delineated for demographic purposes aptCNT : Country : CountryaptCPA : County or Parish : A sub-unit of a state or province. (49 of the United States of America use the term "county;" Louisiana uses the term "parish") aptCTY : Municipality : The name of the city, town, village, or other community or delivery center aptDEL : Delimiter : Delimiters are printed without framing white space. If no value component is provided, the delimiter appears as a line breakaptPOB : Post box : A numbered box located in a post station aptPRE : Precinct : A subsection of a municipality aptSTA : State or Province : A sub-unit of a country with limited sovereignty in a federally organized countryaptZIP : Postal Code : A postal code designating a region defined by the postal service
      ///</summary>
      private Tv3AddressPartType propGetType_()
      {
        return wrapped().type_;
      }
      private void propSetType_(Tv3AddressPartType value)
      {
        wrapped().type_ = value;
      }
      ///<summary>
      /// Whether an address part names the street, city, country, postal code, post box, etc.
      /// 
      ///  If the type is NULL the address part is unclassified and would simply appear on an address label as is. If populated, the value of this attribute SHALL be taken from the HL7 AddressPartType code system. -- Possible address part types aptNullaptAL : Address Line : An address line is for either an additional locator, a delivery address or a street address. An address generally has only a delivery address line or a street address line, but not bothaptADL : Additional Locator : This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., "3rd floor, Appt. 342"). This can also be a designator pointing away from the location, rather than specifying a smaller location within some larger one (e.g., Dutch "t.o." means "opposite to" for house boats located across the street facing houses)aptUNID : Unit Identifier : The number or name of a specific unit contained within a building or complex, as assigned by that building or complexaptUNIT : Unit Designator : Indicates the type of specific unit contained within a building or complex. E.g. Apartment, Floor aptDAL : Delivery Address Line : A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc. An address generally has only a delivery address line or a street address line, but not both.aptDINST : Delivery Installation Type : Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.aptDINSTA : Delivery Installation Area : The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal routeaptDINSTQ : Delivery Installation Qualifier : A number, letter or name identifying a delivery installation. E.g., for Station A, the delivery installation qualifier would be 'A'.aptDMOD : Delivery Mode : Indicates the type of service offered, method of delivery. For example: post office box, rural route, general delivery, etc.aptDMODID : Delivery Mode Identifier: Represents the routing information such as a letter carrier route number. It is the identifying number of the designator (the box number or rural route number)aptSAL : Street Address Line : A street address line is frequently used instead of breaking out build number, street name, street type, etc. An address generally has only a delivery address line or a street address line, but not both.aptBNR : Building Number : The number of a building, house or lot alongside the street. Also known as "primary street number". This does not number the street but rather the buildingaptBNN : Building Number Numeric : The numeric portion of a building number aptBNS : Building Number Suffix : Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number aptSTR : Street Name : The name of the street, including the typeaptSTB : Street Name Base : The base name of a roadway or artery recognized by a municipality (excluding street type and direction) aptSTTYP : Street Type : The designation given to the street. (e.g. Street, Avenue, Crescent, etc.) aptDIR : Direction : Direction (e.g., N, S, W, E) aptINT : Intersection : An intersection denotes that the actual address is located at or close to the intersection of two or more streetsaptCAR : Care of : The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient.  Note: This is included only to support the convention of writing c/- address lines. This item is not appropriate for use when information is entrusted to one party on behalf of another in some significant way.aptCEN : Census Tract : A geographic sub-unit delineated for demographic purposes aptCNT : Country : CountryaptCPA : County or Parish : A sub-unit of a state or province. (49 of the United States of America use the term "county;" Louisiana uses the term "parish") aptCTY : Municipality : The name of the city, town, village, or other community or delivery center aptDEL : Delimiter : Delimiters are printed without framing white space. If no value component is provided, the delimiter appears as a line breakaptPOB : Post box : A numbered box located in a post station aptPRE : Precinct : A subsection of a municipality aptSTA : State or Province : A sub-unit of a country with limited sovereignty in a federally organized countryaptZIP : Postal Code : A postal code designating a region defined by the postal service
      ///</summary>
      public Tv3AddressPartType type_ { get { return propGetType_(); } set { propSetType_(value); } }

    }

    ///<summary>
    /// Mailing and home or office addresses. 
    /// 
    ///   AD is primarily used to communicate data that will allow printing mail labels, or that will allow a person to physically visit that address. The postal address datatype is not supposed to be a container for additional information that might be useful for finding geographic locations (e.g., GPS coordinates) or for performing epidemiological studies. Such additional information should be captured by other, more appropriate data structures.  Addresses are essentially sequences of address parts, but add a "use" code and a valid time range for information about if and when the address can be used for a given purpose
    ///</summary>
    public class AD : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 AD
      ///</summary>
      public AD() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAD()) {} 

      internal AD(Iv3AD com) : base(com) {} 

      internal new HCv3AD wrapped() { return (HCv3AD) com; }

      ///<summary>
      /// Shortcut method. Add an address part with a type which is one of the Tv3AddressPartType enumerated constants. 
      /// 
      /// Possible address part types aptNullaptAL : Address Line : An address line is for either an additional locator, a delivery address or a street address. An address generally has only a delivery address line or a street address line, but not bothaptADL : Additional Locator : This can be a unit designator, such as apartment number, suite number, or floor. There may be several unit designators in an address (e.g., "3rd floor, Appt. 342"). This can also be a designator pointing away from the location, rather than specifying a smaller location within some larger one (e.g., Dutch "t.o." means "opposite to" for house boats located across the street facing houses)aptUNID : Unit Identifier : The number or name of a specific unit contained within a building or complex, as assigned by that building or complexaptUNIT : Unit Designator : Indicates the type of specific unit contained within a building or complex. E.g. Apartment, Floor aptDAL : Delivery Address Line : A delivery address line is frequently used instead of breaking out delivery mode, delivery installation, etc. An address generally has only a delivery address line or a street address line, but not both.aptDINST : Delivery Installation Type : Indicates the type of delivery installation (the facility to which the mail will be delivered prior to final shipping via the delivery mode.) Example: post office, letter carrier depot, community mail center, station, etc.aptDINSTA : Delivery Installation Area : The location of the delivery installation, usually a town or city, and is only required if the area is different from the municipality. Area to which mail delivery service is provided from any postal facility or service such as an individual letter carrier, rural route, or postal routeaptDINSTQ : Delivery Installation Qualifier : A number, letter or name identifying a delivery installation. E.g., for Station A, the delivery installation qualifier would be 'A'.aptDMOD : Delivery Mode : Indicates the type of service offered, method of delivery. For example: post office box, rural route, general delivery, etc.aptDMODID : Delivery Mode Identifier: Represents the routing information such as a letter carrier route number. It is the identifying number of the designator (the box number or rural route number)aptSAL : Street Address Line : A street address line is frequently used instead of breaking out build number, street name, street type, etc. An address generally has only a delivery address line or a street address line, but not both.aptBNR : Building Number : The number of a building, house or lot alongside the street. Also known as "primary street number". This does not number the street but rather the buildingaptBNN : Building Number Numeric : The numeric portion of a building number aptBNS : Building Number Suffix : Any alphabetic character, fraction or other text that may appear after the numeric portion of a building number aptSTR : Street Name : The name of the street, including the typeaptSTB : Street Name Base : The base name of a roadway or artery recognized by a municipality (excluding street type and direction) aptSTTYP : Street Type : The designation given to the street. (e.g. Street, Avenue, Crescent, etc.) aptDIR : Direction : Direction (e.g., N, S, W, E) aptINT : Intersection : An intersection denotes that the actual address is located at or close to the intersection of two or more streetsaptCAR : Care of : The name of the party who will take receipt at the specified address, and will take on responsibility for ensuring delivery to the target recipient.  Note: This is included only to support the convention of writing c/- address lines. This item is not appropriate for use when information is entrusted to one party on behalf of another in some significant way.aptCEN : Census Tract : A geographic sub-unit delineated for demographic purposes aptCNT : Country : CountryaptCPA : County or Parish : A sub-unit of a state or province. (49 of the United States of America use the term "county;" Louisiana uses the term "parish") aptCTY : Municipality : The name of the city, town, village, or other community or delivery center aptDEL : Delimiter : Delimiters are printed without framing white space. If no value component is provided, the delimiter appears as a line breakaptPOB : Post box : A numbered box located in a post station aptPRE : Precinct : A subsection of a municipality aptSTA : State or Province : A sub-unit of a country with limited sovereignty in a federally organized countryaptZIP : Postal Code : A postal code designating a region defined by the postal service
      ///</summary>
      public HL7Connect.Cda.ADXP AddPart(string sValue, Tv3AddressPartType type_)
      {
        return HL7Connect.Cda.WrapperFactory.ADXP(wrapped().AddPart(sValue, type_));
      }

      ///<summary>
      /// true if the address includes a part that matches oPart (same type and value)
      ///</summary>
      public bool HasPart(HL7Connect.Cda.ADXP oPart)
      {
        return wrapped().HasPart(oPart.wrapped()) != 0;
      }

      ///<summary>
      /// A sequence of address parts, such as street or post office Box, city, postal code, country, etc
      ///</summary>
      private HL7Connect.Cda.ListADXP propGetPart()
      {
        return HL7Connect.Cda.WrapperFactory.ListADXP(wrapped().part);
      }
      private void propSetPart(HL7Connect.Cda.ListADXP value)
      {
        wrapped().part = value.wrapped();
      }
      ///<summary>
      /// A sequence of address parts, such as street or post office Box, city, postal code, country, etc
      ///</summary>
      public HL7Connect.Cda.ListADXP part { get { return propGetPart(); } set { propSetPart(value); } }

      ///<summary>
      /// A set of codes advising a system or user which address in a set of like addresses to select for a given purpose. 
      /// 
      ///   An address without specific use code might be a default address useful for any purpose, but an address with a specific use code would be preferred for that respective purpose.  If populated, the values contained in this attribute SHALL be taken from the HL7 PostalAddressUse code system.
      ///</summary>
      private ISet<Tv3PostalAddressUse> propGetUse()
      {
        int i = wrapped().use;
        HashSet<Tv3PostalAddressUse> result = new HashSet<Tv3PostalAddressUse>();
        foreach (Tv3PostalAddressUse a in Enum.GetValues(typeof(Tv3PostalAddressUse)))
        {
          if ((((int)a) & i) > 0)
            result.Add(a);
        }
        return result;
      }

      private void propSetUse(ISet<Tv3PostalAddressUse> value)
      {
        int i = 0;
        foreach (Tv3PostalAddressUse a in Enum.GetValues(typeof(Tv3PostalAddressUse)))
        {
          if (value.Contains(a))
            i = i | (int) a;
        }
        wrapped().use = i;
      }

      ///<summary>
      /// A set of codes advising a system or user which address in a set of like addresses to select for a given purpose. 
      /// 
      ///   An address without specific use code might be a default address useful for any purpose, but an address with a specific use code would be preferred for that respective purpose.  If populated, the values contained in this attribute SHALL be taken from the HL7 PostalAddressUse code system.
      ///</summary>
      public ISet<Tv3PostalAddressUse> use { get { return propGetUse(); } set { propSetUse(value); } }

      ///<summary>
      /// A General Timing Specification (GTS) specifying the periods of time during which the address can be used. This is used to specify different addresses for different times of the week or year
      ///</summary>
      private HL7Connect.Cda.QSET<HL7Connect.Cda.TS> propGetUseablePeriod()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<HL7Connect.Cda.TS>(wrapped().useablePeriod);
      }
      private void propSetUseablePeriod(HL7Connect.Cda.QSET<HL7Connect.Cda.TS> value)
      {
        wrapped().useablePeriod = value.wrapped();
      }
      ///<summary>
      /// A General Timing Specification (GTS) specifying the periods of time during which the address can be used. This is used to specify different addresses for different times of the week or year
      ///</summary>
      public HL7Connect.Cda.QSET<HL7Connect.Cda.TS> useablePeriod { get { return propGetUseablePeriod(); } set { propSetUseablePeriod(value); } }

      ///<summary>
      /// A boolean value specifying whether the order of the address parts is known or not. While the address parts are always a sequence, the order in which they are presented may or may not be known to be true or important. Where this matters, the isNotOrdered property can be used to convey this information. The default value for isNotOrdered is false
      ///</summary>
      private bool propGetIsNotOrdered()
      {
        return wrapped().isNotOrdered != 0;
      }
      private void propSetIsNotOrdered(bool value)
      {
        wrapped().isNotOrdered = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// A boolean value specifying whether the order of the address parts is known or not. While the address parts are always a sequence, the order in which they are presented may or may not be known to be true or important. Where this matters, the isNotOrdered property can be used to convey this information. The default value for isNotOrdered is false
      ///</summary>
      public bool isNotOrdered { get { return propGetIsNotOrdered(); } set { propSetIsNotOrdered(value); } }

      ///<summary>
      /// false if isNotOrdered is null, true if isNotOrdered is either true or false
      ///</summary>
      private bool propGetHasIsNotOrdered()
      {
        return wrapped().HasIsNotOrdered != 0;
      }
      private void propSetHasIsNotOrdered(bool value)
      {
        wrapped().HasIsNotOrdered = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// false if isNotOrdered is null, true if isNotOrdered is either true or false
      ///</summary>
      public bool HasIsNotOrdered { get { return propGetHasIsNotOrdered(); } set { propSetHasIsNotOrdered(value); } }

    }

    ///<summary>
    /// A part that may have a type code signifying the role of the part in the whole entity name, and qualifier codes for more detail about the name part type. (Typical name parts for person names are given names, and family names, titles, etc. ).
    ///</summary>
    public class ENXP : HL7Connect.Cda.XP
    {

      ///<summary>
      /// Create a v3 ENXP
      ///</summary>
      public ENXP() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newENXP()) {} 

      internal ENXP(Iv3ENXP com) : base(com) {} 

      internal new HCv3ENXP wrapped() { return (HCv3ENXP) com; }

      ///<summary>
      /// Indicates whether the name part is a given name, family name, prefix, suffix, etc. 
      /// 
      ///   Not every name part must have a type code, if the type code is unknown, not applicable, or simply undefined this is expressed by a null value (type.isNull). For example, a name may be "Rogan Sulma" and it may not be clear which one is a given name or which is a last name, or whether Rogan may be a title. If populated, the value of this attribute SHALL be taken from the HL7 EntityNamePartType2 code system.  -- Possible types for a name part nptNullnptFAM : Family : Family name, this is the name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his fathernptGIV : Given: Given name. Note: don't call it "first name" since this given names do not always come firstnptTITLE : Title : Part of the name that is acquired as a title due to academic, legal, employment or nobility status etc. Note: Title name parts include name parts that come after the name such as qualificationsnptDEL : Delimiter : A delimiter has no meaning other than being literally printed in this name representation. A delimiter has no implicit leading and trailing white space
      ///</summary>
      private Tv3EntityNamePartType propGetType_()
      {
        return wrapped().type_;
      }
      private void propSetType_(Tv3EntityNamePartType value)
      {
        wrapped().type_ = value;
      }
      ///<summary>
      /// Indicates whether the name part is a given name, family name, prefix, suffix, etc. 
      /// 
      ///   Not every name part must have a type code, if the type code is unknown, not applicable, or simply undefined this is expressed by a null value (type.isNull). For example, a name may be "Rogan Sulma" and it may not be clear which one is a given name or which is a last name, or whether Rogan may be a title. If populated, the value of this attribute SHALL be taken from the HL7 EntityNamePartType2 code system.  -- Possible types for a name part nptNullnptFAM : Family : Family name, this is the name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his fathernptGIV : Given: Given name. Note: don't call it "first name" since this given names do not always come firstnptTITLE : Title : Part of the name that is acquired as a title due to academic, legal, employment or nobility status etc. Note: Title name parts include name parts that come after the name such as qualificationsnptDEL : Delimiter : A delimiter has no meaning other than being literally printed in this name representation. A delimiter has no implicit leading and trailing white space
      ///</summary>
      public Tv3EntityNamePartType type_ { get { return propGetType_(); } set { propSetType_(value); } }

      ///<summary>
      /// The qualifier is a set of codes each of which specifies a certain subcategory of the name part in addition to the main name part type.
      /// 
      ///  Example, a given name may be flagged as a nickname (CL), a family name may be a name acquired by marriage (SP) or a name from birth (BR). If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNamePartQualifier2 code system.
      ///</summary>
      private ISet<Tv3EntityNamePartQualifier> propGetQualifier()
      {
        int i = wrapped().qualifier;
        HashSet<Tv3EntityNamePartQualifier> result = new HashSet<Tv3EntityNamePartQualifier>();
        foreach (Tv3EntityNamePartQualifier a in Enum.GetValues(typeof(Tv3EntityNamePartQualifier)))
        {
          if ((((int)a) & i) > 0)
            result.Add(a);
        }
        return result;
      }

      private void propSetQualifier(ISet<Tv3EntityNamePartQualifier> value)
      {
        int i = 0;
        foreach (Tv3EntityNamePartQualifier a in Enum.GetValues(typeof(Tv3EntityNamePartQualifier)))
        {
          if (value.Contains(a))
            i = i | (int) a;
        }
        wrapped().qualifier = i;
      }

      ///<summary>
      /// The qualifier is a set of codes each of which specifies a certain subcategory of the name part in addition to the main name part type.
      /// 
      ///  Example, a given name may be flagged as a nickname (CL), a family name may be a name acquired by marriage (SP) or a name from birth (BR). If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNamePartQualifier2 code system.
      ///</summary>
      public ISet<Tv3EntityNamePartQualifier> qualifier { get { return propGetQualifier(); } set { propSetQualifier(value); } }

    }

    ///<summary>
    /// A name for a person, organization, place or thing. 
    /// 
    ///   Examples:   "Jim Bob Walton, Jr.", "Health Level Seven, Inc.", "Lake Tahoe", etc. An entity name may be as simple as a character string or may consist of several entity name parts, such as, "Jim", "Bob", "Walton", and "Jr.", "Health Level Seven" and "Inc.".  Entity names are essentially sequences of entity name parts, but add a "use" code and a valid time range for information about when the name was used and how to choose between multiple aliases that may be valid at the same point in time
    ///</summary>
    public class EN : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 EN
      ///</summary>
      public EN() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEN()) {} 

      ///<summary>
      /// Create a v3 EN that contains a single part of unknown type (plain text)
      ///</summary>
      public EN(string sValue) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newENPlain(sValue)) {} 

      ///<summary>
      /// Create a v3 EN that contains a simple name with two parts, given and family. (if you want a different order, you'll have to build it by parts)
      ///</summary>
      public EN(string sGiven, string sFamily) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newENSimple(sGiven, sFamily)) {} 

      internal EN(Iv3EN com) : base(com) {} 

      internal new HCv3EN wrapped() { return (HCv3EN) com; }

      ///<summary>
      /// Shortcut method. Add a name part with a type which is one of the Tv3EntityNamePartType enumerated constants. 
      /// 
      /// Possible types for a name part nptNullnptFAM : Family : Family name, this is the name that links to the genealogy. In some cultures (e.g. Eritrea) the family name of a son is the first name of his fathernptGIV : Given: Given name. Note: don't call it "first name" since this given names do not always come firstnptTITLE : Title : Part of the name that is acquired as a title due to academic, legal, employment or nobility status etc. Note: Title name parts include name parts that come after the name such as qualificationsnptDEL : Delimiter : A delimiter has no meaning other than being literally printed in this name representation. A delimiter has no implicit leading and trailing white space
      ///</summary>
      public HL7Connect.Cda.ENXP AddPart(string sValue, Tv3EntityNamePartType type_)
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().AddPart(sValue, type_));
      }

      ///<summary>
      /// Shortcut method. Add an part and mark it up as a prefix
      ///</summary>
      public HL7Connect.Cda.ENXP AddPlain(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().AddPlain(sValue));
      }

      ///<summary>
      /// Shortcut method. Add an part and mark it up as a given name
      ///</summary>
      public HL7Connect.Cda.ENXP AddGiven(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().AddGiven(sValue));
      }

      ///<summary>
      /// Shortcut method. Add an part and mark it up as a family name
      ///</summary>
      public HL7Connect.Cda.ENXP AddFamily(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().AddFamily(sValue));
      }

      ///<summary>
      /// Shortcut method. Add an part and mark it up as a prefix
      ///</summary>
      public HL7Connect.Cda.ENXP AddPrefix(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().AddPrefix(sValue));
      }

      ///<summary>
      /// Shortcut method. Add an part and mark it up as a prefix
      ///</summary>
      public HL7Connect.Cda.ENXP AddSuffix(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().AddSuffix(sValue));
      }

      ///<summary>
      /// The name with a standard name ordering imposed
      ///</summary>
      public HL7Connect.Cda.EN canonical()
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().canonical());
      }

      ///<summary>
      /// A sequence of name parts, such as given name or family name, prefix, suffix, etc
      ///</summary>
      private HL7Connect.Cda.ListENXP propGetPart()
      {
        return HL7Connect.Cda.WrapperFactory.ListENXP(wrapped().part);
      }
      private void propSetPart(HL7Connect.Cda.ListENXP value)
      {
        wrapped().part = value.wrapped();
      }
      ///<summary>
      /// A sequence of name parts, such as given name or family name, prefix, suffix, etc
      ///</summary>
      public HL7Connect.Cda.ListENXP part { get { return propGetPart(); } set { propSetPart(value); } }

      ///<summary>
      /// A set of codes advising a system or user which name in a set of names to select for a given purpose. 
      /// 
      ///  A name without specific use code might be a default name useful for any purpose, but a name with a specific use code would be preferred for that respective purpose. Names SHOULD not be collected without at least one use code, but names MAY exist without  use code, particularly for legacy data.  If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNameUse2 code syste
      ///</summary>
      private ISet<Tv3EntityNameUse> propGetUse()
      {
        int i = wrapped().use;
        HashSet<Tv3EntityNameUse> result = new HashSet<Tv3EntityNameUse>();
        foreach (Tv3EntityNameUse a in Enum.GetValues(typeof(Tv3EntityNameUse)))
        {
          if ((((int)a) & i) > 0)
            result.Add(a);
        }
        return result;
      }

      private void propSetUse(ISet<Tv3EntityNameUse> value)
      {
        int i = 0;
        foreach (Tv3EntityNameUse a in Enum.GetValues(typeof(Tv3EntityNameUse)))
        {
          if (value.Contains(a))
            i = i | (int) a;
        }
        wrapped().use = i;
      }

      ///<summary>
      /// A set of codes advising a system or user which name in a set of names to select for a given purpose. 
      /// 
      ///  A name without specific use code might be a default name useful for any purpose, but a name with a specific use code would be preferred for that respective purpose. Names SHOULD not be collected without at least one use code, but names MAY exist without  use code, particularly for legacy data.  If populated, the values contained in this attribute SHALL be taken from the HL7 EntityNameUse2 code syste
      ///</summary>
      public ISet<Tv3EntityNameUse> use { get { return propGetUse(); } set { propSetUse(value); } }

    }

    ///<summary>
    /// The quantity datatype is an abstract generalization for all datatypes whose domain values has an order relation (less-or-equal) and where difference is defined in all of the datatype's totally ordered value subsets. 
    /// 
    ///   The quantity type abstraction is needed in defining certain other types, such as the interval, and probability distributions
    ///</summary>
    public class QTY : HL7Connect.Cda.ANY
    {

      internal QTY(Iv3QTY com) : base(com) {} 

      internal new HCv3QTY wrapped() { return (HCv3QTY) com; }

      ///<summary>
      /// An expression that can be used to derive the actual value of the quantity given information taken from the context of use.
      /// 
      ///   For example expression can be used for expressing dosage instructions that depend on patient body weight.   If no proper value is provided for the QTY, then the value SHALL have a nullFlavor, whether or not an expression is provided. If no proper value is provided, and an expression is provided, the appropriate nullFlavor is usually DER. No nullFlavor is required if both a proper value and an expression is provided; in such cases, it is up to the processing to determine when the expression should be evaluated.  The language of the expression is inferred from the mediatype. If multiple translations are provided in the expression, the evaluator is free to choose whichever language is preferred; all translations SHALL specify the same outcome.  The language defines the forms that the expression property can take, how the information available in the context of the expression is made available within the features of the language, and how the language declares the new form of the value. Languages may only be used if this information has been appropriately defined for the context in which the QTY is used.  Information Processing Entities are not required to implement any languages in order to claim direct or indirect conformance to this specification, but SHOULD declare what languages are supported in their conformance statements.  Language Mediatype OCL text/plain+ocl Factor application/hl7-factor+xml MathML application/mathml+xml  Note: Factor is an HL7 specific language documented in the Abstract Data Types Specification
      ///</summary>
      private HL7Connect.Cda.ED propGetExpression()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().expression);
      }
      private void propSetExpression(HL7Connect.Cda.ED value)
      {
        wrapped().expression = value.wrapped();
      }
      ///<summary>
      /// An expression that can be used to derive the actual value of the quantity given information taken from the context of use.
      /// 
      ///   For example expression can be used for expressing dosage instructions that depend on patient body weight.   If no proper value is provided for the QTY, then the value SHALL have a nullFlavor, whether or not an expression is provided. If no proper value is provided, and an expression is provided, the appropriate nullFlavor is usually DER. No nullFlavor is required if both a proper value and an expression is provided; in such cases, it is up to the processing to determine when the expression should be evaluated.  The language of the expression is inferred from the mediatype. If multiple translations are provided in the expression, the evaluator is free to choose whichever language is preferred; all translations SHALL specify the same outcome.  The language defines the forms that the expression property can take, how the information available in the context of the expression is made available within the features of the language, and how the language declares the new form of the value. Languages may only be used if this information has been appropriately defined for the context in which the QTY is used.  Information Processing Entities are not required to implement any languages in order to claim direct or indirect conformance to this specification, but SHOULD declare what languages are supported in their conformance statements.  Language Mediatype OCL text/plain+ocl Factor application/hl7-factor+xml MathML application/mathml+xml  Note: Factor is an HL7 specific language documented in the Abstract Data Types Specification
      ///</summary>
      public HL7Connect.Cda.ED expression { get { return propGetExpression(); } set { propSetExpression(value); } }

      ///<summary>
      /// The text representation from which the QTY was encoded, if such a representation is the source of the QTY. 
      /// 
      ///   Original text can be used in a structured user interface to capture what the user saw as a representation of the quantity on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user.   It is valid to use a QTY derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. In a situation where the value is determined sometime after the text was entered, originalText is the text or phrase used as the basis for determining the value. The originalText is not a substitute for a valid value. If the actual value of the QTY is not valid, then the QTY SHALL be nullFlavored, irrespective of whether originalText has a value or not.  The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.  Note: the details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification
      ///</summary>
      private HL7Connect.Cda.ED propGetOriginalText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().originalText);
      }
      private void propSetOriginalText(HL7Connect.Cda.ED value)
      {
        wrapped().originalText = value.wrapped();
      }
      ///<summary>
      /// The text representation from which the QTY was encoded, if such a representation is the source of the QTY. 
      /// 
      ///   Original text can be used in a structured user interface to capture what the user saw as a representation of the quantity on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user.   It is valid to use a QTY derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. In a situation where the value is determined sometime after the text was entered, originalText is the text or phrase used as the basis for determining the value. The originalText is not a substitute for a valid value. If the actual value of the QTY is not valid, then the QTY SHALL be nullFlavored, irrespective of whether originalText has a value or not.  The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.  Note: the details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification
      ///</summary>
      public HL7Connect.Cda.ED originalText { get { return propGetOriginalText(); } set { propSetOriginalText(value); } }

      ///<summary>
      /// The uncertainty of the quantity using a distribution function and its parameters. It is the primary measure of variance/uncertainty of the value (the square root of the sum of the squares of the differences between all data points and the mean). The actual type of uncertainty depends on the type of the QTY and is fixed for each type.
      /// 
      ///   Uncertainty SHALL only be applied to value domains that have a continuous distribution (REAL, PQ, MO, and TS). Uncertainty MAY be applied to the numerator and denominator of a RTO separately.  Uncertainty SHALL not have an expression. Uncertainty SHALL not have uncertainty of its own. Uncertainty SHALL not have originalText - any uncertainty associated with the QTY should be conveyed as part of the originalText of the QTY itself.  Note: uncertainty does not have it's own originalText because it is expected that the uncertainty of the quantity should be expressed in the originalText of the quantity itself
      ///</summary>
      private HL7Connect.Cda.QTY propGetUncertainty()
      {
        return HL7Connect.Cda.WrapperFactory.QTY(wrapped().uncertainty);
      }
      private void propSetUncertainty(HL7Connect.Cda.QTY value)
      {
        wrapped().uncertainty = value.wrapped();
      }
      ///<summary>
      /// The uncertainty of the quantity using a distribution function and its parameters. It is the primary measure of variance/uncertainty of the value (the square root of the sum of the squares of the differences between all data points and the mean). The actual type of uncertainty depends on the type of the QTY and is fixed for each type.
      /// 
      ///   Uncertainty SHALL only be applied to value domains that have a continuous distribution (REAL, PQ, MO, and TS). Uncertainty MAY be applied to the numerator and denominator of a RTO separately.  Uncertainty SHALL not have an expression. Uncertainty SHALL not have uncertainty of its own. Uncertainty SHALL not have originalText - any uncertainty associated with the QTY should be conveyed as part of the originalText of the QTY itself.  Note: uncertainty does not have it's own originalText because it is expected that the uncertainty of the quantity should be expressed in the originalText of the quantity itself
      ///</summary>
      public HL7Connect.Cda.QTY uncertainty { get { return propGetUncertainty(); } set { propSetUncertainty(value); } }

      ///<summary>
      /// A code specifying the type of probability distribution in uncertainty. 
      /// 
      ///   The null value (unknown) for the type code indicates that the probability distribution type is unknown. In that case, uncertainty has the meaning of an informal guess if it is populated. If populated, the value of this attribute SHALL be taken from the HL7 DistributionType code system. -- List of possible uncertainty distribution algorithms utNullutU : Uniform : The uniform distribution assigns a constant probability over the entire interval of possible outcomes, while all outcomes outside this interval are assumed to have zero probability. The width of this interval is 2 s v3. Thus, the uniform distribution assigns the probability densities f(x) = (2 s v3)-1 to values ï¿½ - s v3 = x = ï¿½ + s v3 and f(x) = 0 otherwiseutN : Normal (Gaussian) : This is the well-known bell-shaped normal distribution. Because of the central limit theorem, the normal distribution is the distribution of choice for an unbounded random variable that is an outcome of a combination of many stochastic processes. Even for values bounded on a single side (i.e. greater than 0) the normal distribution may be accurate enough if the mean is "far away" from the bound of the scale measured in terms of standard deviationsutLN : Log-Normal : The logarithmic normal distribution is used to transform skewed random variable X into a normally distributed random variable U = log X. The log-normal distribution can be specified with the properties mean ï¿½ and standard deviation s. Note however that mean ï¿½ and standard deviation s are the parameters of the raw value distribution, not the transformed parameters of the lognormal distribution that are conventionally referred to by the same letters. Those log-normal parameters ï¿½ log and slog relate to the mean ï¿½ and standard deviation s of the data value through slog2 = log (s2/ï¿½2 + 1) and ï¿½log = log ï¿½ - slog2/2utG : ? (gamma) : The gamma-distribution used for data that is skewed and bounded to the right, i.e. where the maximum of the distribution curve is located near the origin. The ?-distribution has two parameters a and ï¿½. The relationship to mean ï¿½ and variance s2 is ï¿½ = a ï¿½ and s2 = a ï¿½2utE : Exponential : Used for data that describes extinction. The exponential distribution is a special form of ?-distribution where a = 1, hence, the relationship to mean ï¿½ and variance s2 are ï¿½ = ï¿½ and s2 = ï¿½2utX2 : ? : Used to describe the sum of squares of random variables that occurs when a variance is estimated (rather than presumed) from the sample. The only parameter of the ?2-distribution is ?, so called the number of degrees of freedom (which is the number of independent parts in the sum). The ?2-distribution is a special type of ?-distribution with parameter a = ? /2 and ï¿½ = 2. Hence, ï¿½ = ? and s2 = 2 ?utT : t (student) : Used to describe the quotient of a normal random variable and the square root of a ?2 random variable. The t-distribution has one parameter ?, the number of degrees of freedom. The relationship to mean ï¿½ and variance s2 are: ï¿½ = 0 and s2 = ? / (? - 2)utF : F : Used to describe the quotient of two ?2 random variables. The F-distribution has two parameters ?1 and ?2, which are the numbers of degrees of freedom of the numerator and denominator variable respectively. The relationship to mean ï¿½ and variance s2 are: ï¿½ = ?2 / (?2 - 2) and s 2 = (2 ?22 (? 2 + ?1 - 2)) / (?1 (?2 - 2)2 (?2 - 4))utB : ?(beta) : The beta-distribution is used for data that is bounded on both sides and may or may not be skewed (e.g., occurs when probabilities are estimated.) Two parameters a and ï¿½ are available to adjust the curve. The mean ï¿½ and variance s2 relate as follows: ï¿½ = a / (a + ï¿½) and (s2 = a ï¿½/((a + ï¿½)2 (a + ï¿½ + 1))
      ///</summary>
      private Tv3UncertaintyType propGetUncertaintyType()
      {
        return wrapped().uncertaintyType;
      }
      private void propSetUncertaintyType(Tv3UncertaintyType value)
      {
        wrapped().uncertaintyType = value;
      }
      ///<summary>
      /// A code specifying the type of probability distribution in uncertainty. 
      /// 
      ///   The null value (unknown) for the type code indicates that the probability distribution type is unknown. In that case, uncertainty has the meaning of an informal guess if it is populated. If populated, the value of this attribute SHALL be taken from the HL7 DistributionType code system. -- List of possible uncertainty distribution algorithms utNullutU : Uniform : The uniform distribution assigns a constant probability over the entire interval of possible outcomes, while all outcomes outside this interval are assumed to have zero probability. The width of this interval is 2 s v3. Thus, the uniform distribution assigns the probability densities f(x) = (2 s v3)-1 to values ï¿½ - s v3 = x = ï¿½ + s v3 and f(x) = 0 otherwiseutN : Normal (Gaussian) : This is the well-known bell-shaped normal distribution. Because of the central limit theorem, the normal distribution is the distribution of choice for an unbounded random variable that is an outcome of a combination of many stochastic processes. Even for values bounded on a single side (i.e. greater than 0) the normal distribution may be accurate enough if the mean is "far away" from the bound of the scale measured in terms of standard deviationsutLN : Log-Normal : The logarithmic normal distribution is used to transform skewed random variable X into a normally distributed random variable U = log X. The log-normal distribution can be specified with the properties mean ï¿½ and standard deviation s. Note however that mean ï¿½ and standard deviation s are the parameters of the raw value distribution, not the transformed parameters of the lognormal distribution that are conventionally referred to by the same letters. Those log-normal parameters ï¿½ log and slog relate to the mean ï¿½ and standard deviation s of the data value through slog2 = log (s2/ï¿½2 + 1) and ï¿½log = log ï¿½ - slog2/2utG : ? (gamma) : The gamma-distribution used for data that is skewed and bounded to the right, i.e. where the maximum of the distribution curve is located near the origin. The ?-distribution has two parameters a and ï¿½. The relationship to mean ï¿½ and variance s2 is ï¿½ = a ï¿½ and s2 = a ï¿½2utE : Exponential : Used for data that describes extinction. The exponential distribution is a special form of ?-distribution where a = 1, hence, the relationship to mean ï¿½ and variance s2 are ï¿½ = ï¿½ and s2 = ï¿½2utX2 : ? : Used to describe the sum of squares of random variables that occurs when a variance is estimated (rather than presumed) from the sample. The only parameter of the ?2-distribution is ?, so called the number of degrees of freedom (which is the number of independent parts in the sum). The ?2-distribution is a special type of ?-distribution with parameter a = ? /2 and ï¿½ = 2. Hence, ï¿½ = ? and s2 = 2 ?utT : t (student) : Used to describe the quotient of a normal random variable and the square root of a ?2 random variable. The t-distribution has one parameter ?, the number of degrees of freedom. The relationship to mean ï¿½ and variance s2 are: ï¿½ = 0 and s2 = ? / (? - 2)utF : F : Used to describe the quotient of two ?2 random variables. The F-distribution has two parameters ?1 and ?2, which are the numbers of degrees of freedom of the numerator and denominator variable respectively. The relationship to mean ï¿½ and variance s2 are: ï¿½ = ?2 / (?2 - 2) and s 2 = (2 ?22 (? 2 + ?1 - 2)) / (?1 (?2 - 2)2 (?2 - 4))utB : ?(beta) : The beta-distribution is used for data that is bounded on both sides and may or may not be skewed (e.g., occurs when probabilities are estimated.) Two parameters a and ï¿½ are available to adjust the curve. The mean ï¿½ and variance s2 relate as follows: ï¿½ = a / (a + ï¿½) and (s2 = a ï¿½/((a + ï¿½)2 (a + ï¿½ + 1))
      ///</summary>
      public Tv3UncertaintyType uncertaintyType { get { return propGetUncertaintyType(); } set { propSetUncertaintyType(value); } }

      ///<summary>
      /// Indicates that the value comes from a range of possible values. 
      /// 
      ///   uncertainRange is used where the actual value is unknown, but it is known that the value comes from a known range of possible values. uncertainRange differs from uncertainty in that uncertainty is used to report a particular value along with an associated distribution of uncertainty for the value, or to report the summary distribution of a set of data, whereas uncertainRange indicates that there is a single value that, although unknown, comes from a particular range of values. No inference regarding distribution of values can be taken. uncertainRange is often associated with an instruction to perform a particular operation at some point within a given time interval
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.QTY> propGetUncertainRange()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.QTY>(wrapped().uncertainRange);
      }
      private void propSetUncertainRange(HL7Connect.Cda.IVL<HL7Connect.Cda.QTY> value)
      {
        wrapped().uncertainRange = value.wrapped();
      }
      ///<summary>
      /// Indicates that the value comes from a range of possible values. 
      /// 
      ///   uncertainRange is used where the actual value is unknown, but it is known that the value comes from a known range of possible values. uncertainRange differs from uncertainty in that uncertainty is used to report a particular value along with an associated distribution of uncertainty for the value, or to report the summary distribution of a set of data, whereas uncertainRange indicates that there is a single value that, although unknown, comes from a particular range of values. No inference regarding distribution of values can be taken. uncertainRange is often associated with an instruction to perform a particular operation at some point within a given time interval
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.QTY> uncertainRange { get { return propGetUncertainRange(); } set { propSetUncertainRange(value); } }

    }

    ///<summary>
    /// Integer numbers (-1,0,1,2, 100, 3398129, etc.) are precise numbers that are results of counting and enumerating. Integer numbers are discrete, the set of integers is infinite but countable. No arbitrary limit is imposed on the range of integer numbers.
    ///</summary>
    public class INT : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 INT
      ///</summary>
      public INT() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newINT()) {} 

      ///<summary>
      /// Create a v3 INT
      ///</summary>
      public INT(int iValue) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newINTvalue(iValue)) {} 

      internal INT(Iv3INT com) : base(com) {} 

      internal new HCv3INT wrapped() { return (HCv3INT) com; }

      ///<summary>
      /// false if value is null, true if value is either true or false
      ///</summary>
      private bool propGetHasValue()
      {
        return wrapped().HasValue != 0;
      }
      ///<summary>
      /// false if value is null, true if value is either true or false
      ///</summary>
      public bool HasValue { get { return propGetHasValue(); } }

      ///<summary>
      /// The value of the INT. Note that this specification imposes no limitations on the size of integer, but most implementations will map this to a 32 or 64 bit integer.
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more detail
      ///</summary>
      private long propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(long value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// The value of the INT. Note that this specification imposes no limitations on the size of integer, but most implementations will map this to a 32 or 64 bit integer.
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more detail
      ///</summary>
      public long value { get { return propGetValue(); } set { propSetValue(value); } }

    }

    ///<summary>
    /// Represents data where coded values are associated with a specific order. 
    /// 
    ///  Note:  CO may be used for things that model rankings and scores, e.g. likert scales, pain, Apgar values, etc, where there is a) implied ordering, b) no implication that the distance between each value is constant, and c) the total number of values is finite. CO may also be used in the context of an ordered code system. In this case, it may not be appropriate or even possible to use the value attribute, but CO may still be used so that models that make use of such code systems may introduce model elements that involve statements about the order of the terms in a domain. The relative order of values in a code system need not be independently obvious in the literal representation of the CO. It these circumstances, is expected that an application will look up the ordering of these values from some definition of the code system.  Some of the code systems will directly assign numerical value to the concepts that are suitable for some mathemetical operations. Though it would generally make sense, applications SHOULD not assume that the translations of the code, if provided, will have the same ordering as the CO. Translations SHALL not be considered when the ordering of the code system is determined
    ///</summary>
    public class CO : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 CO
      ///</summary>
      public CO() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCO()) {} 

      internal CO(Iv3CO com) : base(com) {} 

      internal new HCv3CO wrapped() { return (HCv3CO) com; }

      ///<summary>
      /// A numerical value associated with the coded ordinal value.
      /// 
      ///  The value may be constrained to an integer in some contexts of use. If code is nonNull, value SHALL only be nonNull if the code system explicitly assigns a value to the concept
      ///</summary>
      private HL7Connect.Ucum.QDecimal propGetValue()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Ucum.QDecimal value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// A numerical value associated with the coded ordinal value.
      /// 
      ///  The value may be constrained to an integer in some contexts of use. If code is nonNull, value SHALL only be nonNull if the code system explicitly assigns a value to the concept
      ///</summary>
      public HL7Connect.Ucum.QDecimal value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// A code representing the definition of the ordinal ite
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// A code representing the definition of the ordinal ite
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

    }

    ///<summary>
    /// Fractional numbers. Typically used whenever quantities are measured, estimated, or computed from other real numbers. The typical representation is decimal, where the number of significant decimal digits is known as the precision.
    ///</summary>
    public class REAL : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 REAL
      ///</summary>
      public REAL() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newREAL()) {} 

      internal REAL(Iv3REAL com) : base(com) {} 

      internal new HCv3REAL wrapped() { return (HCv3REAL) com; }

      ///<summary>
      /// The value of the REAL. 
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more details
      ///</summary>
      private HL7Connect.Ucum.QDecimal propGetValue()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Ucum.QDecimal value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// The value of the REAL. 
      /// 
      ///   This is an example of the primitive type wrapping pattern. See section 6.3 for more details
      ///</summary>
      public HL7Connect.Ucum.QDecimal value { get { return propGetValue(); } set { propSetValue(value); } }

    }

    ///<summary>
    /// A quantity constructed as the quotient of a numerator quantity divided by a denominator quantity. 
    /// 
    ///  Common factors in the numerator and denominator are not automatically cancelled out.  The RTO datatype supports titers (e.g., "1:128") and other quantities produced by laboratories that truly represent ratios. Ratios are not simply "structured numerics", particularly blood pressure measurements (e.g. "120/60") are not ratios. Notes:  1. Ratios are different from rational numbers, i.e., in ratios common factors in the numerator and denominator never cancel out. A ratio of two real or integer numbers is not automatically reduced to a real number. This datatype is not defined to generally represent rational numbers. It is used only if common factors in numerator and denominator are not supposed to cancel out. This is only rarely the case. For observation values, ratios occur almost exclusively with titers. In most other cases, REAL should be used instead of the RTO. 2. Since many implementation technologies expect generics to be collections, or only have one parameter, RTO is not implemented as a generic in this specification. Constraints at the point where the RTO is used will define which form of QTY are used
    ///</summary>
    public class RTO : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 RTO
      ///</summary>
      public RTO() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRTO()) {} 

      internal RTO(Iv3RTO com) : base(com) {} 

      internal new HCv3RTO wrapped() { return (HCv3RTO) com; }

      ///<summary>
      /// The quantity that is being divided in the rati
      ///</summary>
      private HL7Connect.Cda.QTY propGetNumerator()
      {
        return HL7Connect.Cda.WrapperFactory.QTY(wrapped().numerator);
      }
      private void propSetNumerator(HL7Connect.Cda.QTY value)
      {
        wrapped().numerator = value.wrapped();
      }
      ///<summary>
      /// The quantity that is being divided in the rati
      ///</summary>
      public HL7Connect.Cda.QTY numerator { get { return propGetNumerator(); } set { propSetNumerator(value); } }

      ///<summary>
      ///</summary>
      private string /*todo: change to class*/ propGetNumeratorType()
      {
        return wrapped().NumeratorType;
      }
      private void propSetNumeratorType(string /*todo: change to class*/ value)
      {
        wrapped().NumeratorType = value;
      }
      ///<summary>
      ///</summary>
      public string /*todo: change to class*/ NumeratorType { get { return propGetNumeratorType(); } set { propSetNumeratorType(value); } }

      ///<summary>
      /// The quantity that divides the numerator in the ratio. 
      /// 
      ///  The denominator SHALL not be zero.
      ///</summary>
      private HL7Connect.Cda.QTY propGetDenominator()
      {
        return HL7Connect.Cda.WrapperFactory.QTY(wrapped().denominator);
      }
      private void propSetDenominator(HL7Connect.Cda.QTY value)
      {
        wrapped().denominator = value.wrapped();
      }
      ///<summary>
      /// The quantity that divides the numerator in the ratio. 
      /// 
      ///  The denominator SHALL not be zero.
      ///</summary>
      public HL7Connect.Cda.QTY denominator { get { return propGetDenominator(); } set { propSetDenominator(value); } }

      ///<summary>
      ///</summary>
      private string /*todo: change to class*/ propGetDenominatorType()
      {
        return wrapped().DenominatorType;
      }
      private void propSetDenominatorType(string /*todo: change to class*/ value)
      {
        wrapped().DenominatorType = value;
      }
      ///<summary>
      ///</summary>
      public string /*todo: change to class*/ DenominatorType { get { return propGetDenominatorType(); } set { propSetDenominatorType(value); } }

    }

    ///<summary>
    /// A dimensioned quantity expressing the result of measuring
    ///</summary>
    public class PQ : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 PQ
      ///</summary>
      public PQ() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPQ()) {} 

      ///<summary>
      /// Create a v3 PQ
      ///</summary>
      public PQ(HL7Connect.Ucum.QDecimal rValue, string sUnit) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPQValue(rValue.wrapped(), sUnit)) {} 

      internal PQ(Iv3PQ com) : base(com) {} 

      internal new HCv3PQ wrapped() { return (HCv3PQ) com; }

      ///<summary>
      /// The canonical form for the PQ (canonical UCUM units with appropriate conversion)
      ///</summary>
      public HL7Connect.Cda.PQ canonical()
      {
        return HL7Connect.Cda.WrapperFactory.PQ(wrapped().canonical());
      }

      ///<summary>
      /// whether other is a PQ and has the same canonical units
      ///</summary>
      public HL7Connect.Cda.BL comparable(HL7Connect.Cda.QTY other)
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().comparable(other.wrapped()));
      }

      ///<summary>
      /// the number which is multiplied by the unit to make the PQ or PQR value if not nullFlavore
      ///</summary>
      private HL7Connect.Ucum.QDecimal propGetValue()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Ucum.QDecimal value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// the number which is multiplied by the unit to make the PQ or PQR value if not nullFlavore
      ///</summary>
      public HL7Connect.Ucum.QDecimal value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// The reason that this PQ or PQR was provided. More than one reason may be given. For possible values, see 7.5.1.4.10 CD.codingRationale. -- Coding Rationale for why a code is provided (CD and PQ/PQR) 
      /// 
      /// crNullcrO : Original : Originally produced code crP : Post-coded : post-coded from free text source crR : Required : Required by the specification describing the use of the coded concept.The exact form of the requirement is not specified here; it may be required by the specification directly, or it may arise as an indirect result of other conformance tools. More than one different requirement may exist simultaineously, so more than one code in a CD complex may be requiredcrOR : Original &amp; Required :Originally produced code, required by the specification describing the use of the coded concept.crPR : Post-coded &amp; Requierd : post-coded from free text source, required by the specification describing the use of the coded concept
      ///</summary>
      private Tv3CodingRationale propGetCodingRationale()
      {
        return wrapped().codingRationale;
      }
      private void propSetCodingRationale(Tv3CodingRationale value)
      {
        wrapped().codingRationale = value;
      }
      ///<summary>
      /// The reason that this PQ or PQR was provided. More than one reason may be given. For possible values, see 7.5.1.4.10 CD.codingRationale. -- Coding Rationale for why a code is provided (CD and PQ/PQR) 
      /// 
      /// crNullcrO : Original : Originally produced code crP : Post-coded : post-coded from free text source crR : Required : Required by the specification describing the use of the coded concept.The exact form of the requirement is not specified here; it may be required by the specification directly, or it may arise as an indirect result of other conformance tools. More than one different requirement may exist simultaineously, so more than one code in a CD complex may be requiredcrOR : Original &amp; Required :Originally produced code, required by the specification describing the use of the coded concept.crPR : Post-coded &amp; Requierd : post-coded from free text source, required by the specification describing the use of the coded concept
      ///</summary>
      public Tv3CodingRationale codingRationale { get { return propGetCodingRationale(); } set { propSetCodingRationale(value); } }

      ///<summary>
      /// The unit of measure specified in the Unified Code for Units of Measure (UCUM). 
      /// 
      ///   UCUM defines two forms of expression, case sensitive and case insensitive. PQ uses the case sensitive codes. The codeSystem OID for the case sensitive form is 2.16.840.1.113883.6.8. The default value for unit is the UCUM code "1" (unity).  Equality of physical quantities does not require the values and units to be equal independently. Value and unit is only how we represent physical quantities. For example, 1 m equals 100 cm. Although the units are different and the values are different, the physical quantities are equal. Therefore one should never expect a particular unit for a physical quantity but instead allow for automated conversion between different comparable units.   The unit SHALL come from UCUM, which only specifies unambiguous measurement units. Sometimes it is not clear how some measurements in healthcare map to UCUM codes.  Note: The general pattern for a measurement is  value *unit*  of *Thing*. In this scheme, the PQ represents the  value and the *unit*, and the *Thing* is described by some coded concept that is linked to the PQ by the context of use. This maps obviously to some measurements, such as *Patient Body Temperature* of 37 *Celsius*, and 250 *mg/day* of *Salicylate*.  However for some measurements that arise in healthcare, the scheme is not so obvious. Two classic examples are 5 Drinks of Beer, and 3 Acetominophen tablets. At first glance it is tempting to classify these measurments like this: 5 *drinks* of *Beer* and 3 *Acetominophen* *tablets*. The problem with this is that UCUM does not support units of "beer", "tablets" or "scoops".  The reason for this is that neither tablets or scoops are proper units. What kind of tablets? How big is the glass? In these kinds of cases, the concept that appears to be a unit needs to further specified before interoperability is established. If a correct amount is required, then it is generally appropriate to specify an exact measurement with an appropriate UCUM unit. If this is not possible, then the concept is not part of the measurement. UCUM provides a unit called unity for use in these cases. The proper way to understand these measurements as 3 *1* *Acetominophen* tablets, where 1 is the UCUM unit for unity, and the *Thing* has a qualifier. The context of use will need to provide the extra qualifying information
      ///</summary>
      private string propGetUnit()
      {
        return wrapped().unit_;
      }
      private void propSetUnit(string value)
      {
        wrapped().unit_ = value;
      }
      ///<summary>
      /// The unit of measure specified in the Unified Code for Units of Measure (UCUM). 
      /// 
      ///   UCUM defines two forms of expression, case sensitive and case insensitive. PQ uses the case sensitive codes. The codeSystem OID for the case sensitive form is 2.16.840.1.113883.6.8. The default value for unit is the UCUM code "1" (unity).  Equality of physical quantities does not require the values and units to be equal independently. Value and unit is only how we represent physical quantities. For example, 1 m equals 100 cm. Although the units are different and the values are different, the physical quantities are equal. Therefore one should never expect a particular unit for a physical quantity but instead allow for automated conversion between different comparable units.   The unit SHALL come from UCUM, which only specifies unambiguous measurement units. Sometimes it is not clear how some measurements in healthcare map to UCUM codes.  Note: The general pattern for a measurement is  value *unit*  of *Thing*. In this scheme, the PQ represents the  value and the *unit*, and the *Thing* is described by some coded concept that is linked to the PQ by the context of use. This maps obviously to some measurements, such as *Patient Body Temperature* of 37 *Celsius*, and 250 *mg/day* of *Salicylate*.  However for some measurements that arise in healthcare, the scheme is not so obvious. Two classic examples are 5 Drinks of Beer, and 3 Acetominophen tablets. At first glance it is tempting to classify these measurments like this: 5 *drinks* of *Beer* and 3 *Acetominophen* *tablets*. The problem with this is that UCUM does not support units of "beer", "tablets" or "scoops".  The reason for this is that neither tablets or scoops are proper units. What kind of tablets? How big is the glass? In these kinds of cases, the concept that appears to be a unit needs to further specified before interoperability is established. If a correct amount is required, then it is generally appropriate to specify an exact measurement with an appropriate UCUM unit. If this is not possible, then the concept is not part of the measurement. UCUM provides a unit called unity for use in these cases. The proper way to understand these measurements as 3 *1* *Acetominophen* tablets, where 1 is the UCUM unit for unity, and the *Thing* has a qualifier. The context of use will need to provide the extra qualifying information
      ///</summary>
      public string unit { get { return propGetUnit(); } set { propSetUnit(value); } }

      ///<summary>
      /// An alternative representation of the same physical quantity expressed in a different unit from a different unit code system and possibly with a different value.
      /// 
      ///   It is not necessary for information processing entities to check and enforce that the translations are valid translations of the base unit, but they are allowed to do so, and to reject instances where the translations are not valid.  Note Translations are allowed to contain other representations in UCUM units, but there is generally no point to this as it's possible to convert from UCUM form to another
      ///</summary>
      private HL7Connect.Cda.SetPQR propGetTranslation()
      {
        return HL7Connect.Cda.WrapperFactory.SetPQR(wrapped().translation);
      }
      private void propSetTranslation(HL7Connect.Cda.SetPQR value)
      {
        wrapped().translation = value.wrapped();
      }
      ///<summary>
      /// An alternative representation of the same physical quantity expressed in a different unit from a different unit code system and possibly with a different value.
      /// 
      ///   It is not necessary for information processing entities to check and enforce that the translations are valid translations of the base unit, but they are allowed to do so, and to reject instances where the translations are not valid.  Note Translations are allowed to contain other representations in UCUM units, but there is generally no point to this as it's possible to convert from UCUM form to another
      ///</summary>
      public HL7Connect.Cda.SetPQR translation { get { return propGetTranslation(); } set { propSetTranslation(value); } }

    }

    ///<summary>
    /// Specializes CD.CV
    /// 
    ///  An extension of the coded value datatype representing a physical quantity using a unit from any code system. Used to show alternative representation for a physical quantity. The coded value represents the unit (usually in some other coding system than UCUM)
    ///</summary>
    public class PQR : HL7Connect.Cda.CD
    {

      ///<summary>
      /// Create a v3 PQR
      ///</summary>
      public PQR() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPQR()) {} 

      internal PQR(Iv3PQR com) : base(com) {} 

      internal new HCv3PQR wrapped() { return (HCv3PQR) com; }

      ///<summary>
      /// The magnitude of the measurement value in terms of the unit specified by this code
      ///</summary>
      private HL7Connect.Ucum.QDecimal propGetValue()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Ucum.QDecimal value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// The magnitude of the measurement value in terms of the unit specified by this code
      ///</summary>
      public HL7Connect.Ucum.QDecimal value { get { return propGetValue(); } set { propSetValue(value); } }

    }

    ///<summary>
    /// A MO is a quantity expressing the amount of money in some currency. 
    /// 
    ///  Currencies are the units in which monetary amounts are denominated in different economic regions. While the monetary amount is a single kind of quantity (money) the exchange rates between the different units are variable. This is the principle difference between PQ and MO, and the reason why currency units are not physical units
    ///</summary>
    public class MO : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 MO
      ///</summary>
      public MO() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newMO()) {} 

      ///<summary>
      /// Create a v3 MO
      ///</summary>
      public MO(HL7Connect.Ucum.QDecimal rValue, string sCurrency) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newMOValue(rValue.wrapped(), sCurrency)) {} 

      internal MO(Iv3MO com) : base(com) {} 

      internal new HCv3MO wrapped() { return (HCv3MO) com; }

      ///<summary>
      /// The value of the MO if non Null. MO values are usually precise to 0.01 (one cent, penny, paisa, etc.), or 1 (yen, forint, etc
      ///</summary>
      private HL7Connect.Ucum.QDecimal propGetValue()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Ucum.QDecimal value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// The value of the MO if non Null. MO values are usually precise to 0.01 (one cent, penny, paisa, etc.), or 1 (yen, forint, etc
      ///</summary>
      public HL7Connect.Ucum.QDecimal value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// The currency unit as defined in ISO 421
      ///</summary>
      private string propGetCurrency()
      {
        return wrapped().currency;
      }
      private void propSetCurrency(string value)
      {
        wrapped().currency = value;
      }
      ///<summary>
      /// The currency unit as defined in ISO 421
      ///</summary>
      public string currency { get { return propGetCurrency(); } set { propSetCurrency(value); } }

    }

    ///<summary>
    /// A quantity specifying a point on the axis of natural time. A point in time is most often represented as a calendar expression.
    ///</summary>
    public class TS : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 TS
      ///</summary>
      public TS() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTS()) {} 

      ///<summary>
      /// Create a v3 TS
      ///</summary>
      public TS(string sDateTime) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTSValue(sDateTime)) {} 

      internal TS(Iv3TS com) : base(com) {} 

      internal new HCv3TS wrapped() { return (HCv3TS) com; }

      ///<summary>
      /// The value of the TS. value is a string with the format "YYYY[MM[DD[HH[MM[SS[.U[U[U[U]]]]]]]]][+|-ZZzz]" that conforms to the constrained ISO 8601 defined in ISO 8824 (ASN.1) under clause 32 (generalized time). The format should be used to the degree of precision that is appropriat
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(string value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// The value of the TS. value is a string with the format "YYYY[MM[DD[HH[MM[SS[.U[U[U[U]]]]]]]]][+|-ZZzz]" that conforms to the constrained ISO 8601 defined in ISO 8824 (ASN.1) under clause 32 (generalized time). The format should be used to the degree of precision that is appropriat
      ///</summary>
      public string value { get { return propGetValue(); } set { propSetValue(value); } }

    }

    ///<summary>
    /// Abstract; specializes ANY
    /// 
    ///   Parameter: T : QTY  An unordered set of distinct values which are quantities.   Any ordered type can be the basis of an QSET; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the QSET must be elements of a totally ordered subset of the partially ordered datatype (for example, PQ is only ordered when the units are consistent. Every value in a QSET(PQ) must have the same canonical unit).  QSET is an abstract type. A working QSET is specified as an expression tree built using a combination of operator (QSI, QSD, QSU, QSP) and component types (QSC, QSS and IVL; and, for TS, PIVL and EIVL).  QSETs SHALL not contain null or nullFlavored values as members of the set
    ///</summary>
    public class QSET<T> : HL7Connect.Cda.ANY where T : HL7Connect.Cda.QTY
    {

      internal QSET(Iv3QSET com) : base(com) {} 

      internal new HCv3QSET wrapped() { return (HCv3QSET) com; }

      ///<summary>
      /// Whether a GTS is flat (parts of the base QSET part are encoded as a series of repeated "effectiveTime" elements) or whether they are encoded as "comp" elements in a single "effectiveTime". This flag has no meaning inside a GTS, where comp elements are required.
      ///</summary>
      private bool propGetFlat()
      {
        return wrapped().Flat != 0;
      }
      private void propSetFlat(bool value)
      {
        wrapped().Flat = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Whether a GTS is flat (parts of the base QSET part are encoded as a series of repeated "effectiveTime" elements) or whether they are encoded as "comp" elements in a single "effectiveTime". This flag has no meaning inside a GTS, where comp elements are required.
      ///</summary>
      public bool Flat { get { return propGetFlat(); } set { propSetFlat(value); } }

      ///<summary>
      /// The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 
      /// 
      ///   Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user.   It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the QSET is not valid, then the QSET SHALL be nullFlavored, irrespective of whether originalText has a value or not.  The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.  Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification
      ///</summary>
      private HL7Connect.Cda.ED propGetOriginalText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().originalText);
      }
      private void propSetOriginalText(HL7Connect.Cda.ED value)
      {
        wrapped().originalText = value.wrapped();
      }
      ///<summary>
      /// The text representation from which the QSET was encoded, if such a representation is the source of the QSET. 
      /// 
      ///   Original text can be used in a structured user interface to capture what the user saw as a representation of the set on the data input screen, or in a situation where the user dictates or directly enters text, it is the text entered or uttered by the user.   It is valid to use a QSET derived datatype to store only the text that the user entered or uttered. In this situation, original text will exist without a valid value. The originalText is not a substitute for a valid value. If the actual content of the QSET is not valid, then the QSET SHALL be nullFlavored, irrespective of whether originalText has a value or not.  The original text SHALL be an excerpt of the relevant information in the original sources, rather than a pointer or exact reproduction. Thus the original text SHALL be represented in plain text form. In specific circumstances, when clearly descirbed the context of use, the originalText may be a reference to some other text artefact for which the resolution scope is clearly described.  Note: The details of the link in the originalText.reference between different artifacts of medical information (e.g., document and coded result) is outside the scope of this specification and may be further proscribed in specifications that use this specification
      ///</summary>
      public HL7Connect.Cda.ED originalText { get { return propGetOriginalText(); } set { propSetOriginalText(value); } }

      ///<summary>
      ///</summary>
      private string /*todo: change to class*/ propGetParamType()
      {
        return wrapped().ParamType;
      }
      private void propSetParamType(string /*todo: change to class*/ value)
      {
        wrapped().ParamType = value;
      }
      ///<summary>
      ///</summary>
      public string /*todo: change to class*/ ParamType { get { return propGetParamType(); } set { propSetParamType(value); } }

    }

    ///<summary>
    /// Specifies a QSET as a union of other sets
    ///</summary>
    public class QSU<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 QSU
      ///</summary>
      public QSU(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newQSU(sType)) {} 

      internal QSU(Iv3QSU com) : base(com) {} 

      internal new HCv3QSU wrapped() { return (HCv3QSU) com; }

      ///<summary>
      /// a list of other QSETs that are involved in the unio
      ///</summary>
      private HL7Connect.Cda.SetQSET<T> propGetTerms()
      {
        return HL7Connect.Cda.WrapperFactory.SetQSET<T>(wrapped().terms);
      }
      private void propSetTerms(HL7Connect.Cda.SetQSET<T> value)
      {
        wrapped().terms = value.wrapped();
      }
      ///<summary>
      /// a list of other QSETs that are involved in the unio
      ///</summary>
      public HL7Connect.Cda.SetQSET<T> terms { get { return propGetTerms(); } set { propSetTerms(value); } }

    }

    ///<summary>
    /// Specializes QSET
    /// 
    ///   Specifies a QSET as an intersection of other sets
    ///</summary>
    public class QSI<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 QSI
      ///</summary>
      public QSI(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newQSI(sType)) {} 

      internal QSI(Iv3QSI com) : base(com) {} 

      internal new HCv3QSI wrapped() { return (HCv3QSI) com; }

      ///<summary>
      /// A list of other QSETs that are involved in the intersectio
      ///</summary>
      private HL7Connect.Cda.SetQSET<T> propGetTerms()
      {
        return HL7Connect.Cda.WrapperFactory.SetQSET<T>(wrapped().terms);
      }
      private void propSetTerms(HL7Connect.Cda.SetQSET<T> value)
      {
        wrapped().terms = value.wrapped();
      }
      ///<summary>
      /// A list of other QSETs that are involved in the intersectio
      ///</summary>
      public HL7Connect.Cda.SetQSET<T> terms { get { return propGetTerms(); } set { propSetTerms(value); } }

    }

    ///<summary>
    /// Specializes QSET
    /// 
    ///   Specifies a QSET as the difference between two sets
    ///</summary>
    public class QSD<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 QSD
      ///</summary>
      public QSD(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newQSD(sType)) {} 

      internal QSD(Iv3QSD com) : base(com) {} 

      internal new HCv3QSD wrapped() { return (HCv3QSD) com; }

      ///<summary>
      /// The set from which the second set is subtracte
      ///</summary>
      private HL7Connect.Cda.QSET<T> propGetMinuend()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<T>(wrapped().minuend);
      }
      private void propSetMinuend(HL7Connect.Cda.QSET<T> value)
      {
        wrapped().minuend = value.wrapped();
      }
      ///<summary>
      /// The set from which the second set is subtracte
      ///</summary>
      public HL7Connect.Cda.QSET<T> minuend { get { return propGetMinuend(); } set { propSetMinuend(value); } }

      ///<summary>
      /// The set that is subtracted from the first se
      ///</summary>
      private HL7Connect.Cda.QSET<T> propGetSubtrahend()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<T>(wrapped().subtrahend);
      }
      private void propSetSubtrahend(HL7Connect.Cda.QSET<T> value)
      {
        wrapped().subtrahend = value.wrapped();
      }
      ///<summary>
      /// The set that is subtracted from the first se
      ///</summary>
      public HL7Connect.Cda.QSET<T> subtrahend { get { return propGetSubtrahend(); } set { propSetSubtrahend(value); } }

    }

    ///<summary>
    /// Specializes QSET
    /// 
    ///   Specifies a QSET as the periodic hull between two sets.   A periodic hull may be generated by comparing two sets that interleave. For QSET values *A* and *B* to interleave, the occurrence intervals of both groups can be arranged in pairs of corresponding occurrence intervals. It must further hold that for all corresponding occurrence intervals a  &sube; A and b &sube; B, a starts before b starts (or at the same time) and b ends after a ends (or at the same time).  The interleaves-relation holds when two schedules have the same average frequency, and when the second schedule never "outpaces" the first schedule. That is, no occurrence interval in the second schedule may start before its corresponding occurrence interval in the first schedule
    ///</summary>
    public class QSP<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 QSP
      ///</summary>
      public QSP(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newQSP(sType)) {} 

      internal QSP(Iv3QSP com) : base(com) {} 

      internal new HCv3QSP wrapped() { return (HCv3QSP) com; }

      ///<summary>
      /// The set used as the basis for the periodic hull operatio
      ///</summary>
      private HL7Connect.Cda.QSET<T> propGetLow()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<T>(wrapped().low);
      }
      private void propSetLow(HL7Connect.Cda.QSET<T> value)
      {
        wrapped().low = value.wrapped();
      }
      ///<summary>
      /// The set used as the basis for the periodic hull operatio
      ///</summary>
      public HL7Connect.Cda.QSET<T> low { get { return propGetLow(); } set { propSetLow(value); } }

      ///<summary>
      /// The set that is used as the parameter for the periodic hull operation
      ///</summary>
      private HL7Connect.Cda.QSET<T> propGetHigh()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<T>(wrapped().high);
      }
      private void propSetHigh(HL7Connect.Cda.QSET<T> value)
      {
        wrapped().high = value.wrapped();
      }
      ///<summary>
      /// The set that is used as the parameter for the periodic hull operation
      ///</summary>
      public HL7Connect.Cda.QSET<T> high { get { return propGetHigh(); } set { propSetHigh(value); } }

    }

    ///<summary>
    /// Specializes QSET
    /// 
    ///   Specifies a QSET as an enumeration of simple values. This is a shortcut form for specifying the same values as singleton interval
    ///</summary>
    public class QSS<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 QSS
      ///</summary>
      public QSS(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newQSS(sType)) {} 

      internal QSS(Iv3QSS com) : base(com) {} 

      internal new HCv3QSS wrapped() { return (HCv3QSS) com; }

      ///<summary>
      /// a list of values that are in the set. The set is actually constructed as the union of the intervals implied by the precision implicit in the definition of T. For some types of QTY, this is either trivial (INT) or ambiguous (RTO) and QSS doesnï¿½t really make sense for these type. QSS is a useful type for TS in particula
      ///</summary>
      private HL7Connect.Cda.SetQTY propGetTerms()
      {
        return HL7Connect.Cda.WrapperFactory.SetQTY(wrapped().terms);
      }
      private void propSetTerms(HL7Connect.Cda.SetQTY value)
      {
        wrapped().terms = value.wrapped();
      }
      ///<summary>
      /// a list of values that are in the set. The set is actually constructed as the union of the intervals implied by the precision implicit in the definition of T. For some types of QTY, this is either trivial (INT) or ambiguous (RTO) and QSS doesnï¿½t really make sense for these type. QSS is a useful type for TS in particula
      ///</summary>
      public HL7Connect.Cda.SetQTY terms { get { return propGetTerms(); } set { propSetTerms(value); } }

    }

    ///<summary>
    /// Specializes QSET
    /// 
    ///   Specifies a QSET as an coded value that describes a predefined QSET(TS)
    ///</summary>
    public class QSC<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 QSC
      ///</summary>
      public QSC(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newQSC(sType)) {} 

      internal QSC(Iv3QSC com) : base(com) {} 

      internal new HCv3QSC wrapped() { return (HCv3QSC) com; }

      ///<summary>
      /// A predefined code that fully and unambiguously describes a set of times.
      /// 
      ///   The possible set of codes that are allowed for use in this attribute should be described in conformance statements. HL7 defines the set of codes described below in GTSAbbrevation, and all information processing entities claiming direct conformance to this standard SHALL support the codes AM, PM, BID, TID, QID, JB, and JE if this type is supported
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// A predefined code that fully and unambiguously describes a set of times.
      /// 
      ///   The possible set of codes that are allowed for use in this attribute should be described in conformance statements. HL7 defines the set of codes described below in GTSAbbrevation, and all information processing entities claiming direct conformance to this standard SHALL support the codes AM, PM, BID, TID, QID, JB, and JE if this type is supported
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

    }

    ///<summary>
    /// A set of consecutive values of an ordered base datatype. 
    /// 
    ///   Any ordered type can be the basis of an IVL; it does not matter whether the base type is discrete or continuous. If the base datatype is only partially ordered, all elements of the IVL must be elements of a totally ordered subset of the partially ordered datatype. For example, PQ is considered ordered. However the ordering of PQs is only partial; a total order is only defined among comparable quantities (quantities of the same physical dimension). While IVLs between 2 and 4 meter exists, there is no IVL between 2 meters and 4 second
    ///</summary>
    public class IVL<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 IVL
      ///</summary>
      public IVL(string sType) : base(Cda.WrapperFactory.WorkingFactory.wrapped().newIVL(sType)) {} 

      internal IVL(Iv3IVL com) : base(com) {} 

      internal new HCv3IVL wrapped() { return (HCv3IVL) com; }

      ///<summary>
      /// This is the low limit. If the low limit is not known, a nullFlavor may be specified.
      /// 
      ///  The low limit SHALL NOT be positive infinity
      ///</summary>
      private T propGetLow()
      {
        return (T) HL7Connect.Cda.WrapperFactory.QTY(wrapped().low);
      }
      private void propSetLow(T value)
      {
        wrapped().low = value.wrapped();
      }
      ///<summary>
      /// This is the low limit. If the low limit is not known, a nullFlavor may be specified.
      /// 
      ///  The low limit SHALL NOT be positive infinity
      ///</summary>
      public T low { get { return propGetLow(); } set { propSetLow(value); } }

      ///<summary>
      /// false if lowClosed is null, true if lowClosed is either true or false
      ///</summary>
      private bool propGetHasLowClosed()
      {
        return wrapped().HasLowClosed != 0;
      }
      private void propSetHasLowClosed(bool value)
      {
        wrapped().HasLowClosed = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// false if lowClosed is null, true if lowClosed is either true or false
      ///</summary>
      public bool HasLowClosed { get { return propGetHasLowClosed(); } set { propSetHasLowClosed(value); } }

      ///<summary>
      /// Whether low is included in the IVL (is closed) or excluded from the IVL (is open)
      ///</summary>
      private bool propGetLowClosed()
      {
        return wrapped().lowClosed != 0;
      }
      private void propSetLowClosed(bool value)
      {
        wrapped().lowClosed = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Whether low is included in the IVL (is closed) or excluded from the IVL (is open)
      ///</summary>
      public bool lowClosed { get { return propGetLowClosed(); } set { propSetLowClosed(value); } }

      ///<summary>
      /// This is the high limit. If the high limit is not known, a nullFlavor may be specified.
      /// 
      ///  The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
      ///</summary>
      private T propGetHigh()
      {
        return (T) HL7Connect.Cda.WrapperFactory.QTY(wrapped().high);
      }
      private void propSetHigh(T value)
      {
        wrapped().high = value.wrapped();
      }
      ///<summary>
      /// This is the high limit. If the high limit is not known, a nullFlavor may be specified.
      /// 
      ///  The high limit SHALL NOT be negative infinity, and SHALL be higher than the low limit if one exists.
      ///</summary>
      public T high { get { return propGetHigh(); } set { propSetHigh(value); } }

      ///<summary>
      /// false if highClosed is null, true if highClosed is either true or false
      ///</summary>
      private bool propGetHasHighClosed()
      {
        return wrapped().HasHighClosed != 0;
      }
      private void propSetHasHighClosed(bool value)
      {
        wrapped().HasHighClosed = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// false if highClosed is null, true if highClosed is either true or false
      ///</summary>
      public bool HasHighClosed { get { return propGetHasHighClosed(); } set { propSetHasHighClosed(value); } }

      ///<summary>
      /// Whether high is included in the IVL (is closed) or excluded from the IVL (is open)
      ///</summary>
      private bool propGetHighClosed()
      {
        return wrapped().highClosed != 0;
      }
      private void propSetHighClosed(bool value)
      {
        wrapped().highClosed = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Whether high is included in the IVL (is closed) or excluded from the IVL (is open)
      ///</summary>
      public bool highClosed { get { return propGetHighClosed(); } set { propSetHighClosed(value); } }

      ///<summary>
      /// The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of
      ///</summary>
      private T propGetWidth()
      {
        return (T) HL7Connect.Cda.WrapperFactory.QTY(wrapped().width);
      }
      private void propSetWidth(T value)
      {
        wrapped().width = value.wrapped();
      }
      ///<summary>
      /// The difference between high and low boundary. Width is used when the size of the Interval is known, but the actual start and end points are not known. The actual type QTY will be dictated by the type of
      ///</summary>
      public T width { get { return propGetWidth(); } set { propSetWidth(value); } }

      ///<summary>
      /// Specifies that some particular value lies within the interval.
      /// 
      ///   This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known
      ///</summary>
      private T propGetAny()
      {
        return (T) HL7Connect.Cda.WrapperFactory.QTY(wrapped().any);
      }
      private void propSetAny(T value)
      {
        wrapped().any = value.wrapped();
      }
      ///<summary>
      /// Specifies that some particular value lies within the interval.
      /// 
      ///   This should be used when it is not known when something started, or will end, but it is known that it was happening at a given time. This is relatively common for observations (i.e. of disease processes), procedure, and scheduling. In these cases, neither high nor low is known, though the width may also be known
      ///</summary>
      public T any { get { return propGetAny(); } set { propSetAny(value); } }

      ///<summary>
      /// This is a consequence of the mapping from CDA data types to ISO 21090. If the interval is represented as &lt;x value="time"&gt; then any will be populated and anyIsValue will be set to true. If, however, the interval is encoded as &lt;x&gt;&lt;center value="time"/&gt;&lt;/x&gt; (which has the same meaning), then anyIsValue wil be set to true. The two forms are semantically equivalent; this attribute exists to control the xml rendition only. 
      /// 
      /// Note that center in CDA is mapped to Any in ISO 21090. This is somewhat equivocal, but it appears that if matches the general intent of the somewhat odd construct of only specifying a center.
      ///</summary>
      private bool propGetAnyIsValue()
      {
        return wrapped().anyIsValue != 0;
      }
      private void propSetAnyIsValue(bool value)
      {
        wrapped().anyIsValue = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// This is a consequence of the mapping from CDA data types to ISO 21090. If the interval is represented as &lt;x value="time"&gt; then any will be populated and anyIsValue will be set to true. If, however, the interval is encoded as &lt;x&gt;&lt;center value="time"/&gt;&lt;/x&gt; (which has the same meaning), then anyIsValue wil be set to true. The two forms are semantically equivalent; this attribute exists to control the xml rendition only. 
      /// 
      /// Note that center in CDA is mapped to Any in ISO 21090. This is somewhat equivocal, but it appears that if matches the general intent of the somewhat odd construct of only specifying a center.
      ///</summary>
      public bool anyIsValue { get { return propGetAnyIsValue(); } set { propSetAnyIsValue(value); } }

    }

    ///<summary>
    /// An interval of time that recurs periodically. PIVL has two properties, phase and period/frequency. phase specifies the "interval prototype" that is repeated on the period/frequency.
    ///</summary>
    public class PIVL<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 PIVL
      ///</summary>
      public PIVL() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPIVL()) {} 

      internal PIVL(Iv3PIVL com) : base(com) {} 

      internal new HCv3PIVL wrapped() { return (HCv3PIVL) com; }

      ///<summary>
      ///</summary>
      private bool propGetHasIsFlexible()
      {
        return wrapped().HasIsFlexible != 0;
      }
      private void propSetHasIsFlexible(bool value)
      {
        wrapped().HasIsFlexible = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      ///</summary>
      public bool HasIsFlexible { get { return propGetHasIsFlexible(); } set { propSetHasIsFlexible(value); } }

      ///<summary>
      /// A prototype of the repeating interval, specifying the duration of each occurrence and anchors the PIVL sequence at a certain point in time. phase also marks the anchor point in time for the entire series of periodically recurring intervals. If count is null or nullFlavored, the recurrence of a PIVL has no beginning or ending, but is infinite in both future and past. 
      /// 
      ///   The width of the phase SHALL be less than or equal to the perio
      ///</summary>
      private HL7Connect.Cda.IVL<T> propGetPhase()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<T>(wrapped().phase);
      }
      private void propSetPhase(HL7Connect.Cda.IVL<T> value)
      {
        wrapped().phase = value.wrapped();
      }
      ///<summary>
      /// A prototype of the repeating interval, specifying the duration of each occurrence and anchors the PIVL sequence at a certain point in time. phase also marks the anchor point in time for the entire series of periodically recurring intervals. If count is null or nullFlavored, the recurrence of a PIVL has no beginning or ending, but is infinite in both future and past. 
      /// 
      ///   The width of the phase SHALL be less than or equal to the perio
      ///</summary>
      public HL7Connect.Cda.IVL<T> phase { get { return propGetPhase(); } set { propSetPhase(value); } }

      ///<summary>
      /// A time duration specified as a reciprocal measure of the frequency at which the PIVL repeats
      ///</summary>
      private HL7Connect.Cda.PQ propGetPeriod()
      {
        return HL7Connect.Cda.WrapperFactory.PQ(wrapped().period);
      }
      private void propSetPeriod(HL7Connect.Cda.PQ value)
      {
        wrapped().period = value.wrapped();
      }
      ///<summary>
      /// A time duration specified as a reciprocal measure of the frequency at which the PIVL repeats
      ///</summary>
      public HL7Connect.Cda.PQ period { get { return propGetPeriod(); } set { propSetPeriod(value); } }

      ///<summary>
      /// The number of times the PIVL repeats (numerator) within a specified time-period (denominator). The numerator is an integer, and the denominator is a PQ.TIME.
      /// 
      ///   Only one of period and frequency should be specified. The form chosen should be the form that most naturally conveys the idea to humans. i.e. Every 10 mins (period) or twice a day (frequency)
      ///</summary>
      private HL7Connect.Cda.RTO propGetFrequency()
      {
        return HL7Connect.Cda.WrapperFactory.RTO(wrapped().frequency);
      }
      private void propSetFrequency(HL7Connect.Cda.RTO value)
      {
        wrapped().frequency = value.wrapped();
      }
      ///<summary>
      /// The number of times the PIVL repeats (numerator) within a specified time-period (denominator). The numerator is an integer, and the denominator is a PQ.TIME.
      /// 
      ///   Only one of period and frequency should be specified. The form chosen should be the form that most naturally conveys the idea to humans. i.e. Every 10 mins (period) or twice a day (frequency)
      ///</summary>
      public HL7Connect.Cda.RTO frequency { get { return propGetFrequency(); } set { propSetFrequency(value); } }

      ///<summary>
      /// If and how the repetitions are aligned to the cycles of the underlying calendar (e.g., to distinguish every 30 days from "the 5th of every month".) A non-aligned PIVL recurs independently from the calendar. An aligned PIVL is synchronized with the calendar.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 CalendarCycle code system.  -- possible relationships between a releating event and the calender ccNullccCYccMYccCMccCWccWYccDMccCDccDYccDWccHDccCHccNHccCNccSNccCS
      ///</summary>
      private Tv3CalendarCycle propGetAlignment()
      {
        return wrapped().alignment;
      }
      private void propSetAlignment(Tv3CalendarCycle value)
      {
        wrapped().alignment = value;
      }
      ///<summary>
      /// If and how the repetitions are aligned to the cycles of the underlying calendar (e.g., to distinguish every 30 days from "the 5th of every month".) A non-aligned PIVL recurs independently from the calendar. An aligned PIVL is synchronized with the calendar.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from the HL7 CalendarCycle code system.  -- possible relationships between a releating event and the calender ccNullccCYccMYccCMccCWccWYccDMccCDccDYccDWccHDccCHccNHccCNccSNccCS
      ///</summary>
      public Tv3CalendarCycle alignment { get { return propGetAlignment(); } set { propSetAlignment(value); } }

      ///<summary>
      /// Indicates whether the exact timing is up to the party executing the schedule e.g., to distinguish "every 8 hours" from "3 times a day".
      /// 
      ///   Note: this is sometimes referred to as "institution specified timing"
      ///</summary>
      private bool propGetIsFlexible()
      {
        return wrapped().isFlexible != 0;
      }
      private void propSetIsFlexible(bool value)
      {
        wrapped().isFlexible = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Indicates whether the exact timing is up to the party executing the schedule e.g., to distinguish "every 8 hours" from "3 times a day".
      /// 
      ///   Note: this is sometimes referred to as "institution specified timing"
      ///</summary>
      public bool isFlexible { get { return propGetIsFlexible(); } set { propSetIsFlexible(value); } }

      ///<summary>
      /// The number of times the period repeats in total. If count is null or nullFlavored, then the period repeats indefinitely both before and after the anchor implicit in the phas
      ///</summary>
      private HL7Connect.Cda.INT propGetCount()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().Count);
      }
      private void propSetCount(HL7Connect.Cda.INT value)
      {
        wrapped().Count = value.wrapped();
      }
      ///<summary>
      /// The number of times the period repeats in total. If count is null or nullFlavored, then the period repeats indefinitely both before and after the anchor implicit in the phas
      ///</summary>
      public HL7Connect.Cda.INT count { get { return propGetCount(); } set { propSetCount(value); } }

    }

    ///<summary>
    /// Specifies a periodic interval of time where the recurrence is based on activities of daily living or other important events that are time-related but not fully determined by time. 
    /// 
    ///  Example: "one hour after breakfast" specifies the beginning of the interval at one hour after breakfast is finished. Breakfast is assumed to occur before lunch but is not determined to occur at any specific tim
    ///</summary>
    public class EIVL<T> : HL7Connect.Cda.QSET<T> where T : HL7Connect.Cda.QTY
    {

      ///<summary>
      /// Create a v3 EIVL
      ///</summary>
      public EIVL() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEIVL()) {} 

      internal EIVL(Iv3EIVL com) : base(com) {} 

      internal new HCv3EIVL wrapped() { return (HCv3EIVL) com; }

      ///<summary>
      /// A code for a common (periodic) activity of daily living based on which the event related periodic interval is specified. Events that qualify for being adopted in the domain of this attribute must satisfy the following requirements:
      /// 
      ///  ï¿½ the event commonly occurs on a regular basis ï¿½ the event is being used for timing activities, and ï¿½ the event is not entirely determined by time  If these criteria are not met, the relationship of the event and its time must be communicated using structures outside the datatypes defined in this standard.  If populated, the value of this attribute SHALL be taken from the HL7 TimingEvent code system. -- Lists Timing events that a repeating event may relate to teNullteHS : HS : the hour of sleepteWAKE : WAKE : upon wakingteAC : AC : before meal (from lat. ante cibus)teACM : ACM : before breakfast (from lat. ante cibus matutinus)teACD : ACD : before lunch (from lat. ante cibus diurnus)teACV : ACV : before dinner (from lat. ante cibus vespertinus)teIC : IC : between meals (from lat. inter cibus)teICM : ICM : between breakfast and lunchteICD : ICD : between lunch and dinnerteICV : ICV : between dinner and the hour of sleeptePC : PC : after meal (from lat. post cibus)tePCM : PCM : after breakfast (from lat. post cibus matutinus)tePCD : PCD: after lunch (from lat. post cibus diurnus)tePCV : PCV : after dinner (from lat. post cibus vespertinus)teC : C : meal (from lat. cibus)teCM : CM : breakfast (from lat. cibus matutinus)teCD : CD : lunch (from lat. cibus diurnus)teCV : CV : dinner (from lat. cibus vespertinus)
      ///</summary>
      private Tv3TimingEvent propGetEvent_()
      {
        return wrapped().Event;
      }
      private void propSetEvent_(Tv3TimingEvent value)
      {
        wrapped().Event = value;
      }
      ///<summary>
      /// A code for a common (periodic) activity of daily living based on which the event related periodic interval is specified. Events that qualify for being adopted in the domain of this attribute must satisfy the following requirements:
      /// 
      ///  ï¿½ the event commonly occurs on a regular basis ï¿½ the event is being used for timing activities, and ï¿½ the event is not entirely determined by time  If these criteria are not met, the relationship of the event and its time must be communicated using structures outside the datatypes defined in this standard.  If populated, the value of this attribute SHALL be taken from the HL7 TimingEvent code system. -- Lists Timing events that a repeating event may relate to teNullteHS : HS : the hour of sleepteWAKE : WAKE : upon wakingteAC : AC : before meal (from lat. ante cibus)teACM : ACM : before breakfast (from lat. ante cibus matutinus)teACD : ACD : before lunch (from lat. ante cibus diurnus)teACV : ACV : before dinner (from lat. ante cibus vespertinus)teIC : IC : between meals (from lat. inter cibus)teICM : ICM : between breakfast and lunchteICD : ICD : between lunch and dinnerteICV : ICV : between dinner and the hour of sleeptePC : PC : after meal (from lat. post cibus)tePCM : PCM : after breakfast (from lat. post cibus matutinus)tePCD : PCD: after lunch (from lat. post cibus diurnus)tePCV : PCV : after dinner (from lat. post cibus vespertinus)teC : C : meal (from lat. cibus)teCM : CM : breakfast (from lat. cibus matutinus)teCD : CD : lunch (from lat. cibus diurnus)teCV : CV : dinner (from lat. cibus vespertinus)
      ///</summary>
      public Tv3TimingEvent event_ { get { return propGetEvent_(); } set { propSetEvent_(value); } }

      ///<summary>
      /// An interval of elapsed time (duration, not absolute point in time) that marks the offsets for the beginning, width and end of the EIVL measured from the time each such event actually occurred. 
      /// 
      ///   Example: if the specification is "one hour before breakfast for 10 minutes", code is CM, IVL.low of offset is -1 h and the IVL.high of offset is -50 min.  The offset SHALL be null if the event code specifies "before", "after" or "between meals". The offset SHALL be nonNull if the EIVL is nonNull and the event code is C, CM, CD, or CV. The offset may or may not be null for the event codes HS and WAKE
      ///</summary>
      private HL7Connect.Cda.IVL<T> propGetOffset()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<T>(wrapped().offset);
      }
      private void propSetOffset(HL7Connect.Cda.IVL<T> value)
      {
        wrapped().offset = value.wrapped();
      }
      ///<summary>
      /// An interval of elapsed time (duration, not absolute point in time) that marks the offsets for the beginning, width and end of the EIVL measured from the time each such event actually occurred. 
      /// 
      ///   Example: if the specification is "one hour before breakfast for 10 minutes", code is CM, IVL.low of offset is -1 h and the IVL.high of offset is -50 min.  The offset SHALL be null if the event code specifies "before", "after" or "between meals". The offset SHALL be nonNull if the EIVL is nonNull and the event code is C, CM, CD, or CV. The offset may or may not be null for the event codes HS and WAKE
      ///</summary>
      public HL7Connect.Cda.IVL<T> offset { get { return propGetOffset(); } set { propSetOffset(value); } }

    }

    ///<summary>
    /// Specializes ANY
    /// 
    ///   Parameter: T : ANY  A generic datatype extension used to specify a probability expressing the information producer's belief that the given value holds
    ///</summary>
    public class UVP : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 UVP
      ///</summary>
      public UVP() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newUVP()) {} 

      internal UVP(Iv3UVP com) : base(com) {} 

      internal new HCv3UVP wrapped() { return (HCv3UVP) com; }

      ///<summary>
      /// The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 
      /// 
      ///   There is no "default probability" that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean "uncertain", and a simple T does not mean "certain". In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess
      ///</summary>
      private HL7Connect.Ucum.QDecimal propGetProbability()
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().probability);
      }
      private void propSetProbability(HL7Connect.Ucum.QDecimal value)
      {
        wrapped().probability = value.wrapped();
      }
      ///<summary>
      /// The probability assigned to the value, a decimal number between 0 (impossible) and 1 (certain), inclusive. 
      /// 
      ///   There is no "default probability" that one can assume when the probability is unstated. Therefore, it is impossible to make any semantic difference between a UVP without probability and a simple T. UVP does not mean "uncertain", and a simple T does not mean "certain". In fact, the probability of the UVP could be 0.999 or 1, which is quite certain, where a simple T value could be a very vague guess
      ///</summary>
      public HL7Connect.Ucum.QDecimal probability { get { return propGetProbability(); } set { propSetProbability(value); } }

      ///<summary>
      /// The value of T which the probability refers t
      ///</summary>
      private HL7Connect.Cda.ANY propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ANY(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.ANY value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// The value of T which the probability refers t
      ///</summary>
      public HL7Connect.Cda.ANY value { get { return propGetValue(); } set { propSetValue(value); } }

    }

    ///<summary>
    /// Specializes ANY
    /// 
    ///   Parameter: T : ANY  A set of UVP with probabilities (also known as a histogram.) All the elements in the set are considered alternatives and are rated each with its probability expressing the belief (or frequency) that each given value holds.  NPPD&lt;T&gt; may be used where only one value for T may be true. The sum of the probabilities should be &lt;= 1, but due to estimating and rounding inaccuracies, the total may actually exceed
    ///</summary>
    public class NPPD : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a v3 NPPD
      ///</summary>
      public NPPD() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newNPPD()) {} 

      internal NPPD(Iv3NPPD com) : base(com) {} 

      internal new HCv3NPPD wrapped() { return (HCv3NPPD) com; }

      ///<summary>
      /// The list of values with probabilities for the histogra
      ///</summary>
      private HL7Connect.Cda.SetUVP propGetItem()
      {
        return HL7Connect.Cda.WrapperFactory.SetUVP(wrapped().Item);
      }
      private void propSetItem(HL7Connect.Cda.SetUVP value)
      {
        wrapped().Item = value.wrapped();
      }
      ///<summary>
      /// The list of values with probabilities for the histogra
      ///</summary>
      public HL7Connect.Cda.SetUVP item { get { return propGetItem(); } set { propSetItem(value); } }

    }

    public class SetED : HL7Connect.Utils.Base, ISet<ED>
    {
      public SetED(Iv3SetED com) : base(com) {}
      internal new HCv3SetED wrapped() { return (HCv3SetED) com; }
  
      public bool Add(ED item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<ED> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<ED>.Add(ED item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ED item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ED[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ED(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(ED item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetEDEnumerator : IEnumerator<ED>
      {
        private Iv3SetED com;
        int index = -1;
  
        public SetEDEnumerator(Iv3SetED com)
        {
          this.com = com;
        }
  
        public ED Current { get { return new ED(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ED(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ED> GetEnumerator()
      {
        return new SetEDEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetEDEnumerator(wrapped());
      }
  
    }
  
    public class SetST : HL7Connect.Utils.Base, ISet<ST>
    {
      public SetST(Iv3SetST com) : base(com) {}
      internal new HCv3SetST wrapped() { return (HCv3SetST) com; }
  
      public bool Add(ST item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<ST> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<ST>.Add(ST item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ST item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ST[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (ST) HL7Connect.Cda.WrapperFactory.ST(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(ST item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetSTEnumerator : IEnumerator<ST>
      {
        private Iv3SetST com;
        int index = -1;
  
        public SetSTEnumerator(Iv3SetST com)
        {
          this.com = com;
        }
  
        public ST Current { get { return (ST) HL7Connect.Cda.WrapperFactory.ST(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (ST) HL7Connect.Cda.WrapperFactory.ST(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ST> GetEnumerator()
      {
        return new SetSTEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetSTEnumerator(wrapped());
      }
  
    }
  
    public class SetCD : HL7Connect.Utils.Base, ISet<CD>
    {
      public SetCD(Iv3SetCD com) : base(com) {}
      internal new HCv3SetCD wrapped() { return (HCv3SetCD) com; }
  
      public bool Add(CD item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<CD> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<CD>.Add(CD item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CD item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CD[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (CD) HL7Connect.Cda.WrapperFactory.CD(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(CD item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetCDEnumerator : IEnumerator<CD>
      {
        private Iv3SetCD com;
        int index = -1;
  
        public SetCDEnumerator(Iv3SetCD com)
        {
          this.com = com;
        }
  
        public CD Current { get { return (CD) HL7Connect.Cda.WrapperFactory.CD(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (CD) HL7Connect.Cda.WrapperFactory.CD(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CD> GetEnumerator()
      {
        return new SetCDEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetCDEnumerator(wrapped());
      }
  
    }
  
    public class ListADXP : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ADXP>
    {
      public ListADXP(Iv3ListADXP com) : base(com) {}
      internal new HCv3ListADXP wrapped() { return (HCv3ListADXP) com; }
  
      public ADXP this[int index]
      {
        get { return new ADXP(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ADXP item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ADXP Append()
      {
        return new ADXP(wrapped().Append());
      }
  
      public void Insert(int index, ADXP item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ADXP item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ADXP item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ADXP[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ADXP(wrapped().Item(i));
      }
  
      public bool Remove(ADXP item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListADXPEnumerator : IEnumerator<ADXP>
      {
        private Iv3ListADXP com;
        int index = -1;
  
        public ListADXPEnumerator(Iv3ListADXP com)
        {
          this.com = com;
        }
  
        public ADXP Current { get { return new ADXP(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ADXP(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ADXP> GetEnumerator()
      {
        return new ListADXPEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListADXPEnumerator(wrapped());
      }
  
    }
  
    public class ListENXP : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ENXP>
    {
      public ListENXP(Iv3ListENXP com) : base(com) {}
      internal new HCv3ListENXP wrapped() { return (HCv3ListENXP) com; }
  
      public ENXP this[int index]
      {
        get { return new ENXP(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ENXP item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ENXP Append()
      {
        return new ENXP(wrapped().Append());
      }
  
      public void Insert(int index, ENXP item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ENXP item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ENXP item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ENXP[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ENXP(wrapped().Item(i));
      }
  
      public bool Remove(ENXP item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListENXPEnumerator : IEnumerator<ENXP>
      {
        private Iv3ListENXP com;
        int index = -1;
  
        public ListENXPEnumerator(Iv3ListENXP com)
        {
          this.com = com;
        }
  
        public ENXP Current { get { return new ENXP(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ENXP(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ENXP> GetEnumerator()
      {
        return new ListENXPEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListENXPEnumerator(wrapped());
      }
  
    }
  
    public class SetPQR : HL7Connect.Utils.Base, ISet<PQR>
    {
      public SetPQR(Iv3SetPQR com) : base(com) {}
      internal new HCv3SetPQR wrapped() { return (HCv3SetPQR) com; }
  
      public bool Add(PQR item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<PQR> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<PQR>.Add(PQR item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(PQR item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(PQR[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new PQR(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(PQR item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetPQREnumerator : IEnumerator<PQR>
      {
        private Iv3SetPQR com;
        int index = -1;
  
        public SetPQREnumerator(Iv3SetPQR com)
        {
          this.com = com;
        }
  
        public PQR Current { get { return new PQR(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new PQR(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<PQR> GetEnumerator()
      {
        return new SetPQREnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetPQREnumerator(wrapped());
      }
  
    }
  
    public class SetQSET<T> : HL7Connect.Utils.Base, ISet<QSET<T>> where T : HL7Connect.Cda.QTY
    {
      public SetQSET(Iv3SetQSET com) : base(com) {}
      internal new HCv3SetQSET wrapped() { return (HCv3SetQSET) com; }
  
      public bool Add(QSET<T> item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<QSET<T>> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<QSET<T>>.Add(QSET<T> item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(QSET<T> item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(QSET<T>[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new QSET<T>(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(QSET<T> item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetQSETEnumerator : IEnumerator<QSET<T>>
      {
        private Iv3SetQSET com;
        int index = -1;
  
        public SetQSETEnumerator(Iv3SetQSET com)
        {
          this.com = com;
        }
  
        public QSET<T> Current { get { return new QSET<T>(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new QSET<T>(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<QSET<T>> GetEnumerator()
      {
        return new SetQSETEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetQSETEnumerator(wrapped());
      }
  
    }
  
    public class SetQTY : HL7Connect.Utils.Base, ISet<QTY>
    {
      public SetQTY(Iv3SetQTY com) : base(com) {}
      internal new HCv3SetQTY wrapped() { return (HCv3SetQTY) com; }
  
      public bool Add(QTY item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<QTY> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<QTY>.Add(QTY item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(QTY item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(QTY[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (QTY) HL7Connect.Cda.WrapperFactory.QTY(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(QTY item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetQTYEnumerator : IEnumerator<QTY>
      {
        private Iv3SetQTY com;
        int index = -1;
  
        public SetQTYEnumerator(Iv3SetQTY com)
        {
          this.com = com;
        }
  
        public QTY Current { get { return (QTY) HL7Connect.Cda.WrapperFactory.QTY(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (QTY) HL7Connect.Cda.WrapperFactory.QTY(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<QTY> GetEnumerator()
      {
        return new SetQTYEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetQTYEnumerator(wrapped());
      }
  
    }
  
    public class SetUVP : HL7Connect.Utils.Base, ISet<UVP>
    {
      public SetUVP(Iv3SetUVP com) : base(com) {}
      internal new HCv3SetUVP wrapped() { return (HCv3SetUVP) com; }
  
      public bool Add(UVP item)
      {
        return wrapped().AddItem(item.wrapped()) == 0 ? false : true;
      }
  
      public void ExceptWith(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public void IntersectWith(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSubsetOf(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsProperSupersetOf(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSubsetOf(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public bool IsSupersetOf(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public bool Overlaps(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public bool SetEquals(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public void SymmetricExceptWith(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      public void UnionWith(IEnumerable<UVP> other)
      {
        throw new NotImplementedException();
      }
  
      void ICollection<UVP>.Add(UVP item)
      {
        throw new NotImplementedException();
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(UVP item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(UVP[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new UVP(wrapped().Item(i));
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public bool Remove(UVP item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SetUVPEnumerator : IEnumerator<UVP>
      {
        private Iv3SetUVP com;
        int index = -1;
  
        public SetUVPEnumerator(Iv3SetUVP com)
        {
          this.com = com;
        }
  
        public UVP Current { get { return new UVP(com.Item(index)); } }
  
        public void Dispose() { }
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new UVP(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<UVP> GetEnumerator()
      {
        return new SetUVPEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SetUVPEnumerator(wrapped());
      }
  
    }
  
    public class ListCS : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CS>
    {
      public ListCS(Iv3ListCS com) : base(com) {}
      internal new HCv3ListCS wrapped() { return (HCv3ListCS) com; }
  
      public CS this[int index]
      {
        get { return new CS(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CS item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CS Append()
      {
        return new CS(wrapped().Append());
      }
  
      public void Insert(int index, CS item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CS item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CS item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CS[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new CS(wrapped().Item(i));
      }
  
      public bool Remove(CS item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListCSEnumerator : IEnumerator<CS>
      {
        private Iv3ListCS com;
        int index = -1;
  
        public ListCSEnumerator(Iv3ListCS com)
        {
          this.com = com;
        }
  
        public CS Current { get { return new CS(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new CS(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CS> GetEnumerator()
      {
        return new ListCSEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListCSEnumerator(wrapped());
      }
  
    }
  
    public class ListII : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<II>
    {
      public ListII(Iv3ListII com) : base(com) {}
      internal new HCv3ListII wrapped() { return (HCv3ListII) com; }
  
      public II this[int index]
      {
        get { return new II(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(II item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public II Append()
      {
        return new II(wrapped().Append());
      }
  
      public void Insert(int index, II item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(II item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(II item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(II[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new II(wrapped().Item(i));
      }
  
      public bool Remove(II item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListIIEnumerator : IEnumerator<II>
      {
        private Iv3ListII com;
        int index = -1;
  
        public ListIIEnumerator(Iv3ListII com)
        {
          this.com = com;
        }
  
        public II Current { get { return new II(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new II(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<II> GetEnumerator()
      {
        return new ListIIEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListIIEnumerator(wrapped());
      }
  
    }
  
    public class ListAD : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<AD>
    {
      public ListAD(Iv3ListAD com) : base(com) {}
      internal new HCv3ListAD wrapped() { return (HCv3ListAD) com; }
  
      public AD this[int index]
      {
        get { return new AD(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(AD item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public AD Append()
      {
        return new AD(wrapped().Append());
      }
  
      public void Insert(int index, AD item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(AD item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(AD item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(AD[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new AD(wrapped().Item(i));
      }
  
      public bool Remove(AD item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListADEnumerator : IEnumerator<AD>
      {
        private Iv3ListAD com;
        int index = -1;
  
        public ListADEnumerator(Iv3ListAD com)
        {
          this.com = com;
        }
  
        public AD Current { get { return new AD(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new AD(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<AD> GetEnumerator()
      {
        return new ListADEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListADEnumerator(wrapped());
      }
  
    }
  
    public class ListTEL : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<TEL>
    {
      public ListTEL(Iv3ListTEL com) : base(com) {}
      internal new HCv3ListTEL wrapped() { return (HCv3ListTEL) com; }
  
      public TEL this[int index]
      {
        get { return new TEL(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(TEL item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public TEL Append()
      {
        return new TEL(wrapped().Append());
      }
  
      public void Insert(int index, TEL item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(TEL item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(TEL item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(TEL[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new TEL(wrapped().Item(i));
      }
  
      public bool Remove(TEL item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListTELEnumerator : IEnumerator<TEL>
      {
        private Iv3ListTEL com;
        int index = -1;
  
        public ListTELEnumerator(Iv3ListTEL com)
        {
          this.com = com;
        }
  
        public TEL Current { get { return new TEL(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new TEL(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<TEL> GetEnumerator()
      {
        return new ListTELEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListTELEnumerator(wrapped());
      }
  
    }
  
    public class ListANY : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ANY>
    {
      public ListANY(Iv3ListANY com) : base(com) {}
      internal new HCv3ListANY wrapped() { return (HCv3ListANY) com; }
  
      public ANY this[int index]
      {
        get { return (ANY) HL7Connect.Cda.WrapperFactory.ANY(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ANY item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ANY Append()
      {
        return (ANY) HL7Connect.Cda.WrapperFactory.ANY(wrapped().Append());
      }
  
      public void Insert(int index, ANY item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ANY item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ANY item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ANY[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (ANY) HL7Connect.Cda.WrapperFactory.ANY(wrapped().Item(i));
      }
  
      public bool Remove(ANY item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListANYEnumerator : IEnumerator<ANY>
      {
        private Iv3ListANY com;
        int index = -1;
  
        public ListANYEnumerator(Iv3ListANY com)
        {
          this.com = com;
        }
  
        public ANY Current { get { return (ANY) HL7Connect.Cda.WrapperFactory.ANY(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (ANY) HL7Connect.Cda.WrapperFactory.ANY(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ANY> GetEnumerator()
      {
        return new ListANYEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListANYEnumerator(wrapped());
      }
  
    }
  
    public class ListCD : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CD>
    {
      public ListCD(Iv3ListCD com) : base(com) {}
      internal new HCv3ListCD wrapped() { return (HCv3ListCD) com; }
  
      public CD this[int index]
      {
        get { return (CD) HL7Connect.Cda.WrapperFactory.CD(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CD item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CD Append()
      {
        return (CD) HL7Connect.Cda.WrapperFactory.CD(wrapped().Append());
      }
  
      public void Insert(int index, CD item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CD item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CD item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CD[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (CD) HL7Connect.Cda.WrapperFactory.CD(wrapped().Item(i));
      }
  
      public bool Remove(CD item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListCDEnumerator : IEnumerator<CD>
      {
        private Iv3ListCD com;
        int index = -1;
  
        public ListCDEnumerator(Iv3ListCD com)
        {
          this.com = com;
        }
  
        public CD Current { get { return (CD) HL7Connect.Cda.WrapperFactory.CD(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (CD) HL7Connect.Cda.WrapperFactory.CD(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CD> GetEnumerator()
      {
        return new ListCDEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListCDEnumerator(wrapped());
      }
  
    }
  
    public class ListEN : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<EN>
    {
      public ListEN(Iv3ListEN com) : base(com) {}
      internal new HCv3ListEN wrapped() { return (HCv3ListEN) com; }
  
      public EN this[int index]
      {
        get { return new EN(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(EN item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public EN Append()
      {
        return new EN(wrapped().Append());
      }
  
      public void Insert(int index, EN item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(EN item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(EN item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(EN[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new EN(wrapped().Item(i));
      }
  
      public bool Remove(EN item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListENEnumerator : IEnumerator<EN>
      {
        private Iv3ListEN com;
        int index = -1;
  
        public ListENEnumerator(Iv3ListEN com)
        {
          this.com = com;
        }
  
        public EN Current { get { return new EN(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new EN(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<EN> GetEnumerator()
      {
        return new ListENEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListENEnumerator(wrapped());
      }
  
    }
  
    public class ListCR : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CR>
    {
      public ListCR(Iv3ListCR com) : base(com) {}
      internal new HCv3ListCR wrapped() { return (HCv3ListCR) com; }
  
      public CR this[int index]
      {
        get { return new CR(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CR item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CR Append()
      {
        return new CR(wrapped().Append());
      }
  
      public void Insert(int index, CR item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CR item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CR item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CR[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new CR(wrapped().Item(i));
      }
  
      public bool Remove(CR item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListCREnumerator : IEnumerator<CR>
      {
        private Iv3ListCR com;
        int index = -1;
  
        public ListCREnumerator(Iv3ListCR com)
        {
          this.com = com;
        }
  
        public CR Current { get { return new CR(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new CR(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CR> GetEnumerator()
      {
        return new ListCREnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListCREnumerator(wrapped());
      }
  
    }
  
    public class ListPQ : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<PQ>
    {
      public ListPQ(Iv3ListPQ com) : base(com) {}
      internal new HCv3ListPQ wrapped() { return (HCv3ListPQ) com; }
  
      public PQ this[int index]
      {
        get { return new PQ(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(PQ item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public PQ Append()
      {
        return new PQ(wrapped().Append());
      }
  
      public void Insert(int index, PQ item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(PQ item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(PQ item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(PQ[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new PQ(wrapped().Item(i));
      }
  
      public bool Remove(PQ item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ListPQEnumerator : IEnumerator<PQ>
      {
        private Iv3ListPQ com;
        int index = -1;
  
        public ListPQEnumerator(Iv3ListPQ com)
        {
          this.com = com;
        }
  
        public PQ Current { get { return new PQ(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new PQ(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<PQ> GetEnumerator()
      {
        return new ListPQEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ListPQEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// Defines basic identification and styling attributes shared by many structured document elements
    ///</summary>
    public class SNBase : HL7Connect.Utils.Base
    {

      internal SNBase(IsnBase com) : base(com) {} 

      internal new HCsnBase wrapped() { return (HCsnBase) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Unique Identity of this element within a documen
      ///</summary>
      private string propGetID()
      {
        return wrapped().ID;
      }
      private void propSetID(string value)
      {
        wrapped().ID = value;
      }
      ///<summary>
      /// Unique Identity of this element within a documen
      ///</summary>
      public string ID { get { return propGetID(); } set { propSetID(value); } }

      ///<summary>
      /// Language of the element. See Section 7.4.2.3.7 for more information. Within a document, the language applies to all the contained elements unless some other language is specifically identifie
      ///</summary>
      private string propGetLanguage()
      {
        return wrapped().language;
      }
      private void propSetLanguage(string value)
      {
        wrapped().language = value;
      }
      ///<summary>
      /// Language of the element. See Section 7.4.2.3.7 for more information. Within a document, the language applies to all the contained elements unless some other language is specifically identifie
      ///</summary>
      public string language { get { return propGetLanguage(); } set { propSetLanguage(value); } }

      ///<summary>
      /// Styles that apply to this document.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from one of these values listed in StyleCode or a valid local extension.  Local extensions to the styleType enumeration must follow the following convention: [x][A-Za-z][A-Za-z0-9]* (first character is "x", second character is an upper or lower case A-Z, remaining characters are any combination of upper and lower case letters or numbers)
      ///</summary>
      private IList<String> propGetStyleCode()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().styleCode);
      }
      ///<summary>
      /// Styles that apply to this document.
      /// 
      ///  If populated, the value of this attribute SHALL be taken from one of these values listed in StyleCode or a valid local extension.  Local extensions to the styleType enumeration must follow the following convention: [x][A-Za-z][A-Za-z0-9]* (first character is "x", second character is an upper or lower case A-Z, remaining characters are any combination of upper and lower case letters or numbers)
      ///</summary>
      public IList<String> styleCode { get { return propGetStyleCode(); } }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class SDText : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a IsnText
      ///</summary>
      public SDText() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newText()) {} 

      internal SDText(IsnText com) : base(com) {} 

      internal new HCsnText wrapped() { return (HCsnText) com; }

      ///<summary>
      /// Unique Identity of this element within a document - can be used as a URL target
      ///</summary>
      private string propGetID()
      {
        return wrapped().ID;
      }
      private void propSetID(string value)
      {
        wrapped().ID = value;
      }
      ///<summary>
      /// Unique Identity of this element within a document - can be used as a URL target
      ///</summary>
      public string ID { get { return propGetID(); } set { propSetID(value); } }

      ///<summary>
      /// Language of the element. Within a document, the language applies to all the contained elements unless some other language is specifically identified
      ///</summary>
      private string propGetLanguage()
      {
        return wrapped().language;
      }
      private void propSetLanguage(string value)
      {
        wrapped().language = value;
      }
      ///<summary>
      /// Language of the element. Within a document, the language applies to all the contained elements unless some other language is specifically identified
      ///</summary>
      public string language { get { return propGetLanguage(); } set { propSetLanguage(value); } }

      ///<summary>
      /// If populated, the value of this attribute SHALL be taken from one of these values listed in StyleCode or a valid local extension. 
      /// 
      /// Local extensions to the styleType enumeration must follow the following convention: [x][A-Za-z][A-Za-z0-9]* (first character is "x", second character is an upper or lower case A-Z, remaining characters are any combination of upper and lower case letters or numbers)
      ///</summary>
      private IList<String> propGetStyleCode()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().styleCode);
      }
      ///<summary>
      /// If populated, the value of this attribute SHALL be taken from one of these values listed in StyleCode or a valid local extension. 
      /// 
      /// Local extensions to the styleType enumeration must follow the following convention: [x][A-Za-z][A-Za-z0-9]* (first character is "x", second character is an upper or lower case A-Z, remaining characters are any combination of upper and lower case letters or numbers)
      ///</summary>
      public IList<String> styleCode { get { return propGetStyleCode(); } }

      ///<summary>
      /// A series of parts that capture the content of the narrative text
      ///</summary>
      private HL7Connect.Cda.CMGeneralList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMGeneralList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the narrative text
      ///</summary>
      public HL7Connect.Cda.CMGeneralList parts { get { return propGetParts(); } }

      ///<summary>
      /// mediaType is fixed to text/x-hl7-text+xml
      ///</summary>
      private string propGetMediaType()
      {
        return wrapped().mediaType;
      }
      ///<summary>
      /// mediaType is fixed to text/x-hl7-text+xml
      ///</summary>
      public string mediaType { get { return propGetMediaType(); } }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class SDTitle : HL7Connect.Cda.ANY
    {

      ///<summary>
      /// Create a IsnTitle
      ///</summary>
      public SDTitle() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTitle()) {} 

      internal SDTitle(IsnTitle com) : base(com) {} 

      internal new HCsnTitle wrapped() { return (HCsnTitle) com; }

      ///<summary>
      /// Unique Identity of this element within a document - can be used as a URL target
      ///</summary>
      private string propGetID()
      {
        return wrapped().ID;
      }
      private void propSetID(string value)
      {
        wrapped().ID = value;
      }
      ///<summary>
      /// Unique Identity of this element within a document - can be used as a URL target
      ///</summary>
      public string ID { get { return propGetID(); } set { propSetID(value); } }

      ///<summary>
      /// Language of the element. Within a document, the language applies to all the contained elements unless some other language is specifically identified
      ///</summary>
      private string propGetLanguage()
      {
        return wrapped().language;
      }
      private void propSetLanguage(string value)
      {
        wrapped().language = value;
      }
      ///<summary>
      /// Language of the element. Within a document, the language applies to all the contained elements unless some other language is specifically identified
      ///</summary>
      public string language { get { return propGetLanguage(); } set { propSetLanguage(value); } }

      ///<summary>
      /// If populated, the value of this attribute SHALL be taken from one of these values listed in StyleCode or a valid local extension. 
      /// 
      /// Local extensions to the styleType enumeration must follow the following convention: [x][A-Za-z][A-Za-z0-9]* (first character is "x", second character is an upper or lower case A-Z, remaining characters are any combination of upper and lower case letters or numbers)
      ///</summary>
      private IList<String> propGetStyleCode()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().styleCode);
      }
      ///<summary>
      /// If populated, the value of this attribute SHALL be taken from one of these values listed in StyleCode or a valid local extension. 
      /// 
      /// Local extensions to the styleType enumeration must follow the following convention: [x][A-Za-z][A-Za-z0-9]* (first character is "x", second character is an upper or lower case A-Z, remaining characters are any combination of upper and lower case letters or numbers)
      ///</summary>
      public IList<String> styleCode { get { return propGetStyleCode(); } }

      ///<summary>
      /// A series of parts that capture the content of the narrative title
      ///</summary>
      private HL7Connect.Cda.CMTitleList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMTitleList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the narrative title
      ///</summary>
      public HL7Connect.Cda.CMTitleList parts { get { return propGetParts(); } }

      ///<summary>
      /// mediaType is fixed to text/x-hl7-text+xml
      ///</summary>
      private string propGetMediaType()
      {
        return wrapped().mediaType;
      }
      ///<summary>
      /// mediaType is fixed to text/x-hl7-text+xml
      ///</summary>
      public string mediaType { get { return propGetMediaType(); } }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class CMFootnotes : HL7Connect.Cda.Base
    {

      ///<summary>
      /// Create a Narrative CMFootnotes
      ///</summary>
      public CMFootnotes() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCMFootnotes()) {} 

      internal CMFootnotes(IsnCMFootnotes com) : base(com) {} 

      internal new HCsnCMFootnotes wrapped() { return (HCsnCMFootnotes) com; }

      ///<summary>
      /// Plain text string.
      ///</summary>
      private string propGetText()
      {
        return wrapped().Text;
      }
      private void propSetText(string value)
      {
        wrapped().Text = value;
      }
      ///<summary>
      /// Plain text string.
      ///</summary>
      public string text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// contents of an ampersand entity (i.e. "#160" will be encoded as &#160;).
      ///</summary>
      private string propGetEntity()
      {
        return wrapped().entity;
      }
      private void propSetEntity(string value)
      {
        wrapped().entity = value;
      }
      ///<summary>
      /// contents of an ampersand entity (i.e. "#160" will be encoded as &#160;).
      ///</summary>
      public string entity { get { return propGetEntity(); } set { propSetEntity(value); } }

      ///<summary>
      /// A footnot
      ///</summary>
      private HL7Connect.Cda.Footnote propGetFootnote()
      {
        return HL7Connect.Cda.WrapperFactory.Footnote(wrapped().footnote);
      }
      private void propSetFootnote(HL7Connect.Cda.Footnote value)
      {
        wrapped().footnote = value.wrapped();
      }
      ///<summary>
      /// A footnot
      ///</summary>
      public HL7Connect.Cda.Footnote footnote { get { return propGetFootnote(); } set { propSetFootnote(value); } }

      ///<summary>
      /// A reference to a footnot
      ///</summary>
      private HL7Connect.Cda.FootnoteRef propGetFootnoteRef()
      {
        return HL7Connect.Cda.WrapperFactory.FootnoteRef(wrapped().footnoteRef);
      }
      private void propSetFootnoteRef(HL7Connect.Cda.FootnoteRef value)
      {
        wrapped().footnoteRef = value.wrapped();
      }
      ///<summary>
      /// A reference to a footnot
      ///</summary>
      public HL7Connect.Cda.FootnoteRef footnoteRef { get { return propGetFootnoteRef(); } set { propSetFootnoteRef(value); } }

    }

    ///<summary>
    /// Content model that allows text, footnotes, links, and superscript and subscript text. The choice stereotype denotes that exactly one of the attributes (including inherited attributes) SHALL have a value. All the others must be null.
    ///</summary>
    public class CMInline : HL7Connect.Cda.CMFootnotes
    {

      ///<summary>
      /// Create a Narrative CMInline
      ///</summary>
      public CMInline() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCMInline()) {} 

      internal CMInline(IsnCMInline com) : base(com) {} 

      internal new HCsnCMInline wrapped() { return (HCsnCMInline) com; }

      ///<summary>
      /// A HTML-type lin
      ///</summary>
      private HL7Connect.Cda.LinkHtml propGetLinkHtml()
      {
        return HL7Connect.Cda.WrapperFactory.LinkHtml(wrapped().linkHtml);
      }
      private void propSetLinkHtml(HL7Connect.Cda.LinkHtml value)
      {
        wrapped().linkHtml = value.wrapped();
      }
      ///<summary>
      /// A HTML-type lin
      ///</summary>
      public HL7Connect.Cda.LinkHtml linkHtml { get { return propGetLinkHtml(); } set { propSetLinkHtml(value); } }

      ///<summary>
      /// Subscript tex
      ///</summary>
      private string propGetSub()
      {
        return wrapped().sub;
      }
      private void propSetSub(string value)
      {
        wrapped().sub = value;
      }
      ///<summary>
      /// Subscript tex
      ///</summary>
      public string sub { get { return propGetSub(); } set { propSetSub(value); } }

      ///<summary>
      /// Superscript tex
      ///</summary>
      private string propGetSup()
      {
        return wrapped().sup;
      }
      private void propSetSup(string value)
      {
        wrapped().sup = value;
      }
      ///<summary>
      /// Superscript tex
      ///</summary>
      public string sup { get { return propGetSup(); } set { propSetSup(value); } }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class CMTitle : HL7Connect.Utils.Base
    {

      ///<summary>
      /// Create a Narrative CMTitle
      ///</summary>
      public CMTitle() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCMTitle()) {} 

      internal CMTitle(IsnCMTitle com) : base(com) {} 

      internal new HCsnCMTitle wrapped() { return (HCsnCMTitle) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Plain text string.
      ///</summary>
      private string propGetText()
      {
        return wrapped().Text;
      }
      private void propSetText(string value)
      {
        wrapped().Text = value;
      }
      ///<summary>
      /// Plain text string.
      ///</summary>
      public string text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// contents of an ampersand entity (i.e. "#160" will be encoded as &#160;).
      ///</summary>
      private string propGetEntity()
      {
        return wrapped().entity;
      }
      private void propSetEntity(string value)
      {
        wrapped().entity = value;
      }
      ///<summary>
      /// contents of an ampersand entity (i.e. "#160" will be encoded as &#160;).
      ///</summary>
      public string entity { get { return propGetEntity(); } set { propSetEntity(value); } }

      ///<summary>
      /// A footnot
      ///</summary>
      private HL7Connect.Cda.CMTitleList propGetFootnote()
      {
        return HL7Connect.Cda.WrapperFactory.CMTitleList(wrapped().footnote);
      }
      private void propSetFootnote(HL7Connect.Cda.CMTitleList value)
      {
        wrapped().footnote = value.wrapped();
      }
      ///<summary>
      /// A footnot
      ///</summary>
      public HL7Connect.Cda.CMTitleList footnote { get { return propGetFootnote(); } set { propSetFootnote(value); } }

      ///<summary>
      /// A reference to a footnote
      ///</summary>
      private string propGetFootnoteRef()
      {
        return wrapped().footnoteRef;
      }
      private void propSetFootnoteRef(string value)
      {
        wrapped().footnoteRef = value;
      }
      ///<summary>
      /// A reference to a footnote
      ///</summary>
      public string footnoteRef { get { return propGetFootnoteRef(); } set { propSetFootnoteRef(value); } }

      ///<summary>
      /// A hard line break
      ///</summary>
      private bool propGetBr()
      {
        return wrapped().br != 0;
      }
      private void propSetBr(bool value)
      {
        wrapped().br = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// A hard line break
      ///</summary>
      public bool br { get { return propGetBr(); } set { propSetBr(value); } }

      ///<summary>
      /// A HTML-type lin
      ///</summary>
      private HL7Connect.Cda.LinkHtml propGetLinkHtml()
      {
        return HL7Connect.Cda.WrapperFactory.LinkHtml(wrapped().linkHtml);
      }
      private void propSetLinkHtml(HL7Connect.Cda.LinkHtml value)
      {
        wrapped().linkHtml = value.wrapped();
      }
      ///<summary>
      /// A HTML-type lin
      ///</summary>
      public HL7Connect.Cda.LinkHtml linkHtml { get { return propGetLinkHtml(); } set { propSetLinkHtml(value); } }

      ///<summary>
      ///</summary>
      private string propGetSub()
      {
        return wrapped().sub;
      }
      private void propSetSub(string value)
      {
        wrapped().sub = value;
      }
      ///<summary>
      ///</summary>
      public string sub { get { return propGetSub(); } set { propSetSub(value); } }

      ///<summary>
      ///</summary>
      private string propGetSup()
      {
        return wrapped().sup;
      }
      private void propSetSup(string value)
      {
        wrapped().sup = value;
      }
      ///<summary>
      ///</summary>
      public string sup { get { return propGetSup(); } set { propSetSup(value); } }

      ///<summary>
      /// Nested Conten
      ///</summary>
      private HL7Connect.Cda.CMTitle propGetContent()
      {
        return HL7Connect.Cda.WrapperFactory.CMTitle(wrapped().content);
      }
      private void propSetContent(HL7Connect.Cda.CMTitle value)
      {
        wrapped().content = value.wrapped();
      }
      ///<summary>
      /// Nested Conten
      ///</summary>
      public HL7Connect.Cda.CMTitle content { get { return propGetContent(); } set { propSetContent(value); } }

    }

    ///<summary>
    /// Content model that allows text, footnotes, links, superscript and subscript text, line breaks, multimedia content, and nested Content items. The choice stereotype denotes that exactly one of the attributes (including inherited attributes) SHALL have a value. All the others must be null.
    ///</summary>
    public class CMContent : HL7Connect.Cda.CMInline
    {

      ///<summary>
      /// Create a Narrative CMContent
      ///</summary>
      public CMContent() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCMContent()) {} 

      internal CMContent(IsnCMContent com) : base(com) {} 

      internal new HCsnCMContent wrapped() { return (HCsnCMContent) com; }

      ///<summary>
      /// Nested Conten
      ///</summary>
      private HL7Connect.Cda.Content propGetContent()
      {
        return HL7Connect.Cda.WrapperFactory.Content(wrapped().content);
      }
      private void propSetContent(HL7Connect.Cda.Content value)
      {
        wrapped().content = value.wrapped();
      }
      ///<summary>
      /// Nested Conten
      ///</summary>
      public HL7Connect.Cda.Content content { get { return propGetContent(); } set { propSetContent(value); } }

      ///<summary>
      /// A hard line brea
      ///</summary>
      private bool propGetBr()
      {
        return wrapped().br != 0;
      }
      private void propSetBr(bool value)
      {
        wrapped().br = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// A hard line brea
      ///</summary>
      public bool br { get { return propGetBr(); } set { propSetBr(value); } }

      ///<summary>
      /// Multimedi
      ///</summary>
      private HL7Connect.Cda.RenderMultiMedia propGetRenderMultiMedia()
      {
        return HL7Connect.Cda.WrapperFactory.RenderMultiMedia(wrapped().renderMultiMedia);
      }
      private void propSetRenderMultiMedia(HL7Connect.Cda.RenderMultiMedia value)
      {
        wrapped().renderMultiMedia = value.wrapped();
      }
      ///<summary>
      /// Multimedi
      ///</summary>
      public HL7Connect.Cda.RenderMultiMedia renderMultiMedia { get { return propGetRenderMultiMedia(); } set { propSetRenderMultiMedia(value); } }

    }

    ///<summary>
    /// Content model that allows text, footnotes, links, superscript and subscript text, line breaks, multimedia content, nested Content items, paragraphs, lists, and tables. The choice stereotype denotes that exactly one of the attributes (including inherited attributes) SHALL have a value. All the others must be null.
    ///</summary>
    public class CMGeneral : HL7Connect.Cda.CMContent
    {

      ///<summary>
      /// Create a Narrative CMGeneral
      ///</summary>
      public CMGeneral() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCMGeneral()) {} 

      internal CMGeneral(IsnCMGeneral com) : base(com) {} 

      internal new HCsnCMGeneral wrapped() { return (HCsnCMGeneral) com; }

      ///<summary>
      /// A paragraph of text and other CMContent content
      ///</summary>
      private HL7Connect.Cda.Paragraph propGetParagraph()
      {
        return HL7Connect.Cda.WrapperFactory.Paragraph(wrapped().paragraph);
      }
      private void propSetParagraph(HL7Connect.Cda.Paragraph value)
      {
        wrapped().paragraph = value.wrapped();
      }
      ///<summary>
      /// A paragraph of text and other CMContent content
      ///</summary>
      public HL7Connect.Cda.Paragraph paragraph { get { return propGetParagraph(); } set { propSetParagraph(value); } }

      ///<summary>
      /// List based content
      ///</summary>
      private HL7Connect.Cda.List propGetList()
      {
        return HL7Connect.Cda.WrapperFactory.List(wrapped().list);
      }
      private void propSetList(HL7Connect.Cda.List value)
      {
        wrapped().list = value.wrapped();
      }
      ///<summary>
      /// List based content
      ///</summary>
      public HL7Connect.Cda.List list { get { return propGetList(); } set { propSetList(value); } }

      ///<summary>
      /// Tabl
      ///</summary>
      private HL7Connect.Cda.Table propGetTable()
      {
        return HL7Connect.Cda.WrapperFactory.Table(wrapped().Table);
      }
      private void propSetTable(HL7Connect.Cda.Table value)
      {
        wrapped().Table = value.wrapped();
      }
      ///<summary>
      /// Tabl
      ///</summary>
      public HL7Connect.Cda.Table table { get { return propGetTable(); } set { propSetTable(value); } }

    }

    ///<summary>
    /// References multimedia content that is integral to the document, and serves to show where the referenced multimedia is to be rendered. The multi media content must be contained within the context of the document. 
    /// 
    ///  There is an optional caption, and contains a required referencedObject attribute (of type XML IDREFS), the values of which must equal the XML ID value(s) of ObservationMedia or RegionOfInterest CDA entries within the document context.
    ///</summary>
    public class RenderMultiMedia : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative RenderMultiMedia
      ///</summary>
      public RenderMultiMedia() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRenderMultiMedia()) {} 

      internal RenderMultiMedia(IsnRenderMultiMedia com) : base(com) {} 

      internal new HCsnRenderMultiMedia wrapped() { return (HCsnRenderMultiMedia) com; }

      ///<summary>
      /// An optional caption for the multimedia conten
      ///</summary>
      private HL7Connect.Cda.Caption propGetCaption()
      {
        return HL7Connect.Cda.WrapperFactory.Caption(wrapped().caption);
      }
      private void propSetCaption(HL7Connect.Cda.Caption value)
      {
        wrapped().caption = value.wrapped();
      }
      ///<summary>
      /// An optional caption for the multimedia conten
      ///</summary>
      public HL7Connect.Cda.Caption caption { get { return propGetCaption(); } set { propSetCaption(value); } }

      ///<summary>
      /// The references are to other identified objects within the document context.
      /// 
      ///  Refer to section A.2 for the meaning of the XMLIDREF stereotype.
      ///</summary>
      private IList<String> propGetReferencedObject()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().referencedObject);
      }
      ///<summary>
      /// The references are to other identified objects within the document context.
      /// 
      ///  Refer to section A.2 for the meaning of the XMLIDREF stereotype.
      ///</summary>
      public IList<String> referencedObject { get { return propGetReferencedObject(); } }

    }

    ///<summary>
    /// A hypertext reference to another document. These links are generally shown as hyperlinks that a user may activate when viewing the document.
    /// 
    ///   The link functionality provides a generic referencing mechanism, similar, but not identical, to the HTML anchor tag. It can be used to reference identifiers that are either internal or external to the document or the document context.  Multimedia that is integral to a document must be referenced by the renderMultiMedia element (see below). Multimedia that is simply referenced by the document and not an integral part of the document can by provided by a link. There is no requirement that a receiver render an internal or external link, or the target of an external lin
    ///</summary>
    public class LinkHtml : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative LinkHtml
      ///</summary>
      public LinkHtml() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newLinkHtml()) {} 

      internal LinkHtml(IsnLinkHtml com) : base(com) {} 

      internal new HCsnLinkHtml wrapped() { return (HCsnLinkHtml) com; }

      ///<summary>
      /// The linkHtml.name attribute is deprecated, because attributes of type XML ID provide an alternative and more consistent target for referencing. Following the conventions of HTML, an internal link is prefaced with the pound sign, as shown in the following example.
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      private void propSetName(string value)
      {
        wrapped().Name = value;
      }
      ///<summary>
      /// The linkHtml.name attribute is deprecated, because attributes of type XML ID provide an alternative and more consistent target for referencing. Following the conventions of HTML, an internal link is prefaced with the pound sign, as shown in the following example.
      ///</summary>
      public string name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// The URL that identifiers the target documen/object of the link. The target is an XML identifier either internal or external to the document.The context of use must clearly define the scope of resolution of the link. Following the conventions of HTML, an internal link ï¿½ usually a link within the scope of the context of the document - is prefaced with the pound sign
      ///</summary>
      private string propGetHref()
      {
        return wrapped().href;
      }
      private void propSetHref(string value)
      {
        wrapped().href = value;
      }
      ///<summary>
      /// The URL that identifiers the target documen/object of the link. The target is an XML identifier either internal or external to the document.The context of use must clearly define the scope of resolution of the link. Following the conventions of HTML, an internal link ï¿½ usually a link within the scope of the context of the document - is prefaced with the pound sign
      ///</summary>
      public string href { get { return propGetHref(); } set { propSetHref(value); } }

      ///<summary>
      /// This attribute describes the relationship from the current document to the anchor specified by the href attribute. The value of this attribute is a space-separated list of link types. 
      /// 
      ///  If populated, the value of this attribute SHALL be taken from one of these values listed in LinkType, taken from the HTML specification
      ///</summary>
      private string propGetRel()
      {
        return wrapped().rel;
      }
      private void propSetRel(string value)
      {
        wrapped().rel = value;
      }
      ///<summary>
      /// This attribute describes the relationship from the current document to the anchor specified by the href attribute. The value of this attribute is a space-separated list of link types. 
      /// 
      ///  If populated, the value of this attribute SHALL be taken from one of these values listed in LinkType, taken from the HTML specification
      ///</summary>
      public string rel { get { return propGetRel(); } set { propSetRel(value); } }

      ///<summary>
      /// This attribute is used to describe a reverse link [p.155] from the anchor specified by the href attribute to the current document. The value of this attribute is a space-separated list of link types.See above for valid value
      ///</summary>
      private string propGetRev()
      {
        return wrapped().rev;
      }
      private void propSetRev(string value)
      {
        wrapped().rev = value;
      }
      ///<summary>
      /// This attribute is used to describe a reverse link [p.155] from the anchor specified by the href attribute to the current document. The value of this attribute is a space-separated list of link types.See above for valid value
      ///</summary>
      public string rev { get { return propGetRev(); } set { propSetRev(value); } }

      ///<summary>
      /// This attribute offers advisory information about the element for which it is set. The title attribute has an additional role when used with a LINK element that designates an external style sheet. Please consult the HTML standard for additional information.
      /// 
      ///  Note: Values of the title attribute may be rendered by user agents in a variety of ways. For instance, visual browsers frequently display the title as a "tool tip" (a short message that appears when the pointing device pauses over an object). Audio user agents may speak the title information in a similar context. For example, setting the attribute on a link allows user agents (visual and non-visual) to tell users about the nature of the linked resource
      ///</summary>
      private string propGetTitle()
      {
        return wrapped().title;
      }
      private void propSetTitle(string value)
      {
        wrapped().title = value;
      }
      ///<summary>
      /// This attribute offers advisory information about the element for which it is set. The title attribute has an additional role when used with a LINK element that designates an external style sheet. Please consult the HTML standard for additional information.
      /// 
      ///  Note: Values of the title attribute may be rendered by user agents in a variety of ways. For instance, visual browsers frequently display the title as a "tool tip" (a short message that appears when the pointing device pauses over an object). Audio user agents may speak the title information in a similar context. For example, setting the attribute on a link allows user agents (visual and non-visual) to tell users about the nature of the linked resource
      ///</summary>
      public string title { get { return propGetTitle(); } set { propSetTitle(value); } }

      ///<summary>
      /// A series of parts that capture the content of the Link
      ///</summary>
      private HL7Connect.Cda.CMFootnotesList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMFootnotesList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the Link
      ///</summary>
      public HL7Connect.Cda.CMFootnotesList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// Indicates a footnote. The content contained within the Footnote is the content of the footnote. When the document is rendered, a link to the footnote is displayed inline with the flow of text adjacent to the footnote.
    /// 
    ///  Note: Receivers are required to interpret these elements when rendering by visually distinguishing footnoted text. The exact rendition is at the discretion of the recipient, and might include a mark at the location of the footnote with a hyperlink to the footnoted text, a simple demarcation (such as "This is the text [this is the footnote] that is being footnoted"), et
    ///</summary>
    public class Footnote : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative Footnote
      ///</summary>
      public Footnote() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newFootnote()) {} 

      internal Footnote(IsnFootnote com) : base(com) {} 

      internal new HCsnFootnote wrapped() { return (HCsnFootnote) com; }

      ///<summary>
      /// A series of parts that capture the content of the Footnote
      ///</summary>
      private HL7Connect.Cda.CMGeneralList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMGeneralList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the Footnote
      ///</summary>
      public HL7Connect.Cda.CMGeneralList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// Same functionality as a normal footnote, but the content model in the parts is restricted to the kind of content that can appear in a title
    ///</summary>
    public class TitleFootnote : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative TitleFootnote
      ///</summary>
      public TitleFootnote() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTitleFootnote()) {} 

      internal TitleFootnote(IsnTitleFootnote com) : base(com) {} 

      internal new HCsnTitleFootnote wrapped() { return (HCsnTitleFootnote) com; }

      ///<summary>
      /// A series of parts that capture the content of the Footnote
      ///</summary>
      private HL7Connect.Cda.CMTitleList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMTitleList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the Footnote
      ///</summary>
      public HL7Connect.Cda.CMTitleList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// A reference to an existing footnote within the document context. This may be used when the same footnote is being used multiple times. The value of the footnoteRef.IDREF must be an footnote.ID value in the same document
    ///</summary>
    public class FootnoteRef : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative FootnoteRef
      ///</summary>
      public FootnoteRef() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newFootnoteRef()) {} 

      internal FootnoteRef(IsnFootnoteRef com) : base(com) {} 

      internal new HCsnFootnoteRef wrapped() { return (HCsnFootnoteRef) com; }

      ///<summary>
      /// The identity of the referenced footnote.
      /// 
      ///  Refer to section A.2 for the meaning of the XMLIDREF stereotype
      ///</summary>
      private string propGetIDREF()
      {
        return wrapped().IDREF;
      }
      private void propSetIDREF(string value)
      {
        wrapped().IDREF = value;
      }
      ///<summary>
      /// The identity of the referenced footnote.
      /// 
      ///  Refer to section A.2 for the meaning of the XMLIDREF stereotype
      ///</summary>
      public string IDREF { get { return propGetIDREF(); } set { propSetIDREF(value); } }

    }

    ///<summary>
    /// A label for a paragraph, list, list item, table, or table cell. It may also be used within RenderMultiMedia to indicate a label for referenced ObservationMedia and RegionOfInterest entries. A Caption contains plain text and may contain links and footnotes.
    /// 
    ///   If a caption is defined, it SHALL be rendered, and SHALL be presented before any the element with which it is associated
    ///</summary>
    public class Caption : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative Caption
      ///</summary>
      public Caption() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCaption()) {} 

      internal Caption(IsnCaption com) : base(com) {} 

      internal new HCsnCaption wrapped() { return (HCsnCaption) com; }

      ///<summary>
      /// A series of parts that capture the content of the Caption
      ///</summary>
      private HL7Connect.Cda.CMInlineList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMInlineList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the Caption
      ///</summary>
      public HL7Connect.Cda.CMInlineList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// Used to wrap a string of text so that it can be explicitly referenced, or so that it can suggest rendering characteristics. Content can be nested recursively, which enables wrapping a string of plain text down to as small a chunk as desired. 
    /// 
    ///  Content has an optional identifier that can serve as the target of a reference. This identifier, represented as an XML ID attribute, must be unique within the document context. The originalText attribute of a datatype defined in this specification may make explicit reference to the content using the identifier, thereby indicating the original text associated with the datatype.
    ///</summary>
    public class Content : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative Content
      ///</summary>
      public Content() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newContent()) {} 

      internal Content(IsnContent com) : base(com) {} 

      internal new HCsnContent wrapped() { return (HCsnContent) com; }

      ///<summary>
      /// can be used to indicate narrative changes from the last version of a CDA document. The attribute is limited to a single generation, in that it only reflects the changes from the preceding version of a document. Receivers SHALL interpret the "revised" attribute when rendering by visually distinguishing or suppressing deleted narrative.
      /// 
      ///  Note:  If applied, this attribute SHALL be used in conjunction with appropriate document version tracking as defined in the applicable conformance statement for the document context  -- Revised status options for a Content element rvnullinsert : Insert : This content was inserted in this revision of the documentdelete : Delete : This content was deleted in this revision of the document
      ///</summary>
      private TsnRevised propGetRevised()
      {
        return wrapped().revised;
      }
      private void propSetRevised(TsnRevised value)
      {
        wrapped().revised = value;
      }
      ///<summary>
      /// can be used to indicate narrative changes from the last version of a CDA document. The attribute is limited to a single generation, in that it only reflects the changes from the preceding version of a document. Receivers SHALL interpret the "revised" attribute when rendering by visually distinguishing or suppressing deleted narrative.
      /// 
      ///  Note:  If applied, this attribute SHALL be used in conjunction with appropriate document version tracking as defined in the applicable conformance statement for the document context  -- Revised status options for a Content element rvnullinsert : Insert : This content was inserted in this revision of the documentdelete : Delete : This content was deleted in this revision of the document
      ///</summary>
      public TsnRevised revised { get { return propGetRevised(); } set { propSetRevised(value); } }

      ///<summary>
      /// A series of parts that capture the content of the Content
      ///</summary>
      private HL7Connect.Cda.CMContentList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMContentList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the Content
      ///</summary>
      public HL7Connect.Cda.CMContentList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// An abstract ancestor for all types that have captions.
    /// 
    ///   If a caption is defined, it SHALL be rendered, and SHALL be presented before any the element with which it is associate
    ///</summary>
    public class Captioned : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative Captioned
      ///</summary>
      public Captioned() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCaptioned()) {} 

      internal Captioned(IsnCaptioned com) : base(com) {} 

      internal new HCsnCaptioned wrapped() { return (HCsnCaptioned) com; }

      ///<summary>
      /// The contents of the Content.
      /// 
      ///  Note: Refer to section A.2 for the meaning of the Anonymous stereotype
      ///</summary>
      private HL7Connect.Cda.Caption propGetCaption()
      {
        return HL7Connect.Cda.WrapperFactory.Caption(wrapped().caption);
      }
      private void propSetCaption(HL7Connect.Cda.Caption value)
      {
        wrapped().caption = value.wrapped();
      }
      ///<summary>
      /// The contents of the Content.
      /// 
      ///  Note: Refer to section A.2 for the meaning of the Anonymous stereotype
      ///</summary>
      public HL7Connect.Cda.Caption caption { get { return propGetCaption(); } set { propSetCaption(value); } }

    }

    ///<summary>
    /// Similar to the HTML paragraph, which allows blocks of narrative to be broken up into logically consistent structures
    ///</summary>
    public class Paragraph : HL7Connect.Cda.Captioned
    {

      ///<summary>
      /// Create a Narrative Paragraph
      ///</summary>
      public Paragraph() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newParagraph()) {} 

      internal Paragraph(IsnParagraph com) : base(com) {} 

      internal new HCsnParagraph wrapped() { return (HCsnParagraph) com; }

      ///<summary>
      /// A series of parts that capture the content of the paragraph
      ///</summary>
      private HL7Connect.Cda.CMContentList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMContentList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the paragraph
      ///</summary>
      public HL7Connect.Cda.CMContentList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// An item in a list.
    ///</summary>
    public class Item : HL7Connect.Cda.Captioned
    {

      ///<summary>
      /// Create a Narrative Item
      ///</summary>
      public Item() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newItem()) {} 

      internal Item(IsnItem com) : base(com) {} 

      internal new HCsnItem wrapped() { return (HCsnItem) com; }

      ///<summary>
      /// A series of parts that capture the content of the item
      ///</summary>
      private HL7Connect.Cda.CMGeneralList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMGeneralList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the item
      ///</summary>
      public HL7Connect.Cda.CMGeneralList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// Similar to an HTML list. There is an optional caption, and one or more items. The list must be ordered or not ordered; this must always be known,
    ///</summary>
    public class List : HL7Connect.Cda.Captioned
    {

      ///<summary>
      /// Create a Narrative List
      ///</summary>
      public List() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newList()) {} 

      internal List(IsnList com) : base(com) {} 

      internal new HCsnList wrapped() { return (HCsnList) com; }

      ///<summary>
      /// Whether the list is ordered or unordered. 
      /// 
      ///  If populated, the value of this attribute SHALL be taken from one of these values:  StrucDoc.ListType Enumeration 1 ordered ordered The list is ordered 1 unordered unordered The list is not ordered  The default value is unordered.  Note: Unordered lists are typically rendered with bullets, whereas ordered lists are typically rendered with numbers, although this is not a requirement. -- Type of list lnullordered : Ordered : The list is orderedunordered : Unordered : The list is not ordered
      ///</summary>
      private TsnListType propGetListType()
      {
        return wrapped().listType;
      }
      private void propSetListType(TsnListType value)
      {
        wrapped().listType = value;
      }
      ///<summary>
      /// Whether the list is ordered or unordered. 
      /// 
      ///  If populated, the value of this attribute SHALL be taken from one of these values:  StrucDoc.ListType Enumeration 1 ordered ordered The list is ordered 1 unordered unordered The list is not ordered  The default value is unordered.  Note: Unordered lists are typically rendered with bullets, whereas ordered lists are typically rendered with numbers, although this is not a requirement. -- Type of list lnullordered : Ordered : The list is orderedunordered : Unordered : The list is not ordered
      ///</summary>
      public TsnListType listType { get { return propGetListType(); } set { propSetListType(value); } }

      ///<summary>
      /// A series of items that capture the content of the list
      ///</summary>
      private HL7Connect.Cda.ItemList propGetItem()
      {
        return HL7Connect.Cda.WrapperFactory.ItemList(wrapped().Item);
      }
      ///<summary>
      /// A series of items that capture the content of the list
      ///</summary>
      public HL7Connect.Cda.ItemList item { get { return propGetItem(); } }

    }

    ///<summary>
    /// An abstract container for table items that may specify table layout details such as alignment. 
    /// 
    ///   Any attributes applied to the table item also apply to any other nested table items unless specifically overridden
    ///</summary>
    public class TableItem : HL7Connect.Cda.SNBase
    {

      ///<summary>
      /// Create a Narrative TableItem
      ///</summary>
      public TableItem() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTableItem()) {} 

      internal TableItem(IsnTableItem com) : base(com) {} 

      internal new HCsnTableItem wrapped() { return (HCsnTableItem) com; }

      ///<summary>
      /// The text alignment that applies within the cell
      /// 
      ///   The default value is left. -- Alignment of paragraph inside a table cell. anullleft : Left : The content is left alignedcenter : Center : The content is center alignedright : Right : The content is right alignedjustify : Justify : The content is justifiedachar
      ///</summary>
      private TsnAlign propGetAlign()
      {
        return wrapped().align;
      }
      private void propSetAlign(TsnAlign value)
      {
        wrapped().align = value;
      }
      ///<summary>
      /// The text alignment that applies within the cell
      /// 
      ///   The default value is left. -- Alignment of paragraph inside a table cell. anullleft : Left : The content is left alignedcenter : Center : The content is center alignedright : Right : The content is right alignedjustify : Justify : The content is justifiedachar
      ///</summary>
      public TsnAlign align { get { return propGetAlign(); } set { propSetAlign(value); } }

      ///<summary>
      /// The character on which to align cells if align is set to char. The default value for the CHAR attribute is the decimal point of the current language--a period in English
      ///</summary>
      private string propGetChar_()
      {
        return wrapped().char_;
      }
      private void propSetChar_(string value)
      {
        wrapped().char_ = value;
      }
      ///<summary>
      /// The character on which to align cells if align is set to char. The default value for the CHAR attribute is the decimal point of the current language--a period in English
      ///</summary>
      public string char_ { get { return propGetChar_(); } set { propSetChar_(value); } }

      ///<summary>
      /// When present, this attribute specifies the offset to the first occurrence of the alignment character on each line. If a line doesnï¿½t include the alignment character, it should be horizontally shifted to end at the alignment position. Information Processing Entities SHALL not be required to support this attribut
      ///</summary>
      private string propGetCharoff()
      {
        return wrapped().charoff;
      }
      private void propSetCharoff(string value)
      {
        wrapped().charoff = value;
      }
      ///<summary>
      /// When present, this attribute specifies the offset to the first occurrence of the alignment character on each line. If a line doesnï¿½t include the alignment character, it should be horizontally shifted to end at the alignment position. Information Processing Entities SHALL not be required to support this attribut
      ///</summary>
      public string charoff { get { return propGetCharoff(); } set { propSetCharoff(value); } }

      ///<summary>
      /// The vertical alignment that applies within the cell
      /// 
      ///   The default value is top. -- Vertical alignment of content inside table cells vnulltop : Top : The content is aligned with the top of the cell as shown in the caption column.middle : Middle : The content is aligned with the bottom of the cell as shown in the caption column.bottom : Bottom : The content is aligned with the bottom of the cell as shown in the caption column.baseline : Baseline : All cells in the same row as a cell whose valign attribute has this value should have their textual data positioned so that the first text line occurs on a baseline common to all cells in the row. This constraint does not apply to subsequent text lines in these cells
      ///</summary>
      private TsnVAlign propGetValign()
      {
        return wrapped().valign;
      }
      private void propSetValign(TsnVAlign value)
      {
        wrapped().valign = value;
      }
      ///<summary>
      /// The vertical alignment that applies within the cell
      /// 
      ///   The default value is top. -- Vertical alignment of content inside table cells vnulltop : Top : The content is aligned with the top of the cell as shown in the caption column.middle : Middle : The content is aligned with the bottom of the cell as shown in the caption column.bottom : Bottom : The content is aligned with the bottom of the cell as shown in the caption column.baseline : Baseline : All cells in the same row as a cell whose valign attribute has this value should have their textual data positioned so that the first text line occurs on a baseline common to all cells in the row. This constraint does not apply to subsequent text lines in these cells
      ///</summary>
      public TsnVAlign valign { get { return propGetValign(); } set { propSetValign(value); } }

    }

    ///<summary>
    /// Abstract ancestor for common properties of col and colgroup.
    ///</summary>
    public class ColItem : HL7Connect.Cda.TableItem
    {

      ///<summary>
      /// Create a Narrative ColItem
      ///</summary>
      public ColItem() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newColItem()) {} 

      internal ColItem(IsnColItem com) : base(com) {} 

      internal new HCsnColItem wrapped() { return (HCsnColItem) com; }

      ///<summary>
      /// The number of columns this column definition spans.. Default value is 1
      ///</summary>
      private int propGetSpan()
      {
        return wrapped().span;
      }
      private void propSetSpan(int value)
      {
        wrapped().span = value;
      }
      ///<summary>
      /// The number of columns this column definition spans.. Default value is 1
      ///</summary>
      public int span { get { return propGetSpan(); } set { propSetSpan(value); } }

      ///<summary>
      /// The length for the colum
      ///</summary>
      private string propGetWidth()
      {
        return wrapped().width;
      }
      private void propSetWidth(string value)
      {
        wrapped().width = value;
      }
      ///<summary>
      /// The length for the colum
      ///</summary>
      public string width { get { return propGetWidth(); } set { propSetWidth(value); } }

    }

    ///<summary>
    /// Applies a consistent style to every cell in a column.
    ///</summary>
    public class Col : HL7Connect.Cda.ColItem
    {

      ///<summary>
      /// Create a Narrative Col
      ///</summary>
      public Col() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCol()) {} 

      internal Col(IsnCol com) : base(com) {} 

      internal new HCsnCol wrapped() { return (HCsnCol) com; }

    }

    ///<summary>
    /// Applies a consistent style to every cell in a group of columns.
    ///</summary>
    public class ColGroup : HL7Connect.Cda.ColItem
    {

      ///<summary>
      /// Create a Narrative ColGroup
      ///</summary>
      public ColGroup() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newColGroup()) {} 

      internal ColGroup(IsnColGroup com) : base(com) {} 

      internal new HCsnColGroup wrapped() { return (HCsnColGroup) com; }

      ///<summary>
      /// A series of parts that capture the conten of the ColGroup
      ///</summary>
      private HL7Connect.Cda.ColList propGetCol()
      {
        return HL7Connect.Cda.WrapperFactory.ColList(wrapped().col);
      }
      ///<summary>
      /// A series of parts that capture the conten of the ColGroup
      ///</summary>
      public HL7Connect.Cda.ColList col { get { return propGetCol(); } }

    }

    ///<summary>
    /// A cell in a table ? may be either a normal cell or a header cell
    ///</summary>
    public class TCell : HL7Connect.Cda.TableItem
    {

      ///<summary>
      /// Create a Narrative TCell
      ///</summary>
      public TCell() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTCell()) {} 

      internal TCell(IsnTCell com) : base(com) {} 

      internal new HCsnTCell wrapped() { return (HCsnTCell) com; }

      ///<summary>
      /// This attribute should be used to provide an abbreviated form of the cellï¿½s content, and may be rendered by user agents when appropriate in place of the cellï¿½s content. Abbreviated names should be short since user agents may render them repeatedl
      ///</summary>
      private string propGetAbbr()
      {
        return wrapped().abbr;
      }
      private void propSetAbbr(string value)
      {
        wrapped().abbr = value;
      }
      ///<summary>
      /// This attribute should be used to provide an abbreviated form of the cellï¿½s content, and may be rendered by user agents when appropriate in place of the cellï¿½s content. Abbreviated names should be short since user agents may render them repeatedl
      ///</summary>
      public string abbr { get { return propGetAbbr(); } set { propSetAbbr(value); } }

      ///<summary>
      /// This attribute may be used to place a cell into conceptual categories that can be considered to form axes in an n-dimensional space. User agents may give users access to these categories (e.g., the user may query the user agent for all cells that belong to certain categories, the user agent may present a table in the form of a table of contents, etc.). Please consult the HTML specification for more information. The value of this attribute is a comma-separated list of category name
      ///</summary>
      private string propGetAxis()
      {
        return wrapped().axis;
      }
      private void propSetAxis(string value)
      {
        wrapped().axis = value;
      }
      ///<summary>
      /// This attribute may be used to place a cell into conceptual categories that can be considered to form axes in an n-dimensional space. User agents may give users access to these categories (e.g., the user may query the user agent for all cells that belong to certain categories, the user agent may present a table in the form of a table of contents, etc.). Please consult the HTML specification for more information. The value of this attribute is a comma-separated list of category name
      ///</summary>
      public string axis { get { return propGetAxis(); } set { propSetAxis(value); } }

      ///<summary>
      /// This attribute specifies the list of header cells that provide header information for the current data cell. The value of this attribute is a space-separated list of ID references to header cells; those cells must be named by setting their id attribute. Authors generally use the headers attribute to help non-visual user agents render header information about data cells (e.g., header information is spoken prior to the cell data), but the attribute may also be used in conjunction with style sheets. See also the scope attribute.
      /// 
      ///  Refer to section A.2 for the meaning of the XMLIDREF stereotype
      ///</summary>
      private IList<String> propGetHeaders()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().headers);
      }
      ///<summary>
      /// This attribute specifies the list of header cells that provide header information for the current data cell. The value of this attribute is a space-separated list of ID references to header cells; those cells must be named by setting their id attribute. Authors generally use the headers attribute to help non-visual user agents render header information about data cells (e.g., header information is spoken prior to the cell data), but the attribute may also be used in conjunction with style sheets. See also the scope attribute.
      /// 
      ///  Refer to section A.2 for the meaning of the XMLIDREF stereotype
      ///</summary>
      public IList<String> headers { get { return propGetHeaders(); } }

      ///<summary>
      /// This attribute specifies the set of data cells for which the current header cell provides header information. This attribute may be used in place of the headers attribute, particularly for simple tables.
      /// 
      ///  This attribute SHALL only be populated for header cells.  The default value is Col  -- Scope of a table cell cnull1row : Row : The current cell provides header information for the rest of the row that contains itcol : Col : The current cell provides header information for the rest of the column that contains it.rowgroup : Rowgroup : The header cell provides header information for the rest of the row group [p.116] that contains it.colgroup : Colgroup : The header cell provides header information for the rest of the column group [p.118] that contains it.
      ///</summary>
      private TsnCellScope propGetScope()
      {
        return wrapped().scope;
      }
      private void propSetScope(TsnCellScope value)
      {
        wrapped().scope = value;
      }
      ///<summary>
      /// This attribute specifies the set of data cells for which the current header cell provides header information. This attribute may be used in place of the headers attribute, particularly for simple tables.
      /// 
      ///  This attribute SHALL only be populated for header cells.  The default value is Col  -- Scope of a table cell cnull1row : Row : The current cell provides header information for the rest of the row that contains itcol : Col : The current cell provides header information for the rest of the column that contains it.rowgroup : Rowgroup : The header cell provides header information for the rest of the row group [p.116] that contains it.colgroup : Colgroup : The header cell provides header information for the rest of the column group [p.118] that contains it.
      ///</summary>
      public TsnCellScope scope { get { return propGetScope(); } set { propSetScope(value); } }

      ///<summary>
      /// The number of rows that this cell spans. Default value is
      ///</summary>
      private int propGetRowspan()
      {
        return wrapped().rowspan;
      }
      private void propSetRowspan(int value)
      {
        wrapped().rowspan = value;
      }
      ///<summary>
      /// The number of rows that this cell spans. Default value is
      ///</summary>
      public int rowspan { get { return propGetRowspan(); } set { propSetRowspan(value); } }

      ///<summary>
      /// The number of columns that this cell spans. Default value is
      ///</summary>
      private int propGetColspan()
      {
        return wrapped().colspan;
      }
      private void propSetColspan(int value)
      {
        wrapped().colspan = value;
      }
      ///<summary>
      /// The number of columns that this cell spans. Default value is
      ///</summary>
      public int colspan { get { return propGetColspan(); } set { propSetColspan(value); } }

      ///<summary>
      /// A series of parts that capture the content of the cell
      ///</summary>
      private HL7Connect.Cda.CMGeneralList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.CMGeneralList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the cell
      ///</summary>
      public HL7Connect.Cda.CMGeneralList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// &nbsp
    ///</summary>
    public class TRowPart : HL7Connect.Cda.Base
    {

      ///<summary>
      /// Create a Narrative TRowPart
      ///</summary>
      public TRowPart() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTRowPart()) {} 

      internal TRowPart(IsnTRowPart com) : base(com) {} 

      internal new HCsnTRowPart wrapped() { return (HCsnTRowPart) com; }

      ///<summary>
      /// A header cell in a table. 
      /// 
      ///  Note: Header cells are sometimes rendered differently, such as using bold, and may be repeated after page breaks.
      ///</summary>
      private HL7Connect.Cda.TCell propGetTh()
      {
        return HL7Connect.Cda.WrapperFactory.TCell(wrapped().th);
      }
      private void propSetTh(HL7Connect.Cda.TCell value)
      {
        wrapped().th = value.wrapped();
      }
      ///<summary>
      /// A header cell in a table. 
      /// 
      ///  Note: Header cells are sometimes rendered differently, such as using bold, and may be repeated after page breaks.
      ///</summary>
      public HL7Connect.Cda.TCell th { get { return propGetTh(); } set { propSetTh(value); } }

      ///<summary>
      /// A cell in a tabl
      ///</summary>
      private HL7Connect.Cda.TCell propGetTd()
      {
        return HL7Connect.Cda.WrapperFactory.TCell(wrapped().td);
      }
      private void propSetTd(HL7Connect.Cda.TCell value)
      {
        wrapped().td = value.wrapped();
      }
      ///<summary>
      /// A cell in a tabl
      ///</summary>
      public HL7Connect.Cda.TCell td { get { return propGetTd(); } set { propSetTd(value); } }

    }

    ///<summary>
    /// A Row in a table
    ///</summary>
    public class TRow : HL7Connect.Cda.TableItem
    {

      ///<summary>
      /// Create a Narrative TRow
      ///</summary>
      public TRow() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTRow()) {} 

      internal TRow(IsnTRow com) : base(com) {} 

      internal new HCsnTRow wrapped() { return (HCsnTRow) com; }

      ///<summary>
      /// A series of parts that capture the content of the row
      ///</summary>
      private HL7Connect.Cda.TRowPartList propGetParts()
      {
        return HL7Connect.Cda.WrapperFactory.TRowPartList(wrapped().parts);
      }
      ///<summary>
      /// A series of parts that capture the content of the row
      ///</summary>
      public HL7Connect.Cda.TRowPartList parts { get { return propGetParts(); } }

    }

    ///<summary>
    /// A grop of rows ? may be used to associate consistent styling across a group of rows.
    ///</summary>
    public class TRowGroup : HL7Connect.Cda.TableItem
    {

      ///<summary>
      /// Create a Narrative TRowGroup
      ///</summary>
      public TRowGroup() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTRowGroup()) {} 

      internal TRowGroup(IsnTRowGroup com) : base(com) {} 

      internal new HCsnTRowGroup wrapped() { return (HCsnTRowGroup) com; }

      ///<summary>
      /// The rows in the grou
      ///</summary>
      private HL7Connect.Cda.TRowList propGetTr()
      {
        return HL7Connect.Cda.WrapperFactory.TRowList(wrapped().tr);
      }
      ///<summary>
      /// The rows in the grou
      ///</summary>
      public HL7Connect.Cda.TRowList tr { get { return propGetTr(); } }

    }

    ///<summary>
    /// A table. May have a caption, and SHALL have at least one row. A table may have optional header and footer rows. All rows are defined in groups. A table may also have col and colgroup elements to define styles for columns.
    ///</summary>
    public class Table : HL7Connect.Cda.Captioned
    {

      ///<summary>
      /// Create a Narrative Table
      ///</summary>
      public Table() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newTable()) {} 

      internal Table(IsnTable com) : base(com) {} 

      internal new HCsnTable wrapped() { return (HCsnTable) com; }

      ///<summary>
      /// A series of cols that define columns in the table
      ///</summary>
      private HL7Connect.Cda.ColList propGetCol()
      {
        return HL7Connect.Cda.WrapperFactory.ColList(wrapped().col);
      }
      ///<summary>
      /// A series of cols that define columns in the table
      ///</summary>
      public HL7Connect.Cda.ColList col { get { return propGetCol(); } }

      ///<summary>
      /// A series of column groups that define columns in the table
      ///</summary>
      private HL7Connect.Cda.ColGroupList propGetColgroup()
      {
        return HL7Connect.Cda.WrapperFactory.ColGroupList(wrapped().colgroup);
      }
      ///<summary>
      /// A series of column groups that define columns in the table
      ///</summary>
      public HL7Connect.Cda.ColGroupList colgroup { get { return propGetColgroup(); } }

      ///<summary>
      /// The header of the table
      ///</summary>
      private HL7Connect.Cda.TRowGroup propGetThead()
      {
        return HL7Connect.Cda.WrapperFactory.TRowGroup(wrapped().thead);
      }
      private void propSetThead(HL7Connect.Cda.TRowGroup value)
      {
        wrapped().thead = value.wrapped();
      }
      ///<summary>
      /// The header of the table
      ///</summary>
      public HL7Connect.Cda.TRowGroup thead { get { return propGetThead(); } set { propSetThead(value); } }

      ///<summary>
      /// The footer of the table
      ///</summary>
      private HL7Connect.Cda.TRowGroup propGetTfoot()
      {
        return HL7Connect.Cda.WrapperFactory.TRowGroup(wrapped().tfoot);
      }
      private void propSetTfoot(HL7Connect.Cda.TRowGroup value)
      {
        wrapped().tfoot = value.wrapped();
      }
      ///<summary>
      /// The footer of the table
      ///</summary>
      public HL7Connect.Cda.TRowGroup tfoot { get { return propGetTfoot(); } set { propSetTfoot(value); } }

      ///<summary>
      /// The body of the table
      ///</summary>
      private HL7Connect.Cda.TRowGroupList propGetTbody()
      {
        return HL7Connect.Cda.WrapperFactory.TRowGroupList(wrapped().tbody);
      }
      ///<summary>
      /// The body of the table
      ///</summary>
      public HL7Connect.Cda.TRowGroupList tbody { get { return propGetTbody(); } }

      ///<summary>
      /// This attribute provides a summary of the tableï¿½s purpose and structure for user agents rendering to non-visual media such as speech and Braille. This is different from the caption in that it must be plain text, and it is usually longe
      ///</summary>
      private string propGetSummary()
      {
        return wrapped().summary;
      }
      private void propSetSummary(string value)
      {
        wrapped().summary = value;
      }
      ///<summary>
      /// This attribute provides a summary of the tableï¿½s purpose and structure for user agents rendering to non-visual media such as speech and Braille. This is different from the caption in that it must be plain text, and it is usually longe
      ///</summary>
      public string summary { get { return propGetSummary(); } set { propSetSummary(value); } }

      ///<summary>
      /// This attribute specifies the desired width of the entire table and is intended for visual user agents. 
      /// 
      ///   The rules described in the html specification for table width calculations apply to the tables described here
      ///</summary>
      private string propGetWidth()
      {
        return wrapped().width;
      }
      private void propSetWidth(string value)
      {
        wrapped().width = value;
      }
      ///<summary>
      /// This attribute specifies the desired width of the entire table and is intended for visual user agents. 
      /// 
      ///   The rules described in the html specification for table width calculations apply to the tables described here
      ///</summary>
      public string width { get { return propGetWidth(); } set { propSetWidth(value); } }

      ///<summary>
      /// The width of the borde
      ///</summary>
      private string propGetBorder()
      {
        return wrapped().border;
      }
      private void propSetBorder(string value)
      {
        wrapped().border = value;
      }
      ///<summary>
      /// The width of the borde
      ///</summary>
      public string border { get { return propGetBorder(); } set { propSetBorder(value); } }

      ///<summary>
      /// This attribute specifies which sides of the frame  surrounding a table will be visible (i.e. which borders are visible). -- Frame - kind of borders - that applies to a table 
      /// 
      /// fnullfvoidabove : Above : The top side onlybelow : Below : The bottom side onlyhsides : Hsides : The right and left sides onlylhs : lhs : The left-hand side onlyrhs : rhs : The right-hand side onlyvsides : VSides : The top and bottom sides onlybox : Box : All four sidesborder : Border : All four sides
      ///</summary>
      private TsnFrame propGetFrame()
      {
        return wrapped().frame;
      }
      private void propSetFrame(TsnFrame value)
      {
        wrapped().frame = value;
      }
      ///<summary>
      /// This attribute specifies which sides of the frame  surrounding a table will be visible (i.e. which borders are visible). -- Frame - kind of borders - that applies to a table 
      /// 
      /// fnullfvoidabove : Above : The top side onlybelow : Below : The bottom side onlyhsides : Hsides : The right and left sides onlylhs : lhs : The left-hand side onlyrhs : rhs : The right-hand side onlyvsides : VSides : The top and bottom sides onlybox : Box : All four sidesborder : Border : All four sides
      ///</summary>
      public TsnFrame frame { get { return propGetFrame(); } set { propSetFrame(value); } }

      ///<summary>
      /// This attribute specifies which rules (i.e. borders) will appear between cells within a table. The rendering of rules is user agent dependent -- How Rules (lines) apply to table elements 
      /// 
      /// rnullnone : None : No rules.groups : Groups : Rules will appear between row groups  and column onlyrows : Rows : Rules will appear between rows onlycols : Cols : Rules will appear between columns onlyall : All : Rules will appear between all rows and columns
      ///</summary>
      private TsnRules propGetRules()
      {
        return wrapped().rules;
      }
      private void propSetRules(TsnRules value)
      {
        wrapped().rules = value;
      }
      ///<summary>
      /// This attribute specifies which rules (i.e. borders) will appear between cells within a table. The rendering of rules is user agent dependent -- How Rules (lines) apply to table elements 
      /// 
      /// rnullnone : None : No rules.groups : Groups : Rules will appear between row groups  and column onlyrows : Rows : Rules will appear between rows onlycols : Cols : Rules will appear between columns onlyall : All : Rules will appear between all rows and columns
      ///</summary>
      public TsnRules rules { get { return propGetRules(); } set { propSetRules(value); } }

      ///<summary>
      /// This attribute specifies how much space the user agent should leave between the left side of the table and the left-hand side of the leftmost column, the top of the table and the top side of the topmost row, and so on for the right and bottom of the table. The attribute also specifies the amount of space to leave between cells
      ///</summary>
      private string propGetCellspacing()
      {
        return wrapped().cellspacing;
      }
      private void propSetCellspacing(string value)
      {
        wrapped().cellspacing = value;
      }
      ///<summary>
      /// This attribute specifies how much space the user agent should leave between the left side of the table and the left-hand side of the leftmost column, the top of the table and the top side of the topmost row, and so on for the right and bottom of the table. The attribute also specifies the amount of space to leave between cells
      ///</summary>
      public string cellspacing { get { return propGetCellspacing(); } set { propSetCellspacing(value); } }

      ///<summary>
      /// This attribute specifies the amount of space between the border of the cell and its contents. If the value of this attribute is a pixel length, all four margins should be this distance from the contents. If the value of the attribute is a percentage length, the top and bottom margins should be equally separated from the content based on a percentage of the available vertical space, and the left and right margins should be equally separated from the content based on a percentage of the available horizontal space.
      /// 
      ///  Note: consult the HTML specification for further information
      ///</summary>
      private string propGetCellpadding()
      {
        return wrapped().cellpadding;
      }
      private void propSetCellpadding(string value)
      {
        wrapped().cellpadding = value;
      }
      ///<summary>
      /// This attribute specifies the amount of space between the border of the cell and its contents. If the value of this attribute is a pixel length, all four margins should be this distance from the contents. If the value of the attribute is a percentage length, the top and bottom margins should be equally separated from the content based on a percentage of the available vertical space, and the left and right margins should be equally separated from the content based on a percentage of the available horizontal space.
      /// 
      ///  Note: consult the HTML specification for further information
      ///</summary>
      public string cellpadding { get { return propGetCellpadding(); } set { propSetCellpadding(value); } }

    }

    public class CMGeneralList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CMGeneral>
    {
      public CMGeneralList(IsnCMGeneralList com) : base(com) {}
      internal new HCsnCMGeneralList wrapped() { return (HCsnCMGeneralList) com; }
  
      public CMGeneral this[int index]
      {
        get { return new CMGeneral(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CMGeneral item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CMGeneral Append()
      {
        return new CMGeneral(wrapped().Append());
      }
  
      public void Insert(int index, CMGeneral item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CMGeneral item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CMGeneral item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CMGeneral[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new CMGeneral(wrapped().Item(i));
      }
  
      public bool Remove(CMGeneral item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class CMGeneralListEnumerator : IEnumerator<CMGeneral>
      {
        private IsnCMGeneralList com;
        int index = -1;
  
        public CMGeneralListEnumerator(IsnCMGeneralList com)
        {
          this.com = com;
        }
  
        public CMGeneral Current { get { return new CMGeneral(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new CMGeneral(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CMGeneral> GetEnumerator()
      {
        return new CMGeneralListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new CMGeneralListEnumerator(wrapped());
      }
  
    }
  
    public class CMTitleList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CMTitle>
    {
      public CMTitleList(IsnCMTitleList com) : base(com) {}
      internal new HCsnCMTitleList wrapped() { return (HCsnCMTitleList) com; }
  
      public CMTitle this[int index]
      {
        get { return new CMTitle(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CMTitle item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CMTitle Append()
      {
        return new CMTitle(wrapped().Append());
      }
  
      public void Insert(int index, CMTitle item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CMTitle item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CMTitle item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CMTitle[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new CMTitle(wrapped().Item(i));
      }
  
      public bool Remove(CMTitle item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class CMTitleListEnumerator : IEnumerator<CMTitle>
      {
        private IsnCMTitleList com;
        int index = -1;
  
        public CMTitleListEnumerator(IsnCMTitleList com)
        {
          this.com = com;
        }
  
        public CMTitle Current { get { return new CMTitle(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new CMTitle(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CMTitle> GetEnumerator()
      {
        return new CMTitleListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new CMTitleListEnumerator(wrapped());
      }
  
    }
  
    public class CMFootnotesList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CMFootnotes>
    {
      public CMFootnotesList(IsnCMFootnotesList com) : base(com) {}
      internal new HCsnCMFootnotesList wrapped() { return (HCsnCMFootnotesList) com; }
  
      public CMFootnotes this[int index]
      {
        get { return (CMFootnotes) HL7Connect.Cda.WrapperFactory.CMFootnotes(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CMFootnotes item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CMFootnotes Append()
      {
        return (CMFootnotes) HL7Connect.Cda.WrapperFactory.CMFootnotes(wrapped().Append());
      }
  
      public void Insert(int index, CMFootnotes item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CMFootnotes item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CMFootnotes item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CMFootnotes[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (CMFootnotes) HL7Connect.Cda.WrapperFactory.CMFootnotes(wrapped().Item(i));
      }
  
      public bool Remove(CMFootnotes item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class CMFootnotesListEnumerator : IEnumerator<CMFootnotes>
      {
        private IsnCMFootnotesList com;
        int index = -1;
  
        public CMFootnotesListEnumerator(IsnCMFootnotesList com)
        {
          this.com = com;
        }
  
        public CMFootnotes Current { get { return (CMFootnotes) HL7Connect.Cda.WrapperFactory.CMFootnotes(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (CMFootnotes) HL7Connect.Cda.WrapperFactory.CMFootnotes(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CMFootnotes> GetEnumerator()
      {
        return new CMFootnotesListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new CMFootnotesListEnumerator(wrapped());
      }
  
    }
  
    public class CMInlineList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CMInline>
    {
      public CMInlineList(IsnCMInlineList com) : base(com) {}
      internal new HCsnCMInlineList wrapped() { return (HCsnCMInlineList) com; }
  
      public CMInline this[int index]
      {
        get { return (CMInline) HL7Connect.Cda.WrapperFactory.CMInline(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CMInline item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CMInline Append()
      {
        return (CMInline) HL7Connect.Cda.WrapperFactory.CMInline(wrapped().Append());
      }
  
      public void Insert(int index, CMInline item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CMInline item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CMInline item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CMInline[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (CMInline) HL7Connect.Cda.WrapperFactory.CMInline(wrapped().Item(i));
      }
  
      public bool Remove(CMInline item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class CMInlineListEnumerator : IEnumerator<CMInline>
      {
        private IsnCMInlineList com;
        int index = -1;
  
        public CMInlineListEnumerator(IsnCMInlineList com)
        {
          this.com = com;
        }
  
        public CMInline Current { get { return (CMInline) HL7Connect.Cda.WrapperFactory.CMInline(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (CMInline) HL7Connect.Cda.WrapperFactory.CMInline(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CMInline> GetEnumerator()
      {
        return new CMInlineListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new CMInlineListEnumerator(wrapped());
      }
  
    }
  
    public class CMContentList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CMContent>
    {
      public CMContentList(IsnCMContentList com) : base(com) {}
      internal new HCsnCMContentList wrapped() { return (HCsnCMContentList) com; }
  
      public CMContent this[int index]
      {
        get { return (CMContent) HL7Connect.Cda.WrapperFactory.CMContent(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CMContent item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CMContent Append()
      {
        return (CMContent) HL7Connect.Cda.WrapperFactory.CMContent(wrapped().Append());
      }
  
      public void Insert(int index, CMContent item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CMContent item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CMContent item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CMContent[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = (CMContent) HL7Connect.Cda.WrapperFactory.CMContent(wrapped().Item(i));
      }
  
      public bool Remove(CMContent item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class CMContentListEnumerator : IEnumerator<CMContent>
      {
        private IsnCMContentList com;
        int index = -1;
  
        public CMContentListEnumerator(IsnCMContentList com)
        {
          this.com = com;
        }
  
        public CMContent Current { get { return (CMContent) HL7Connect.Cda.WrapperFactory.CMContent(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return (CMContent) HL7Connect.Cda.WrapperFactory.CMContent(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CMContent> GetEnumerator()
      {
        return new CMContentListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new CMContentListEnumerator(wrapped());
      }
  
    }
  
    public class ItemList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Item>
    {
      public ItemList(IsnItemList com) : base(com) {}
      internal new HCsnItemList wrapped() { return (HCsnItemList) com; }
  
      public Item this[int index]
      {
        get { return new Item(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Item item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Item Append()
      {
        return new Item(wrapped().Append());
      }
  
      public void Insert(int index, Item item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Item item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Item item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Item[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Item(wrapped().Item(i));
      }
  
      public bool Remove(Item item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ItemListEnumerator : IEnumerator<Item>
      {
        private IsnItemList com;
        int index = -1;
  
        public ItemListEnumerator(IsnItemList com)
        {
          this.com = com;
        }
  
        public Item Current { get { return new Item(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Item(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Item> GetEnumerator()
      {
        return new ItemListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ItemListEnumerator(wrapped());
      }
  
    }
  
    public class ColList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Col>
    {
      public ColList(IsnColList com) : base(com) {}
      internal new HCsnColList wrapped() { return (HCsnColList) com; }
  
      public Col this[int index]
      {
        get { return new Col(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Col item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Col Append()
      {
        return new Col(wrapped().Append());
      }
  
      public void Insert(int index, Col item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Col item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Col item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Col[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Col(wrapped().Item(i));
      }
  
      public bool Remove(Col item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ColListEnumerator : IEnumerator<Col>
      {
        private IsnColList com;
        int index = -1;
  
        public ColListEnumerator(IsnColList com)
        {
          this.com = com;
        }
  
        public Col Current { get { return new Col(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Col(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Col> GetEnumerator()
      {
        return new ColListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ColListEnumerator(wrapped());
      }
  
    }
  
    public class TRowPartList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<TRowPart>
    {
      public TRowPartList(IsnTRowPartList com) : base(com) {}
      internal new HCsnTRowPartList wrapped() { return (HCsnTRowPartList) com; }
  
      public TRowPart this[int index]
      {
        get { return new TRowPart(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(TRowPart item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public TRowPart Append()
      {
        return new TRowPart(wrapped().Append());
      }
  
      public void Insert(int index, TRowPart item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(TRowPart item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(TRowPart item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(TRowPart[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new TRowPart(wrapped().Item(i));
      }
  
      public bool Remove(TRowPart item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class TRowPartListEnumerator : IEnumerator<TRowPart>
      {
        private IsnTRowPartList com;
        int index = -1;
  
        public TRowPartListEnumerator(IsnTRowPartList com)
        {
          this.com = com;
        }
  
        public TRowPart Current { get { return new TRowPart(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new TRowPart(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<TRowPart> GetEnumerator()
      {
        return new TRowPartListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new TRowPartListEnumerator(wrapped());
      }
  
    }
  
    public class TRowList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<TRow>
    {
      public TRowList(IsnTRowList com) : base(com) {}
      internal new HCsnTRowList wrapped() { return (HCsnTRowList) com; }
  
      public TRow this[int index]
      {
        get { return new TRow(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(TRow item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public TRow Append()
      {
        return new TRow(wrapped().Append());
      }
  
      public void Insert(int index, TRow item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(TRow item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(TRow item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(TRow[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new TRow(wrapped().Item(i));
      }
  
      public bool Remove(TRow item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class TRowListEnumerator : IEnumerator<TRow>
      {
        private IsnTRowList com;
        int index = -1;
  
        public TRowListEnumerator(IsnTRowList com)
        {
          this.com = com;
        }
  
        public TRow Current { get { return new TRow(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new TRow(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<TRow> GetEnumerator()
      {
        return new TRowListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new TRowListEnumerator(wrapped());
      }
  
    }
  
    public class ColGroupList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ColGroup>
    {
      public ColGroupList(IsnColGroupList com) : base(com) {}
      internal new HCsnColGroupList wrapped() { return (HCsnColGroupList) com; }
  
      public ColGroup this[int index]
      {
        get { return new ColGroup(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ColGroup item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ColGroup Append()
      {
        return new ColGroup(wrapped().Append());
      }
  
      public void Insert(int index, ColGroup item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ColGroup item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ColGroup item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ColGroup[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ColGroup(wrapped().Item(i));
      }
  
      public bool Remove(ColGroup item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ColGroupListEnumerator : IEnumerator<ColGroup>
      {
        private IsnColGroupList com;
        int index = -1;
  
        public ColGroupListEnumerator(IsnColGroupList com)
        {
          this.com = com;
        }
  
        public ColGroup Current { get { return new ColGroup(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ColGroup(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ColGroup> GetEnumerator()
      {
        return new ColGroupListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ColGroupListEnumerator(wrapped());
      }
  
    }
  
    public class TRowGroupList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<TRowGroup>
    {
      public TRowGroupList(IsnTRowGroupList com) : base(com) {}
      internal new HCsnTRowGroupList wrapped() { return (HCsnTRowGroupList) com; }
  
      public TRowGroup this[int index]
      {
        get { return new TRowGroup(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(TRowGroup item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public TRowGroup Append()
      {
        return new TRowGroup(wrapped().Append());
      }
  
      public void Insert(int index, TRowGroup item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(TRowGroup item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(TRowGroup item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(TRowGroup[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new TRowGroup(wrapped().Item(i));
      }
  
      public bool Remove(TRowGroup item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class TRowGroupListEnumerator : IEnumerator<TRowGroup>
      {
        private IsnTRowGroupList com;
        int index = -1;
  
        public TRowGroupListEnumerator(IsnTRowGroupList com)
        {
          this.com = com;
        }
  
        public TRowGroup Current { get { return new TRowGroup(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new TRowGroup(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<TRowGroup> GetEnumerator()
      {
        return new TRowGroupListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new TRowGroupListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// Base support for CDA structural elements
    ///</summary>
    public class CDABase : HL7Connect.Cda.Base
    {

      ///<summary>
      /// Create a CDA Base
      ///</summary>
      public CDABase() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newBase()) {} 

      internal CDABase(IcdaBase com) : base(com) {} 

      internal new HCcdaBase wrapped() { return (HCcdaBase) com; }

      ///<summary>
      /// XML id associated with this element
      ///</summary>
      private string propGetXmlId()
      {
        return wrapped().xmlId;
      }
      private void propSetXmlId(string value)
      {
        wrapped().xmlId = value;
      }
      ///<summary>
      /// XML id associated with this element
      ///</summary>
      public string xmlId { get { return propGetXmlId(); } set { propSetXmlId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals the imposition of realm-specific constraints. The value of this attribute identifies the realm in question.
      ///</summary>
      private HL7Connect.Cda.ListCS propGetRealmCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCS(wrapped().realmCode);
      }
      private void propSetRealmCode(HL7Connect.Cda.ListCS value)
      {
        wrapped().realmCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals the imposition of realm-specific constraints. The value of this attribute identifies the realm in question.
      ///</summary>
      public HL7Connect.Cda.ListCS realmCode { get { return propGetRealmCode(); } set { propSetRealmCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals the imposition of constraints defined in an HL7-specified message type. This might be a common type (also known as CMET in the messaging communication environment), or content included within a wrapper. The value of this attribute provides a unique identifier for the type in question.
      ///</summary>
      private HL7Connect.Cda.II propGetTypeId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().typeId);
      }
      private void propSetTypeId(HL7Connect.Cda.II value)
      {
        wrapped().typeId = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals the imposition of constraints defined in an HL7-specified message type. This might be a common type (also known as CMET in the messaging communication environment), or content included within a wrapper. The value of this attribute provides a unique identifier for the type in question.
      ///</summary>
      public HL7Connect.Cda.II typeId { get { return propGetTypeId(); } set { propSetTypeId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals the imposition of a set of template-defined constraints. The value of this attribute provides a unique identifier for the templates in question.
      ///</summary>
      private HL7Connect.Cda.ListII propGetTemplateId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().templateId);
      }
      private void propSetTemplateId(HL7Connect.Cda.ListII value)
      {
        wrapped().templateId = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals the imposition of a set of template-defined constraints. The value of this attribute provides a unique identifier for the templates in question.
      ///</summary>
      public HL7Connect.Cda.ListII templateId { get { return propGetTemplateId(); } set { propSetTemplateId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals that the class instance is null, and that the remainder of the information for this class and its properties will not be communicated. The value of this attribute specifies the flavor of null that is intended.-- NullFlavor that applies to the property. Note that nfNull means Not Null nfNullnfNI : No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value nfINV : Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variablenfOTH : Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)nfNINF : Negative Infinity : Negative infinity of numbersnfPINF : Positive Infinity : Positive infinity of numbersnfUNC : Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)nfDER : Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)nfUNK : Unknown : A proper value is applicable, but not known nfASKU : Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn't know) nfNAV : Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later nfQS : Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of waternfNASK : Not Asked : This information has not been sought (e.g., patient was not asked) nfTRC : Trace : The content is greater than zero, but too small to be quantifiednfMSK : Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detailnfNA : Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male)
      ///</summary>
      private Tv3NullFlavor propGetNullFlavor()
      {
        return wrapped().nullFlavor;
      }
      private void propSetNullFlavor(Tv3NullFlavor value)
      {
        wrapped().nullFlavor = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// When valued in an instance, this attribute signals that the class instance is null, and that the remainder of the information for this class and its properties will not be communicated. The value of this attribute specifies the flavor of null that is intended.-- NullFlavor that applies to the property. Note that nfNull means Not Null nfNullnfNI : No Information : The value is exceptional (missing, omitted, incomplete, improper). No information as to the reason for being an exceptional value is provided. This is the most general exceptional value. It is also the default exceptional value nfINV : Invalid : The value as represented in the instance is not a member of the set of permitted data values in the constrained value domain of a variablenfOTH : Other : The actual value is not a member of the set of permitted data values in the constrained value domain of a variable. (e.g., concept not provided by required code system)nfNINF : Negative Infinity : Negative infinity of numbersnfPINF : Positive Infinity : Positive infinity of numbersnfUNC : Unencoded : No attempt has been made to encode the information correctly but the raw source information is represented (usually in originalText)nfDER : Derived : An actual value may exist, but it must be derived from the provided information (usually an expression is provided directly)nfUNK : Unknown : A proper value is applicable, but not known nfASKU : Asked But Unknown : Information was sought but not found (e.g., patient was asked but didn't know) nfNAV : Temporarily Unavailable : Information is not available at this time but it is expected that it will be available later nfQS : Sufficient Quantity : The specific quantity is not known, but is known to be non-zero and is not specified because it makes up the bulk of the material.'Add 10mg of ingredient X, 50mg of ingredient Y, and sufficient quantity of water to 100mL.' The null flavor would be used to express the quantity of waternfNASK : Not Asked : This information has not been sought (e.g., patient was not asked) nfTRC : Trace : The content is greater than zero, but too small to be quantifiednfMSK : Masked : There is information on this item available but it has not been provided by the sender due to security, privacy or other reasons. There may be an alternate mechanism for gaining access to this information.Warning: Using this null flavor does provide information that may be a breach of confidentiality, even though no detail data is provided. Its primary purpose is for those circumstances where it is necessary to inform the receiver that the information does exist without providing any detailnfNA : Not Applicable : No proper value is applicable in this context (e.g., last menstrual period for a male)
      ///</summary>
      public Tv3NullFlavor nullFlavor { get { return propGetNullFlavor(); } set { propSetNullFlavor(value); } }

    }

    ///<summary>
    /// Abstract Ancestor for Act, Encounter, Observation, ObservationMedia, Organizer, Procedure_, RegionOfInterest, SubstanceAdministration or Supply
    ///</summary>
    public class ClinicalStatement : HL7Connect.Cda.CDABase
    {

      internal ClinicalStatement(IcdaClinicalStatement com) : base(com) {} 

      internal new HCcdaClinicalStatement wrapped() { return (HCcdaClinicalStatement) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      private void propSetMoodCode(string value)
      {
        wrapped().moodCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } set { propSetMoodCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

    }

    ///<summary>
    /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
    ///</summary>
    public class Act : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA Act
      ///</summary>
      public Act() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAct()) {} 

      internal Act(IcdaAct com) : base(com) {} 

      internal new HCcdaAct wrapped() { return (HCcdaAct) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      private HL7Connect.Cda.CD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.CD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      public HL7Connect.Cda.CD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// Act.negationInd, when set to "true", is a positive assertion that the Act as a whole is negated. Some properties such as Act.id, Act.moodCode, and the participations are not affected. These properties always have the same meaning: i.e., the author remains the author of the negative Act. An act statement with negationInd is still a statement about the specific fact described by the Act. For instance, a negated "finding of wheezing on July 1" means that the author positively denies that there was wheezing on July 1, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation.
      ///</summary>
      private bool propGetNegationInd()
      {
        return wrapped().negationInd != 0;
      }
      private void propSetNegationInd(bool value)
      {
        wrapped().negationInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Act.negationInd, when set to "true", is a positive assertion that the Act as a whole is negated. Some properties such as Act.id, Act.moodCode, and the participations are not affected. These properties always have the same meaning: i.e., the author remains the author of the negative Act. An act statement with negationInd is still a statement about the specific fact described by the Act. For instance, a negated "finding of wheezing on July 1" means that the author positively denies that there was wheezing on July 1, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation.
      ///</summary>
      public bool negationInd { get { return propGetNegationInd(); } set { propSetNegationInd(value); } }

      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      private bool propGetHasNegationInd()
      {
        return wrapped().HasNegationInd != 0;
      }
      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      public bool HasNegationInd { get { return propGetHasNegationInd(); } }

    }

    ///<summary>
    /// A entity acting in the employ of or on behalf of an organization.
    ///</summary>
    public class AssignedAuthor : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA AssignedAuthor
      ///</summary>
      public AssignedAuthor() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAssignedAuthor()) {} 

      internal AssignedAuthor(IcdaAssignedAuthor com) : base(com) {} 

      internal new HCcdaAssignedAuthor wrapped() { return (HCcdaAssignedAuthor) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// An entity that is a person
      ///</summary>
      private HL7Connect.Cda.Person propGetAssignedPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().assignedPerson);
      }
      private void propSetAssignedPerson(HL7Connect.Cda.Person value)
      {
        wrapped().assignedPerson = value.wrapped();
      }
      ///<summary>
      /// An entity that is a person
      ///</summary>
      public HL7Connect.Cda.Person assignedPerson { get { return propGetAssignedPerson(); } set { propSetAssignedPerson(value); } }

      ///<summary>
      /// Used when a device (application/machine/etc) authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthoringDevice propGetAssignedAuthoringDevice()
      {
        return HL7Connect.Cda.WrapperFactory.AuthoringDevice(wrapped().assignedAuthoringDevice);
      }
      private void propSetAssignedAuthoringDevice(HL7Connect.Cda.AuthoringDevice value)
      {
        wrapped().assignedAuthoringDevice = value.wrapped();
      }
      ///<summary>
      /// Used when a device (application/machine/etc) authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthoringDevice assignedAuthoringDevice { get { return propGetAssignedAuthoringDevice(); } set { propSetAssignedAuthoringDevice(value); } }

      ///<summary>
      /// Choice of assignedPerson or assignedAuthoringDevice
      ///</summary>
      private HL7Connect.Cda.AuthorChoice propGetAssignedAuthorChoice()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorChoice(wrapped().assignedAuthorChoice);
      }
      ///<summary>
      /// Choice of assignedPerson or assignedAuthoringDevice
      ///</summary>
      public HL7Connect.Cda.AuthorChoice assignedAuthorChoice { get { return propGetAssignedAuthorChoice(); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetRepresentedOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().representedOrganization);
      }
      private void propSetRepresentedOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().representedOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization representedOrganization { get { return propGetRepresentedOrganization(); } set { propSetRepresentedOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// a scoping organization in the role of an assigned custodian
    ///</summary>
    public class AssignedCustodian : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA AssignedCustodian
      ///</summary>
      public AssignedCustodian() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAssignedCustodian()) {} 

      internal AssignedCustodian(IcdaAssignedCustodian com) : base(com) {} 

      internal new HCcdaAssignedCustodian wrapped() { return (HCcdaAssignedCustodian) com; }

      ///<summary>
      /// The steward organization is an entity scoping the role of AssignedCustodian, and has a required CustodianOrganization.id
      ///</summary>
      private HL7Connect.Cda.CustodianOrganization propGetRepresentedCustodianOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.CustodianOrganization(wrapped().representedCustodianOrganization);
      }
      private void propSetRepresentedCustodianOrganization(HL7Connect.Cda.CustodianOrganization value)
      {
        wrapped().representedCustodianOrganization = value.wrapped();
      }
      ///<summary>
      /// The steward organization is an entity scoping the role of AssignedCustodian, and has a required CustodianOrganization.id
      ///</summary>
      public HL7Connect.Cda.CustodianOrganization representedCustodianOrganization { get { return propGetRepresentedCustodianOrganization(); } set { propSetRepresentedCustodianOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// Abstract Ancestor for either AssignedEntity or Related Entity
    ///</summary>
    public class InformantChoice : HL7Connect.Cda.CDABase
    {

      internal InformantChoice(IcdaInformantChoice com) : base(com) {} 

      internal new HCcdaInformantChoice wrapped() { return (HCcdaInformantChoice) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

    }

    ///<summary>
    /// An assigned entity is a person assigned to the role by the scoping organization.
    ///</summary>
    public class AssignedEntity : HL7Connect.Cda.InformantChoice
    {

      ///<summary>
      /// Create a CDA AssignedEntity
      ///</summary>
      public AssignedEntity() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAssignedEntity()) {} 

      internal AssignedEntity(IcdaAssignedEntity com) : base(com) {} 

      internal new HCcdaAssignedEntity wrapped() { return (HCcdaAssignedEntity) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// An entity that is a person
      ///</summary>
      private HL7Connect.Cda.Person propGetAssignedPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().assignedPerson);
      }
      private void propSetAssignedPerson(HL7Connect.Cda.Person value)
      {
        wrapped().assignedPerson = value.wrapped();
      }
      ///<summary>
      /// An entity that is a person
      ///</summary>
      public HL7Connect.Cda.Person assignedPerson { get { return propGetAssignedPerson(); } set { propSetAssignedPerson(value); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetRepresentedOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().representedOrganization);
      }
      private void propSetRepresentedOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().representedOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization representedOrganization { get { return propGetRepresentedOrganization(); } set { propSetRepresentedOrganization(value); } }

    }

    ///<summary>
    /// a person or organization in the role of a participating entity
    ///</summary>
    public class AssociatedEntity : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA AssociatedEntity
      ///</summary>
      public AssociatedEntity() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAssociatedEntity()) {} 

      internal AssociatedEntity(IcdaAssociatedEntity com) : base(com) {} 

      internal new HCcdaAssociatedEntity wrapped() { return (HCcdaAssociatedEntity) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// An entity that is a person
      ///</summary>
      private HL7Connect.Cda.Person propGetAssociatedPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().associatedPerson);
      }
      private void propSetAssociatedPerson(HL7Connect.Cda.Person value)
      {
        wrapped().associatedPerson = value.wrapped();
      }
      ///<summary>
      /// An entity that is a person
      ///</summary>
      public HL7Connect.Cda.Person associatedPerson { get { return propGetAssociatedPerson(); } set { propSetAssociatedPerson(value); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetScopingOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().scopingOrganization);
      }
      private void propSetScopingOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().scopingOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization scopingOrganization { get { return propGetScopingOrganization(); } set { propSetScopingOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

    }

    ///<summary>
    /// Represents a participant who has attested to the accuracy of the document, but who does not have privileges to legally authenticate the document. An example would be a resident physician who sees a patient and dictates a note, then later signs it.
    ///</summary>
    public class Authenticator : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Authenticator
      ///</summary>
      public Authenticator() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAuthenticator()) {} 

      internal Authenticator(IcdaAuthenticator com) : base(com) {} 

      internal new HCcdaAuthenticator wrapped() { return (HCcdaAuthenticator) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.TS propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.TS value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.TS time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying whether and how the participant has attested his participation through a signature and or whether such a signature is needed.                                                      Examples: A surgical Procedure act object (representing a procedure report) requires a signature of the performing and responsible surgeon, and possibly other participants. (See also: Participation.signatureText.)
      ///</summary>
      private HL7Connect.Cda.CS propGetSignatureCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().signatureCode);
      }
      private void propSetSignatureCode(HL7Connect.Cda.CS value)
      {
        wrapped().signatureCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying whether and how the participant has attested his participation through a signature and or whether such a signature is needed.                                                      Examples: A surgical Procedure act object (representing a procedure report) requires a signature of the performing and responsible surgeon, and possibly other participants. (See also: Participation.signatureText.)
      ///</summary>
      public HL7Connect.Cda.CS signatureCode { get { return propGetSignatureCode(); } set { propSetSignatureCode(value); } }

      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// Represents the humans and/or machines that authored the document. 
    /// 
    /// In some cases, the role or function of the author is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "Medical Student Progress Note". The role of the author can also be recorded in the Author.functionCode or AssignedAuthor.code attribute. If either of these attributes is included, they should be equivalent to or further specialize the role inherent in the ClinicalDocument.code (such as where the ClinicalDocument.code is simply "Physician Progress Note" and the value of Author.functionCode is "rounding physician"), and shall not conflict with the role inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation.
    ///</summary>
    public class Author : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Author
      ///</summary>
      public Author() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAuthor()) {} 

      internal Author(IcdaAuthor com) : base(com) {} 

      internal new HCcdaAuthor wrapped() { return (HCcdaAuthor) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An optional code specifying additional detail about the function that the Participation has in the Act, if such detail is not implied by the Participation.typeCode.                                                      Examples: First surgeon, second surgeon (or first assistant surgeon, the one facing the primary surgeon), second assistant (often standing next to the primary surgeon), potentially a third assistant, scrub nurse, circulating nurse, nurse assistant, anesthetist, attending anesthetist, anesthesia nurse, technician who positions the patient, postoperative watch nurse, assistants, midwives, students, etc.                                                      Constraints: This code, if specified at all, *must not* be in conflict with the Participation.typeCode.                         No HL7 standard specification may be written to technically depend on the functionCode. If that is deemed necessary, such concepts should be defined in the Participation.typeCode instead.                                                      Discussion: This code can accommodate the huge variety and nuances of functions that participants may perform in the act. The number and kinds of functions applicable depends on the special kind of act. E.g., each operation and method may require a different number of assistant surgeons or nurses.                        Since participation functions refer to what people do in an Act, these are really sub-activities that may all occur in parallel. If any more detail needs to be said about these activities other than just who does them, one should consider using component acts instead.
      ///</summary>
      private HL7Connect.Cda.CD propGetFunctionCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().functionCode);
      }
      private void propSetFunctionCode(HL7Connect.Cda.CD value)
      {
        wrapped().functionCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An optional code specifying additional detail about the function that the Participation has in the Act, if such detail is not implied by the Participation.typeCode.                                                      Examples: First surgeon, second surgeon (or first assistant surgeon, the one facing the primary surgeon), second assistant (often standing next to the primary surgeon), potentially a third assistant, scrub nurse, circulating nurse, nurse assistant, anesthetist, attending anesthetist, anesthesia nurse, technician who positions the patient, postoperative watch nurse, assistants, midwives, students, etc.                                                      Constraints: This code, if specified at all, *must not* be in conflict with the Participation.typeCode.                         No HL7 standard specification may be written to technically depend on the functionCode. If that is deemed necessary, such concepts should be defined in the Participation.typeCode instead.                                                      Discussion: This code can accommodate the huge variety and nuances of functions that participants may perform in the act. The number and kinds of functions applicable depends on the special kind of act. E.g., each operation and method may require a different number of assistant surgeons or nurses.                        Since participation functions refer to what people do in an Act, these are really sub-activities that may all occur in parallel. If any more detail needs to be said about these activities other than just who does them, one should consider using component acts instead.
      ///</summary>
      public HL7Connect.Cda.CD functionCode { get { return propGetFunctionCode(); } set { propSetFunctionCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.TS propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.TS value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.TS time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// A entity acting in the employ of or on behalf of an organization.
      ///</summary>
      private HL7Connect.Cda.AssignedAuthor propGetAssignedAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedAuthor(wrapped().assignedAuthor);
      }
      private void propSetAssignedAuthor(HL7Connect.Cda.AssignedAuthor value)
      {
        wrapped().assignedAuthor = value.wrapped();
      }
      ///<summary>
      /// A entity acting in the employ of or on behalf of an organization.
      ///</summary>
      public HL7Connect.Cda.AssignedAuthor assignedAuthor { get { return propGetAssignedAuthor(); } set { propSetAssignedAuthor(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// Abstract ancestor for either Person or AuthoringDevice
    ///</summary>
    public class AuthorChoice : HL7Connect.Cda.CDABase
    {

      internal AuthorChoice(IcdaAuthorChoice com) : base(com) {} 

      internal new HCcdaAuthorChoice wrapped() { return (HCcdaAuthorChoice) com; }

      ///<summary>
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// Used when a device (application/machine/etc) authored the document or section
    ///</summary>
    public class AuthoringDevice : HL7Connect.Cda.AuthorChoice
    {

      ///<summary>
      /// Create a CDA AuthoringDevice
      ///</summary>
      public AuthoringDevice() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAuthoringDevice()) {} 

      internal AuthoringDevice(IcdaAuthoringDevice com) : base(com) {} 

      internal new HCcdaAuthoringDevice wrapped() { return (HCcdaAuthoringDevice) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The human designated moniker for a device assigned by the manufacturer.                                                      Examples: Perkin Elmer 400 Inductively Coupled Plasma Unit
      ///</summary>
      private HL7Connect.Cda.SC propGetManufacturerModelName()
      {
        return HL7Connect.Cda.WrapperFactory.SC(wrapped().manufacturerModelName);
      }
      private void propSetManufacturerModelName(HL7Connect.Cda.SC value)
      {
        wrapped().manufacturerModelName = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The human designated moniker for a device assigned by the manufacturer.                                                      Examples: Perkin Elmer 400 Inductively Coupled Plasma Unit
      ///</summary>
      public HL7Connect.Cda.SC manufacturerModelName { get { return propGetManufacturerModelName(); } set { propSetManufacturerModelName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The moniker, version and release of the software that operates the device as assigned by the software manufacturer or developer.                                                      Examples: Agilent Technologies Chemstation A.08.xx
      ///</summary>
      private HL7Connect.Cda.SC propGetSoftwareName()
      {
        return HL7Connect.Cda.WrapperFactory.SC(wrapped().softwareName);
      }
      private void propSetSoftwareName(HL7Connect.Cda.SC value)
      {
        wrapped().softwareName = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The moniker, version and release of the software that operates the device as assigned by the software manufacturer or developer.                                                      Examples: Agilent Technologies Chemstation A.08.xx
      ///</summary>
      public HL7Connect.Cda.SC softwareName { get { return propGetSoftwareName(); } set { propSetSoftwareName(value); } }

      ///<summary>
      /// In CDA, Release One, it was possible to specify those individuals responsible for the device. This functionality has been deprecated in CDA, Release Two. The MaintainedEntity class is present for backwards compatibility, and its use is discouraged, except where needed to support the transformation of CDA, Release One documents
      ///</summary>
      private HL7Connect.Cda.MaintainedEntityList propGetAsMaintainedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.MaintainedEntityList(wrapped().asMaintainedEntity);
      }
      private void propSetAsMaintainedEntity(HL7Connect.Cda.MaintainedEntityList value)
      {
        wrapped().asMaintainedEntity = value.wrapped();
      }
      ///<summary>
      /// In CDA, Release One, it was possible to specify those individuals responsible for the device. This functionality has been deprecated in CDA, Release Two. The MaintainedEntity class is present for backwards compatibility, and its use is discouraged, except where needed to support the transformation of CDA, Release One documents
      ///</summary>
      public HL7Connect.Cda.MaintainedEntityList asMaintainedEntity { get { return propGetAsMaintainedEntity(); } set { propSetAsMaintainedEntity(value); } }

    }

    ///<summary>
    /// references the consents associated with this document
    ///</summary>
    public class Authorization : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Authorization
      ///</summary>
      public Authorization() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newAuthorization()) {} 

      internal Authorization(IcdaAuthorization com) : base(com) {} 

      internal new HCcdaAuthorization wrapped() { return (HCcdaAuthorization) com; }

      ///<summary>
      /// This class references the consents associated with this document. The type of consent (e.g. a consent to perform the related ServiceEvent, a consent for the information contained in the document to be released to a third party) is conveyed in Consent.code. Consents referenced in the CDA Header have been finalized (Consent.statusCode must equal "completed") and should be on file.
      ///</summary>
      private HL7Connect.Cda.Consent propGetConsent()
      {
        return HL7Connect.Cda.WrapperFactory.Consent(wrapped().consent);
      }
      private void propSetConsent(HL7Connect.Cda.Consent value)
      {
        wrapped().consent = value.wrapped();
      }
      ///<summary>
      /// This class references the consents associated with this document. The type of consent (e.g. a consent to perform the related ServiceEvent, a consent for the information contained in the document to be released to a third party) is conveyed in Consent.code. Consents referenced in the CDA Header have been finalized (Consent.statusCode must equal "completed") and should be on file.
      ///</summary>
      public HL7Connect.Cda.Consent consent { get { return propGetConsent(); } set { propSetConsent(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// A Patient's birthplace is represented as a relationship between a patient and a place
    ///</summary>
    public class Birthplace : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Birthplace
      ///</summary>
      public Birthplace() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newBirthplace()) {} 

      internal Birthplace(IcdaBirthplace com) : base(com) {} 

      internal new HCcdaBirthplace wrapped() { return (HCcdaBirthplace) com; }

      ///<summary>
      /// The Birthplace class is played by a place (Place class), and scoped by the patient (Patient class)
      ///</summary>
      private HL7Connect.Cda.Place propGetPlace()
      {
        return HL7Connect.Cda.WrapperFactory.Place(wrapped().place);
      }
      private void propSetPlace(HL7Connect.Cda.Place value)
      {
        wrapped().place = value.wrapped();
      }
      ///<summary>
      /// The Birthplace class is played by a place (Place class), and scoped by the patient (Patient class)
      ///</summary>
      public HL7Connect.Cda.Place place { get { return propGetPlace(); } set { propSetPlace(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// The ClinicalDocument class is the entry point into the CDA R-MIM, and corresponds to the &lt;ClinicalDocument&gt; XML element that is the root element of a CDA document 
    /// 
    /// A CDA document is logically broken up into a CDA Header and a CDA Body. The CDA Header is comprised of ClinicalDocument attributes, participants, and act relationships. The CDA Body is the target of the ClinicalDocument component act relationship.
    ///</summary>
    public class ClinicalDocument : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ClinicalDocument
      ///</summary>
      public ClinicalDocument() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newClinicalDocument()) {} 

      internal ClinicalDocument(IcdaClinicalDocument com) : base(com) {} 

      internal new HCcdaClinicalDocument wrapped() { return (HCcdaClinicalDocument) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.II propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.II value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.II id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A word or phrase by which a specific Act may be known among people.                                                      Example: name of a research study (e.g. "Scandinavian Simvastatin Study"), name of a court case (e.g. "Brown v. Board of Education"), name of another kind of work project or operation. For acts representing documents, this is the title of the document.                                                      *CONSTRAINT:* Previous to release 2.05 of the RIM, this attribute bore the datatype *ST*. From release 2.05 onwards, the datatype was extended to a *constrained* restriction of the *ED* datatype. The constraints to be imposed are identical to those for the *ST* datatype, except that the mediaType shall be "text/x-hl7-title+xml" or "text/plain". The intent is to allow sufficient mark-up to convey the semantics of scientific phrases, such as chemical compounds. This markup must not be used to convey simple display preferences. The default mediaType should be "text/plain".                                                      Discussion: This is not a formal identifier but rather a human-recognizable common name. However it is similar to the id attribute in that it refers to a specific Act rather than a 'kind' of act. (For definition mood, the title refers to that specific definition, rather than to a broad category that might be conveyed with Act.code.)                                                      Note: This attribute was *not* in the normative content balloted and approved for the first release of HL7's Reference Information Model Standard. The attribute will be considered when the RIM is prepared for balloting the second release. The attribute is being used in current HL7 Version 3 designs.
      ///</summary>
      private HL7Connect.Cda.ST propGetTitle()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().title);
      }
      private void propSetTitle(HL7Connect.Cda.ST value)
      {
        wrapped().title = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A word or phrase by which a specific Act may be known among people.                                                      Example: name of a research study (e.g. "Scandinavian Simvastatin Study"), name of a court case (e.g. "Brown v. Board of Education"), name of another kind of work project or operation. For acts representing documents, this is the title of the document.                                                      *CONSTRAINT:* Previous to release 2.05 of the RIM, this attribute bore the datatype *ST*. From release 2.05 onwards, the datatype was extended to a *constrained* restriction of the *ED* datatype. The constraints to be imposed are identical to those for the *ST* datatype, except that the mediaType shall be "text/x-hl7-title+xml" or "text/plain". The intent is to allow sufficient mark-up to convey the semantics of scientific phrases, such as chemical compounds. This markup must not be used to convey simple display preferences. The default mediaType should be "text/plain".                                                      Discussion: This is not a formal identifier but rather a human-recognizable common name. However it is similar to the id attribute in that it refers to a specific Act rather than a 'kind' of act. (For definition mood, the title refers to that specific definition, rather than to a broad category that might be conveyed with Act.code.)                                                      Note: This attribute was *not* in the normative content balloted and approved for the first release of HL7's Reference Information Model Standard. The attribute will be considered when the RIM is prepared for balloting the second release. The attribute is being used in current HL7 Version 3 designs.
      ///</summary>
      public HL7Connect.Cda.ST title { get { return propGetTitle(); } set { propSetTitle(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.TS propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.TS value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.TS effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that controls the disclosure of information about this Act, regardless of mood.                                                      Discussion: It is important to note that the necessary confidentiality of the medical record cannot be achieved solely through confidentiality codes to mask individual record items from certain types of users. There are two important problems with per-item confidentiality: one is inference and the other is the danger of holding back information that may be critical in a certain care situation. Inference means that filtered sensitive information can still be assumed given the other information that was not filtered. The simplest form of inference is that even the existence of a test order for an HIV Western Blot test or a T4/T8 lymphocyte count is a strong indication for an existing HIV infection, even if the results are not known. Very often, diagnoses can be inferred from medication, such as Zidovudin for treatment of HIV infections. The problem of hiding individual items becomes especially difficult with current medications, since the continuing administration of the medication must be assured.                        To mitigate some of the inference-risk, aggregations of data should assume the confidentiality level of the most confidential action in the aggregation.
      ///</summary>
      private HL7Connect.Cda.CD propGetConfidentialityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().confidentialityCode);
      }
      private void propSetConfidentialityCode(HL7Connect.Cda.CD value)
      {
        wrapped().confidentialityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that controls the disclosure of information about this Act, regardless of mood.                                                      Discussion: It is important to note that the necessary confidentiality of the medical record cannot be achieved solely through confidentiality codes to mask individual record items from certain types of users. There are two important problems with per-item confidentiality: one is inference and the other is the danger of holding back information that may be critical in a certain care situation. Inference means that filtered sensitive information can still be assumed given the other information that was not filtered. The simplest form of inference is that even the existence of a test order for an HIV Western Blot test or a T4/T8 lymphocyte count is a strong indication for an existing HIV infection, even if the results are not known. Very often, diagnoses can be inferred from medication, such as Zidovudin for treatment of HIV infections. The problem of hiding individual items becomes especially difficult with current medications, since the continuing administration of the medication must be assured.                        To mitigate some of the inference-risk, aggregations of data should assume the confidentiality level of the most confidential action in the aggregation.
      ///</summary>
      public HL7Connect.Cda.CD confidentialityCode { get { return propGetConfidentialityCode(); } set { propSetConfidentialityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A report identifier that remains constant across all revisions that derive from a common original.                         An original report is the first version of a report. It gets a new unique value for setId, and has the value of versionNumber set to equal "1".                         An addendum is an appendage to an existing report that contains supplemental information. The appendage is itself an original report. The parent report being appended is referenced via an ActRelationship, with ActRelationship.typeCode set to equal "APND" (for "appends"). The parent report being appended remains in place and its content and status are unaltered.                         A replacement report replaces an existing report. The replacement report uses the same value for setId as the parent report being replaced, and increments the value of versionNumber by 1. The state of the parent report being replaced should become "superceded", but is still retained in the system for historical reference.
      ///</summary>
      private HL7Connect.Cda.II propGetSetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().setId);
      }
      private void propSetSetId(HL7Connect.Cda.II value)
      {
        wrapped().setId = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A report identifier that remains constant across all revisions that derive from a common original.                         An original report is the first version of a report. It gets a new unique value for setId, and has the value of versionNumber set to equal "1".                         An addendum is an appendage to an existing report that contains supplemental information. The appendage is itself an original report. The parent report being appended is referenced via an ActRelationship, with ActRelationship.typeCode set to equal "APND" (for "appends"). The parent report being appended remains in place and its content and status are unaltered.                         A replacement report replaces an existing report. The replacement report uses the same value for setId as the parent report being replaced, and increments the value of versionNumber by 1. The state of the parent report being replaced should become "superceded", but is still retained in the system for historical reference.
      ///</summary>
      public HL7Connect.Cda.II setId { get { return propGetSetId(); } set { propSetSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Version number is an integer starting at '1' and incrementing by 1. The first instance or original report should always be valued as '1'. The version number value must be incremented by one when a report is replaced, but can also be incremented more often to meet local requirements.
      ///</summary>
      private HL7Connect.Cda.INT propGetVersionNumber()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().versionNumber);
      }
      private void propSetVersionNumber(HL7Connect.Cda.INT value)
      {
        wrapped().versionNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Version number is an integer starting at '1' and incrementing by 1. The first instance or original report should always be valued as '1'. The version number value must be incremented by one when a report is replaced, but can also be incremented more often to meet local requirements.
      ///</summary>
      public HL7Connect.Cda.INT versionNumber { get { return propGetVersionNumber(); } set { propSetVersionNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Time a document is released (i.e., copied or sent to a display device) from a document management system that maintains revision control over the document. Once valued, cannot be changed. Intent of this attribute is to give the viewer of the document some notion as to how long the document has been out of the safe context of its document management system.
      ///</summary>
      private HL7Connect.Cda.TS propGetCopyTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().copyTime);
      }
      private void propSetCopyTime(HL7Connect.Cda.TS value)
      {
        wrapped().copyTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Time a document is released (i.e., copied or sent to a display device) from a document management system that maintains revision control over the document. Once valued, cannot be changed. Intent of this attribute is to give the viewer of the document some notion as to how long the document has been out of the safe context of its document management system.
      ///</summary>
      public HL7Connect.Cda.TS copyTime { get { return propGetCopyTime(); } set { propSetCopyTime(value); } }

      ///<summary>
      /// The recordTarget represents the medical record that this document belongs to. 
      /// 
      /// A clinical document typically has exactly one recordTarget participant. In the uncommon case where a clinical document (such as a group encounter note) is placed into more than one patient chart, more than one recordTarget participants can be stated. The recordTarget(s) of a document are stated in the header and propagate to nested content, where they cannot be overridden
      ///</summary>
      private HL7Connect.Cda.RecordTargetList propGetRecordTarget()
      {
        return HL7Connect.Cda.WrapperFactory.RecordTargetList(wrapped().recordTarget);
      }
      private void propSetRecordTarget(HL7Connect.Cda.RecordTargetList value)
      {
        wrapped().recordTarget = value.wrapped();
      }
      ///<summary>
      /// The recordTarget represents the medical record that this document belongs to. 
      /// 
      /// A clinical document typically has exactly one recordTarget participant. In the uncommon case where a clinical document (such as a group encounter note) is placed into more than one patient chart, more than one recordTarget participants can be stated. The recordTarget(s) of a document are stated in the header and propagate to nested content, where they cannot be overridden
      ///</summary>
      public HL7Connect.Cda.RecordTargetList recordTarget { get { return propGetRecordTarget(); } set { propSetRecordTarget(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// Represents the participant who has transformed a dictated note into text.
      ///</summary>
      private HL7Connect.Cda.DataEnterer propGetDataEnterer()
      {
        return HL7Connect.Cda.WrapperFactory.DataEnterer(wrapped().dataEnterer);
      }
      private void propSetDataEnterer(HL7Connect.Cda.DataEnterer value)
      {
        wrapped().dataEnterer = value.wrapped();
      }
      ///<summary>
      /// Represents the participant who has transformed a dictated note into text.
      ///</summary>
      public HL7Connect.Cda.DataEnterer dataEnterer { get { return propGetDataEnterer(); } set { propSetDataEnterer(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Represents the organization that is in charge of maintaining the document. The custodian is the steward that is entrusted with the care of the document. Every CDA document has exactly one custodian or section
      ///</summary>
      private HL7Connect.Cda.Custodian propGetCustodian()
      {
        return HL7Connect.Cda.WrapperFactory.Custodian(wrapped().custodian);
      }
      private void propSetCustodian(HL7Connect.Cda.Custodian value)
      {
        wrapped().custodian = value.wrapped();
      }
      ///<summary>
      /// Represents the organization that is in charge of maintaining the document. The custodian is the steward that is entrusted with the care of the document. Every CDA document has exactly one custodian or section
      ///</summary>
      public HL7Connect.Cda.Custodian custodian { get { return propGetCustodian(); } set { propSetCustodian(value); } }

      ///<summary>
      /// Represents a recipient who should receive a copy of the document. 
      /// 
      /// NOTE: The information recipient is an entity to whom a copy of a document is directed, at the time of document authorship. It is not the same as the cumulative set of persons to whom the document has subsequently been disclosed, over the life-time of the patient. Such a disclosure list would not be contained within the document, and it outside the scope of CDA.
      ///</summary>
      private HL7Connect.Cda.InformationRecipientList propGetInformationRecipient()
      {
        return HL7Connect.Cda.WrapperFactory.InformationRecipientList(wrapped().informationRecipient);
      }
      private void propSetInformationRecipient(HL7Connect.Cda.InformationRecipientList value)
      {
        wrapped().informationRecipient = value.wrapped();
      }
      ///<summary>
      /// Represents a recipient who should receive a copy of the document. 
      /// 
      /// NOTE: The information recipient is an entity to whom a copy of a document is directed, at the time of document authorship. It is not the same as the cumulative set of persons to whom the document has subsequently been disclosed, over the life-time of the patient. Such a disclosure list would not be contained within the document, and it outside the scope of CDA.
      ///</summary>
      public HL7Connect.Cda.InformationRecipientList informationRecipient { get { return propGetInformationRecipient(); } set { propSetInformationRecipient(value); } }

      ///<summary>
      /// Represents a participant who has legally authenticated the document. 
      /// 
      /// The CDA is a standard that specifies the structure of exchanged clinical documents. In the case where a local document is transformed into a CDA document for exchange, authentication occurs on the local document, and that fact is reflected in the exchanged CDA document. A CDA document can reflect the unauthenticated, authenticated, or legally authenticated state. The unauthenticated state exists when no authentication information has been recorded (i.e., it is the absence of being either authenticated or legally authenticated). While electronic signatures are not captured in a CDA document, both authentication and legal authentication require that a document has been signed manually or electronically by the responsible individual. A legalAuthenticator has a required legalAuthenticator.time indicating the time of authentication, and a required legalAuthenticator.signatureCode, indicating that a signature has been obtained and is on file.
      ///</summary>
      private HL7Connect.Cda.LegalAuthenticator propGetLegalAuthenticator()
      {
        return HL7Connect.Cda.WrapperFactory.LegalAuthenticator(wrapped().legalAuthenticator);
      }
      private void propSetLegalAuthenticator(HL7Connect.Cda.LegalAuthenticator value)
      {
        wrapped().legalAuthenticator = value.wrapped();
      }
      ///<summary>
      /// Represents a participant who has legally authenticated the document. 
      /// 
      /// The CDA is a standard that specifies the structure of exchanged clinical documents. In the case where a local document is transformed into a CDA document for exchange, authentication occurs on the local document, and that fact is reflected in the exchanged CDA document. A CDA document can reflect the unauthenticated, authenticated, or legally authenticated state. The unauthenticated state exists when no authentication information has been recorded (i.e., it is the absence of being either authenticated or legally authenticated). While electronic signatures are not captured in a CDA document, both authentication and legal authentication require that a document has been signed manually or electronically by the responsible individual. A legalAuthenticator has a required legalAuthenticator.time indicating the time of authentication, and a required legalAuthenticator.signatureCode, indicating that a signature has been obtained and is on file.
      ///</summary>
      public HL7Connect.Cda.LegalAuthenticator legalAuthenticator { get { return propGetLegalAuthenticator(); } set { propSetLegalAuthenticator(value); } }

      ///<summary>
      /// Represents a participant who has attested to the accuracy of the document, but who does not have privileges to legally authenticate the document. An example would be a resident physician who sees a patient and dictates a note, then later signs it
      ///</summary>
      private HL7Connect.Cda.AuthenticatorList propGetAuthenticator()
      {
        return HL7Connect.Cda.WrapperFactory.AuthenticatorList(wrapped().authenticator);
      }
      private void propSetAuthenticator(HL7Connect.Cda.AuthenticatorList value)
      {
        wrapped().authenticator = value.wrapped();
      }
      ///<summary>
      /// Represents a participant who has attested to the accuracy of the document, but who does not have privileges to legally authenticate the document. An example would be a resident physician who sees a patient and dictates a note, then later signs it
      ///</summary>
      public HL7Connect.Cda.AuthenticatorList authenticator { get { return propGetAuthenticator(); } set { propSetAuthenticator(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant1List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant1List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant1List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant1List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// represents those orders that are fulfilled by this document. For instance, a provider orders an X-Ray. The X-Ray is performed. A radiologist reads the X-Ray and generates a report. The X-Ray order identifier is transmitted in the Order class, the performed X-Ray procedure is transmitted in the ServiceEvent class, and the ClinicalDocument.code would be valued with "Diagnostic Imaging Report".
      ///</summary>
      private HL7Connect.Cda.InFulfillmentOfList propGetInFulfillmentOf()
      {
        return HL7Connect.Cda.WrapperFactory.InFulfillmentOfList(wrapped().inFulfillmentOf);
      }
      private void propSetInFulfillmentOf(HL7Connect.Cda.InFulfillmentOfList value)
      {
        wrapped().inFulfillmentOf = value.wrapped();
      }
      ///<summary>
      /// represents those orders that are fulfilled by this document. For instance, a provider orders an X-Ray. The X-Ray is performed. A radiologist reads the X-Ray and generates a report. The X-Ray order identifier is transmitted in the Order class, the performed X-Ray procedure is transmitted in the ServiceEvent class, and the ClinicalDocument.code would be valued with "Diagnostic Imaging Report".
      ///</summary>
      public HL7Connect.Cda.InFulfillmentOfList inFulfillmentOf { get { return propGetInFulfillmentOf(); } set { propSetInFulfillmentOf(value); } }

      ///<summary>
      /// represents the main Act, such as a colonoscopy or an appendectomy, being documented. 
      /// 
      /// In some cases, the ServiceEvent is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "History and Physical Report" and the procedure being documented is a "History and Physical" act. A ServiceEvent can further specialize the act inherent in the ClinicalDocument.code, such as where the ClinicalDocument.code is simply "Procedure Report" and the procedure was a "colonoscopy". If ServiceEvent is included, it must be equivalent to or further specialize the value inherent in the ClinicalDocument.code, and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. ServiceEvent.effectiveTime can be used to indicate the time the actual event (as opposed to the encounter surrounding the event) took place.
      ///</summary>
      private HL7Connect.Cda.DocumentationOfList propGetDocumentationOf()
      {
        return HL7Connect.Cda.WrapperFactory.DocumentationOfList(wrapped().documentationOf);
      }
      private void propSetDocumentationOf(HL7Connect.Cda.DocumentationOfList value)
      {
        wrapped().documentationOf = value.wrapped();
      }
      ///<summary>
      /// represents the main Act, such as a colonoscopy or an appendectomy, being documented. 
      /// 
      /// In some cases, the ServiceEvent is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "History and Physical Report" and the procedure being documented is a "History and Physical" act. A ServiceEvent can further specialize the act inherent in the ClinicalDocument.code, such as where the ClinicalDocument.code is simply "Procedure Report" and the procedure was a "colonoscopy". If ServiceEvent is included, it must be equivalent to or further specialize the value inherent in the ClinicalDocument.code, and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. ServiceEvent.effectiveTime can be used to indicate the time the actual event (as opposed to the encounter surrounding the event) took place.
      ///</summary>
      public HL7Connect.Cda.DocumentationOfList documentationOf { get { return propGetDocumentationOf(); } set { propSetDocumentationOf(value); } }

      ///<summary>
      /// A conformant CDA document can have a single relatedDocument with typeCode "APND"; a single relatedDocument with typeCode "RPLC"; a single relatedDocument with typeCode "XFRM"; a combination of two relatedDocuments with typeCodes "XFRM" and "RPLC"; or a combination of two relatedDocuments with typeCodes "XFRM" and "APND". No other combinations are allowed.
      ///</summary>
      private HL7Connect.Cda.RelatedDocumentList propGetRelatedDocument()
      {
        return HL7Connect.Cda.WrapperFactory.RelatedDocumentList(wrapped().relatedDocument);
      }
      private void propSetRelatedDocument(HL7Connect.Cda.RelatedDocumentList value)
      {
        wrapped().relatedDocument = value.wrapped();
      }
      ///<summary>
      /// A conformant CDA document can have a single relatedDocument with typeCode "APND"; a single relatedDocument with typeCode "RPLC"; a single relatedDocument with typeCode "XFRM"; a combination of two relatedDocuments with typeCodes "XFRM" and "RPLC"; or a combination of two relatedDocuments with typeCodes "XFRM" and "APND". No other combinations are allowed.
      ///</summary>
      public HL7Connect.Cda.RelatedDocumentList relatedDocument { get { return propGetRelatedDocument(); } set { propSetRelatedDocument(value); } }

      ///<summary>
      /// references the consents associated with this document. The type of consent (e.g. a consent to perform the related ServiceEvent, a consent for the information contained in the document to be released to a third party) is conveyed in Consent.code. Consents referenced in the CDA Header have been finalized (Consent.statusCode must equal "completed") and should be on file.
      ///</summary>
      private HL7Connect.Cda.AuthorizationList propGetAuthorization()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorizationList(wrapped().authorization);
      }
      private void propSetAuthorization(HL7Connect.Cda.AuthorizationList value)
      {
        wrapped().authorization = value.wrapped();
      }
      ///<summary>
      /// references the consents associated with this document. The type of consent (e.g. a consent to perform the related ServiceEvent, a consent for the information contained in the document to be released to a third party) is conveyed in Consent.code. Consents referenced in the CDA Header have been finalized (Consent.statusCode must equal "completed") and should be on file.
      ///</summary>
      public HL7Connect.Cda.AuthorizationList authorization { get { return propGetAuthorization(); } set { propSetAuthorization(value); } }

      ///<summary>
      /// represents the setting of the clinical encounter during which the documented act(s) or ServiceEvent occurred. Documents are not necessarily generated during an encounter, such as when a clinician, in response to an abnormal lab result, attempts to contact the patient but can't, and writes a Progress Note. 
      /// 
      /// In some cases, the setting of the encounter is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "Diabetes Clinic Progress Note". The setting of an encounter can also be transmitted in the HealthCareFacility.code attribute. If HealthCareFacility.code is sent, it should be equivalent to or further specialize the value inherent in the ClinicalDocument.code (such as where the ClinicalDocument.code is simply "Clinic Progress Note" and the value of HealthCareFacility.code is "cardiology clinic"), and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. EncompassingEncounter.dischargeDispositionCode can be used to depict the disposition of the patient at the time of hospital discharge (e.g., discharged to home, expired, against medical advice, etc.).
      ///</summary>
      private HL7Connect.Cda.Component1 propGetComponentOf()
      {
        return HL7Connect.Cda.WrapperFactory.Component1(wrapped().componentOf);
      }
      private void propSetComponentOf(HL7Connect.Cda.Component1 value)
      {
        wrapped().componentOf = value.wrapped();
      }
      ///<summary>
      /// represents the setting of the clinical encounter during which the documented act(s) or ServiceEvent occurred. Documents are not necessarily generated during an encounter, such as when a clinician, in response to an abnormal lab result, attempts to contact the patient but can't, and writes a Progress Note. 
      /// 
      /// In some cases, the setting of the encounter is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "Diabetes Clinic Progress Note". The setting of an encounter can also be transmitted in the HealthCareFacility.code attribute. If HealthCareFacility.code is sent, it should be equivalent to or further specialize the value inherent in the ClinicalDocument.code (such as where the ClinicalDocument.code is simply "Clinic Progress Note" and the value of HealthCareFacility.code is "cardiology clinic"), and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. EncompassingEncounter.dischargeDispositionCode can be used to depict the disposition of the patient at the time of hospital discharge (e.g., discharged to home, expired, against medical advice, etc.).
      ///</summary>
      public HL7Connect.Cda.Component1 componentOf { get { return propGetComponentOf(); } set { propSetComponentOf(value); } }

      ///<summary>
      /// The CDA body. The body can be either an unstructured blob, or can be comprised of structured markup. Every CDA document has exactly one body, associated with the ClinicalDocument class through the component relationship.
      ///</summary>
      private HL7Connect.Cda.Component2 propGetComponent()
      {
        return HL7Connect.Cda.WrapperFactory.Component2(wrapped().Component);
      }
      private void propSetComponent(HL7Connect.Cda.Component2 value)
      {
        wrapped().Component = value.wrapped();
      }
      ///<summary>
      /// The CDA body. The body can be either an unstructured blob, or can be comprised of structured markup. Every CDA document has exactly one body, associated with the ClinicalDocument class through the component relationship.
      ///</summary>
      public HL7Connect.Cda.Component2 component { get { return propGetComponent(); } set { propSetComponent(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// the setting of the clinical encounter during which the documented act(s) or ServiceEvent occurred
    ///</summary>
    public class Component1 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Component1
      ///</summary>
      public Component1() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newComponent1()) {} 

      internal Component1(IcdaComponent1 com) : base(com) {} 

      internal new HCcdaComponent1 wrapped() { return (HCcdaComponent1) com; }

      ///<summary>
      /// represents the setting of the clinical encounter during which the documented act(s) or ServiceEvent occurred. Documents are not necessarily generated during an encounter, such as when a clinician, in response to an abnormal lab result, attempts to contact the patient but can't, and writes a Progress Note. 
      /// 
      /// In some cases, the setting of the encounter is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "Diabetes Clinic Progress Note". The setting of an encounter can also be transmitted in the HealthCareFacility.code attribute. If HealthCareFacility.code is sent, it should be equivalent to or further specialize the value inherent in the ClinicalDocument.code (such as where the ClinicalDocument.code is simply "Clinic Progress Note" and the value of HealthCareFacility.code is "cardiology clinic"), and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. EncompassingEncounter.dischargeDispositionCode can be used to depict the disposition of the patient at the time of hospital discharge (e.g., discharged to home, expired, against medical advice, etc.).
      ///</summary>
      private HL7Connect.Cda.EncompassingEncounter propGetEncompassingEncounter()
      {
        return HL7Connect.Cda.WrapperFactory.EncompassingEncounter(wrapped().encompassingEncounter);
      }
      private void propSetEncompassingEncounter(HL7Connect.Cda.EncompassingEncounter value)
      {
        wrapped().encompassingEncounter = value.wrapped();
      }
      ///<summary>
      /// represents the setting of the clinical encounter during which the documented act(s) or ServiceEvent occurred. Documents are not necessarily generated during an encounter, such as when a clinician, in response to an abnormal lab result, attempts to contact the patient but can't, and writes a Progress Note. 
      /// 
      /// In some cases, the setting of the encounter is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "Diabetes Clinic Progress Note". The setting of an encounter can also be transmitted in the HealthCareFacility.code attribute. If HealthCareFacility.code is sent, it should be equivalent to or further specialize the value inherent in the ClinicalDocument.code (such as where the ClinicalDocument.code is simply "Clinic Progress Note" and the value of HealthCareFacility.code is "cardiology clinic"), and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. EncompassingEncounter.dischargeDispositionCode can be used to depict the disposition of the patient at the time of hospital discharge (e.g., discharged to home, expired, against medical advice, etc.).
      ///</summary>
      public HL7Connect.Cda.EncompassingEncounter encompassingEncounter { get { return propGetEncompassingEncounter(); } set { propSetEncompassingEncounter(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// The CDA body can be either an unstructured blob, or can be comprised of structured markup. Every CDA document has exactly one body, associated with the ClinicalDocument class through the component relationship.
    ///</summary>
    public class Component2 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Component2
      ///</summary>
      public Component2() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newComponent2()) {} 

      internal Component2(IcdaComponent2 com) : base(com) {} 

      internal new HCcdaComponent2 wrapped() { return (HCcdaComponent2) com; }

      ///<summary>
      /// represents a document body that is in some format other than XML. NonXMLBody.text is used to reference data that is stored externally to the CDA document or to encode the data directly inline. 
      /// 
      /// Rendering a referenced non-XML body requires a software tool that recognizes the particular MIME media type of the blob.
      ///</summary>
      private HL7Connect.Cda.NonXMLBody propGetNonXMLBody()
      {
        return HL7Connect.Cda.WrapperFactory.NonXMLBody(wrapped().nonXMLBody);
      }
      private void propSetNonXMLBody(HL7Connect.Cda.NonXMLBody value)
      {
        wrapped().nonXMLBody = value.wrapped();
      }
      ///<summary>
      /// represents a document body that is in some format other than XML. NonXMLBody.text is used to reference data that is stored externally to the CDA document or to encode the data directly inline. 
      /// 
      /// Rendering a referenced non-XML body requires a software tool that recognizes the particular MIME media type of the blob.
      ///</summary>
      public HL7Connect.Cda.NonXMLBody nonXMLBody { get { return propGetNonXMLBody(); } set { propSetNonXMLBody(value); } }

      ///<summary>
      /// represents a CDA document body that is comprised of one or more document sections, possibly with entries
      ///</summary>
      private HL7Connect.Cda.StructuredBody propGetStructuredBody()
      {
        return HL7Connect.Cda.WrapperFactory.StructuredBody(wrapped().structuredBody);
      }
      private void propSetStructuredBody(HL7Connect.Cda.StructuredBody value)
      {
        wrapped().structuredBody = value.wrapped();
      }
      ///<summary>
      /// represents a CDA document body that is comprised of one or more document sections, possibly with entries
      ///</summary>
      public HL7Connect.Cda.StructuredBody structuredBody { get { return propGetStructuredBody(); } set { propSetStructuredBody(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      private bool propGetContextConductionInd()
      {
        return wrapped().contextConductionInd != 0;
      }
      private void propSetContextConductionInd(bool value)
      {
        wrapped().contextConductionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      public bool contextConductionInd { get { return propGetContextConductionInd(); } set { propSetContextConductionInd(value); } }

      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      private bool propGetHasContextConductionInd()
      {
        return wrapped().HasContextConductionInd != 0;
      }
      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      public bool HasContextConductionInd { get { return propGetHasContextConductionInd(); } }

    }

    ///<summary>
    /// The StructuredBody class is associated with one or more Section classes through a component relationship
    ///</summary>
    public class Component3 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Component3
      ///</summary>
      public Component3() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newComponent3()) {} 

      internal Component3(IcdaComponent3 com) : base(com) {} 

      internal new HCcdaComponent3 wrapped() { return (HCcdaComponent3) com; }

      ///<summary>
      /// Document sections can nest, can override context propagated from the header, and can contain narrative and CDA entries. 
      /// 
      /// The section has an ID attribute. This attribute serves as the target of a linkHtml reference in narrative. All values of attributes of type XML ID must be unique within the document (per the W3C XML specification).
      ///</summary>
      private HL7Connect.Cda.Section propGetSection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().section);
      }
      private void propSetSection(HL7Connect.Cda.Section value)
      {
        wrapped().section = value.wrapped();
      }
      ///<summary>
      /// Document sections can nest, can override context propagated from the header, and can contain narrative and CDA entries. 
      /// 
      /// The section has an ID attribute. This attribute serves as the target of a linkHtml reference in narrative. All values of attributes of type XML ID must be unique within the document (per the W3C XML specification).
      ///</summary>
      public HL7Connect.Cda.Section section { get { return propGetSection(); } set { propSetSection(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      private bool propGetContextConductionInd()
      {
        return wrapped().contextConductionInd != 0;
      }
      private void propSetContextConductionInd(bool value)
      {
        wrapped().contextConductionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      public bool contextConductionInd { get { return propGetContextConductionInd(); } set { propSetContextConductionInd(value); } }

      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      private bool propGetHasContextConductionInd()
      {
        return wrapped().HasContextConductionInd != 0;
      }
      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      public bool HasContextConductionInd { get { return propGetHasContextConductionInd(); } }

    }

    ///<summary>
    /// The components of an organizer
    ///</summary>
    public class Component4 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Component4
      ///</summary>
      public Component4() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newComponent4()) {} 

      internal Component4(IcdaComponent4 com) : base(com) {} 

      internal new HCcdaComponent4 wrapped() { return (HCcdaComponent4) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An integer specifying the relative sequential or temporal ordering of this relationship among other like-types relationships having the same source Act.                                                      Discussion: This attribute is part of the workflow control suite of attributes. An action plan is a composite Act with component Acts. In a sequential plan, each component has a sequenceNumber that specifies the ordering of the plan steps. Multiple components with the same sequenceNumber make a branch. Branches can be exclusive (case-switch) or can indicate parallel processes indicated by the splitCode.                        If value is null, the relative position of the target Act is unspecified. (i.e. it may occur anywhere.)                        Use the 'priorityNumber' attribute to indicate relative preference instead of order of occurrence.
      ///</summary>
      private HL7Connect.Cda.INT propGetSequenceNumber()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().sequenceNumber);
      }
      private void propSetSequenceNumber(HL7Connect.Cda.INT value)
      {
        wrapped().sequenceNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An integer specifying the relative sequential or temporal ordering of this relationship among other like-types relationships having the same source Act.                                                      Discussion: This attribute is part of the workflow control suite of attributes. An action plan is a composite Act with component Acts. In a sequential plan, each component has a sequenceNumber that specifies the ordering of the plan steps. Multiple components with the same sequenceNumber make a branch. Branches can be exclusive (case-switch) or can indicate parallel processes indicated by the splitCode.                        If value is null, the relative position of the target Act is unspecified. (i.e. it may occur anywhere.)                        Use the 'priorityNumber' attribute to indicate relative preference instead of order of occurrence.
      ///</summary>
      public HL7Connect.Cda.INT sequenceNumber { get { return propGetSequenceNumber(); } set { propSetSequenceNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// This attribute indicates whether or not the source Act is intended to be interpreted independently of the target Act. The indicator cannot prevent an individual or application from separating the Acts, but indicates the author's desire and willingness to attest to the content of the source Act if separated from the target Act. Note that the default for this attribute will typically be "TRUE". Also note that this attribute is orthogonal and unrelated to the RIM's context/inheritance mechanism. If the context of an Act is propagated to nested Acts, it is assumed that those nested Acts are not intended to be interpreted without the propagated context.
      ///</summary>
      private HL7Connect.Cda.BL propGetSeperatableInd()
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().seperatableInd);
      }
      private void propSetSeperatableInd(HL7Connect.Cda.BL value)
      {
        wrapped().seperatableInd = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// This attribute indicates whether or not the source Act is intended to be interpreted independently of the target Act. The indicator cannot prevent an individual or application from separating the Acts, but indicates the author's desire and willingness to attest to the content of the source Act if separated from the target Act. Note that the default for this attribute will typically be "TRUE". Also note that this attribute is orthogonal and unrelated to the RIM's context/inheritance mechanism. If the context of an Act is propagated to nested Acts, it is assumed that those nested Acts are not intended to be interpreted without the propagated context.
      ///</summary>
      public HL7Connect.Cda.BL seperatableInd { get { return propGetSeperatableInd(); } set { propSetSeperatableInd(value); } }

      ///<summary>
      /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
      ///</summary>
      private HL7Connect.Cda.Act propGetAct()
      {
        return HL7Connect.Cda.WrapperFactory.Act(wrapped().act);
      }
      private void propSetAct(HL7Connect.Cda.Act value)
      {
        wrapped().act = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
      ///</summary>
      public HL7Connect.Cda.Act act { get { return propGetAct(); } set { propSetAct(value); } }

      ///<summary>
      /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
      ///</summary>
      private HL7Connect.Cda.Encounter propGetEncounter()
      {
        return HL7Connect.Cda.WrapperFactory.Encounter(wrapped().encounter);
      }
      private void propSetEncounter(HL7Connect.Cda.Encounter value)
      {
        wrapped().encounter = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
      ///</summary>
      public HL7Connect.Cda.Encounter encounter { get { return propGetEncounter(); } set { propSetEncounter(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class, used for representing coded and other observations.
      ///</summary>
      private HL7Connect.Cda.Observation propGetObservation()
      {
        return HL7Connect.Cda.WrapperFactory.Observation(wrapped().observation);
      }
      private void propSetObservation(HL7Connect.Cda.Observation value)
      {
        wrapped().observation = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class, used for representing coded and other observations.
      ///</summary>
      public HL7Connect.Cda.Observation observation { get { return propGetObservation(); } set { propSetObservation(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
      ///</summary>
      private HL7Connect.Cda.ObservationMedia propGetObservationMedia()
      {
        return HL7Connect.Cda.WrapperFactory.ObservationMedia(wrapped().observationMedia);
      }
      private void propSetObservationMedia(HL7Connect.Cda.ObservationMedia value)
      {
        wrapped().observationMedia = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
      ///</summary>
      public HL7Connect.Cda.ObservationMedia observationMedia { get { return propGetObservationMedia(); } set { propSetObservationMedia(value); } }

      ///<summary>
      /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
      ///</summary>
      private HL7Connect.Cda.Organizer propGetOrganizer()
      {
        return HL7Connect.Cda.WrapperFactory.Organizer(wrapped().organizer);
      }
      private void propSetOrganizer(HL7Connect.Cda.Organizer value)
      {
        wrapped().organizer = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
      ///</summary>
      public HL7Connect.Cda.Organizer organizer { get { return propGetOrganizer(); } set { propSetOrganizer(value); } }

      ///<summary>
      /// A derivative of the RIM Procedure class, used for representing procedures.
      ///</summary>
      private HL7Connect.Cda.Procedure propGetProcedure()
      {
        return HL7Connect.Cda.WrapperFactory.Procedure(wrapped().procedure_);
      }
      private void propSetProcedure(HL7Connect.Cda.Procedure value)
      {
        wrapped().procedure_ = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Procedure class, used for representing procedures.
      ///</summary>
      public HL7Connect.Cda.Procedure procedure { get { return propGetProcedure(); } set { propSetProcedure(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
      ///</summary>
      private HL7Connect.Cda.RegionOfInterest propGetRegionOfInterest()
      {
        return HL7Connect.Cda.WrapperFactory.RegionOfInterest(wrapped().regionOfInterest);
      }
      private void propSetRegionOfInterest(HL7Connect.Cda.RegionOfInterest value)
      {
        wrapped().regionOfInterest = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
      ///</summary>
      public HL7Connect.Cda.RegionOfInterest regionOfInterest { get { return propGetRegionOfInterest(); } set { propSetRegionOfInterest(value); } }

      ///<summary>
      /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
      ///</summary>
      private HL7Connect.Cda.SubstanceAdministration propGetSubstanceAdministration()
      {
        return HL7Connect.Cda.WrapperFactory.SubstanceAdministration(wrapped().substanceAdministration);
      }
      private void propSetSubstanceAdministration(HL7Connect.Cda.SubstanceAdministration value)
      {
        wrapped().substanceAdministration = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
      ///</summary>
      public HL7Connect.Cda.SubstanceAdministration substanceAdministration { get { return propGetSubstanceAdministration(); } set { propSetSubstanceAdministration(value); } }

      ///<summary>
      /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another.
      ///</summary>
      private HL7Connect.Cda.Supply propGetSupply()
      {
        return HL7Connect.Cda.WrapperFactory.Supply(wrapped().supply);
      }
      private void propSetSupply(HL7Connect.Cda.Supply value)
      {
        wrapped().supply = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another.
      ///</summary>
      public HL7Connect.Cda.Supply supply { get { return propGetSupply(); } set { propSetSupply(value); } }

      ///<summary>
      /// Choice of act, encounter, observation, observationMedia, organizer, procedure_, regionOfInterest, substanceAdministration or supply
      ///</summary>
      private HL7Connect.Cda.ClinicalStatement propGetClinicalStatement()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalStatement(wrapped().clinicalStatement);
      }
      ///<summary>
      /// Choice of act, encounter, observation, observationMedia, organizer, procedure_, regionOfInterest, substanceAdministration or supply
      ///</summary>
      public HL7Connect.Cda.ClinicalStatement clinicalStatement { get { return propGetClinicalStatement(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      private bool propGetContextConductionInd()
      {
        return wrapped().contextConductionInd != 0;
      }
      private void propSetContextConductionInd(bool value)
      {
        wrapped().contextConductionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      public bool contextConductionInd { get { return propGetContextConductionInd(); } set { propSetContextConductionInd(value); } }

      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      private bool propGetHasContextConductionInd()
      {
        return wrapped().HasContextConductionInd != 0;
      }
      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      public bool HasContextConductionInd { get { return propGetHasContextConductionInd(); } }

    }

    ///<summary>
    /// Document sections can nest
    ///</summary>
    public class Component5 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Component5
      ///</summary>
      public Component5() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newComponent5()) {} 

      internal Component5(IcdaComponent5 com) : base(com) {} 

      internal new HCcdaComponent5 wrapped() { return (HCcdaComponent5) com; }

      ///<summary>
      /// Document sections can nest, can override context propagated from the header, and can contain narrative and CDA entries. 
      /// 
      /// The section has an ID attribute. This attribute serves as the target of a linkHtml reference in narrative. All values of attributes of type XML ID must be unique within the document (per the W3C XML specification).
      ///</summary>
      private HL7Connect.Cda.Section propGetSection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().section);
      }
      private void propSetSection(HL7Connect.Cda.Section value)
      {
        wrapped().section = value.wrapped();
      }
      ///<summary>
      /// Document sections can nest, can override context propagated from the header, and can contain narrative and CDA entries. 
      /// 
      /// The section has an ID attribute. This attribute serves as the target of a linkHtml reference in narrative. All values of attributes of type XML ID must be unique within the document (per the W3C XML specification).
      ///</summary>
      public HL7Connect.Cda.Section section { get { return propGetSection(); } set { propSetSection(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      private bool propGetContextConductionInd()
      {
        return wrapped().contextConductionInd != 0;
      }
      private void propSetContextConductionInd(bool value)
      {
        wrapped().contextConductionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      public bool contextConductionInd { get { return propGetContextConductionInd(); } set { propSetContextConductionInd(value); } }

      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      private bool propGetHasContextConductionInd()
      {
        return wrapped().HasContextConductionInd != 0;
      }
      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      public bool HasContextConductionInd { get { return propGetHasContextConductionInd(); } }

    }

    ///<summary>
    /// This class references the consents associated with this document. The type of consent (e.g. a consent to perform the related ServiceEvent, a consent for the information contained in the document to be released to a third party) is conveyed in Consent.code. Consents referenced in the CDA Header have been finalized (Consent.statusCode must equal "completed") and should be on file.
    ///</summary>
    public class Consent : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Consent
      ///</summary>
      public Consent() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newConsent()) {} 

      internal Consent(IcdaConsent com) : base(com) {} 

      internal new HCcdaConsent wrapped() { return (HCcdaConsent) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// used to bring in the LabeledDrug or Material entity that describes the administered substance
    ///</summary>
    public class Consumable : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Consumable
      ///</summary>
      public Consumable() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newConsumable()) {} 

      internal Consumable(IcdaConsumable com) : base(com) {} 

      internal new HCcdaConsumable wrapped() { return (HCcdaConsumable) com; }

      ///<summary>
      /// used to bring in the LabeledDrug or Material entity that describes the administered substance
      ///</summary>
      private HL7Connect.Cda.ManufacturedProduct propGetManufacturedProduct()
      {
        return HL7Connect.Cda.WrapperFactory.ManufacturedProduct(wrapped().manufacturedProduct);
      }
      private void propSetManufacturedProduct(HL7Connect.Cda.ManufacturedProduct value)
      {
        wrapped().manufacturedProduct = value.wrapped();
      }
      ///<summary>
      /// used to bring in the LabeledDrug or Material entity that describes the administered substance
      ///</summary>
      public HL7Connect.Cda.ManufacturedProduct manufacturedProduct { get { return propGetManufacturedProduct(); } set { propSetManufacturedProduct(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// a condition that must hold true before some over activity occurs
    ///</summary>
    public class Criterion : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Criterion
      ///</summary>
      public Criterion() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCriterion()) {} 

      internal Criterion(IcdaCriterion com) : base(com) {} 

      internal new HCcdaCriterion wrapped() { return (HCcdaCriterion) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      private HL7Connect.Cda.ANY propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ANY(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.ANY value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      public HL7Connect.Cda.ANY value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// Represents the organization that is in charge of maintaining the document. The custodian is the steward that is entrusted with the care of the document. Every CDA document has exactly one custodian.
    ///</summary>
    public class Custodian : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Custodian
      ///</summary>
      public Custodian() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCustodian()) {} 

      internal Custodian(IcdaCustodian com) : base(com) {} 

      internal new HCcdaCustodian wrapped() { return (HCcdaCustodian) com; }

      ///<summary>
      /// The actual custodian
      ///</summary>
      private HL7Connect.Cda.AssignedCustodian propGetAssignedCustodian()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedCustodian(wrapped().assignedCustodian);
      }
      private void propSetAssignedCustodian(HL7Connect.Cda.AssignedCustodian value)
      {
        wrapped().assignedCustodian = value.wrapped();
      }
      ///<summary>
      /// The actual custodian
      ///</summary>
      public HL7Connect.Cda.AssignedCustodian assignedCustodian { get { return propGetAssignedCustodian(); } set { propSetAssignedCustodian(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// The steward organization is an entity scoping the role of AssignedCustodian, and has a required CustodianOrganization.id
    ///</summary>
    public class CustodianOrganization : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA CustodianOrganization
      ///</summary>
      public CustodianOrganization() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newCustodianOrganization()) {} 

      internal CustodianOrganization(IcdaCustodianOrganization com) : base(com) {} 

      internal new HCcdaCustodianOrganization wrapped() { return (HCcdaCustodianOrganization) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.EN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.EN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.EN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity.
      ///</summary>
      private HL7Connect.Cda.TEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.TEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.TEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity.
      ///</summary>
      public HL7Connect.Cda.TEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The postal and/or residential address of an organization.
      ///</summary>
      private HL7Connect.Cda.AD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.AD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.AD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The postal and/or residential address of an organization.
      ///</summary>
      public HL7Connect.Cda.AD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// Represents the participant who has transformed a dictated note into text.
    ///</summary>
    public class DataEnterer : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA DataEnterer
      ///</summary>
      public DataEnterer() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newDataEnterer()) {} 

      internal DataEnterer(IcdaDataEnterer com) : base(com) {} 

      internal new HCcdaDataEnterer wrapped() { return (HCcdaDataEnterer) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.TS propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.TS value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.TS time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// Represents the actual participant who has transformed a dictated note into text.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// Represents the actual participant who has transformed a dictated note into text.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// An entity used in an activity, without being substantially changed through that activity.
    ///</summary>
    public class Device : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Device
      ///</summary>
      public Device() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newDevice()) {} 

      internal Device(IcdaDevice com) : base(com) {} 

      internal new HCcdaDevice wrapped() { return (HCcdaDevice) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The human designated moniker for a device assigned by the manufacturer.                                                      Examples: Perkin Elmer 400 Inductively Coupled Plasma Unit
      ///</summary>
      private HL7Connect.Cda.SC propGetManufacturerModelName()
      {
        return HL7Connect.Cda.WrapperFactory.SC(wrapped().manufacturerModelName);
      }
      private void propSetManufacturerModelName(HL7Connect.Cda.SC value)
      {
        wrapped().manufacturerModelName = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The human designated moniker for a device assigned by the manufacturer.                                                      Examples: Perkin Elmer 400 Inductively Coupled Plasma Unit
      ///</summary>
      public HL7Connect.Cda.SC manufacturerModelName { get { return propGetManufacturerModelName(); } set { propSetManufacturerModelName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The moniker, version and release of the software that operates the device as assigned by the software manufacturer or developer.                                                      Examples: Agilent Technologies Chemstation A.08.xx
      ///</summary>
      private HL7Connect.Cda.SC propGetSoftwareName()
      {
        return HL7Connect.Cda.WrapperFactory.SC(wrapped().softwareName);
      }
      private void propSetSoftwareName(HL7Connect.Cda.SC value)
      {
        wrapped().softwareName = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The moniker, version and release of the software that operates the device as assigned by the software manufacturer or developer.                                                      Examples: Agilent Technologies Chemstation A.08.xx
      ///</summary>
      public HL7Connect.Cda.SC softwareName { get { return propGetSoftwareName(); } set { propSetSoftwareName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// represents the main Act, such as a colonoscopy or an appendectomy, being documented.
    ///</summary>
    public class DocumentationOf : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA DocumentationOf
      ///</summary>
      public DocumentationOf() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newDocumentationOf()) {} 

      internal DocumentationOf(IcdaDocumentationOf com) : base(com) {} 

      internal new HCcdaDocumentationOf wrapped() { return (HCcdaDocumentationOf) com; }

      ///<summary>
      /// represents the main Act, such as a colonoscopy or an appendectomy, being documented. 
      /// 
      /// In some cases, the ServiceEvent is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "History and Physical Report" and the procedure being documented is a "History and Physical" act. A ServiceEvent can further specialize the act inherent in the ClinicalDocument.code, such as where the ClinicalDocument.code is simply "Procedure Report" and the procedure was a "colonoscopy". If ServiceEvent is included, it must be equivalent to or further specialize the value inherent in the ClinicalDocument.code, and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. ServiceEvent.effectiveTime can be used to indicate the time the actual event (as opposed to the encounter surrounding the event) took place.
      ///</summary>
      private HL7Connect.Cda.ServiceEvent propGetServiceEvent()
      {
        return HL7Connect.Cda.WrapperFactory.ServiceEvent(wrapped().serviceEvent);
      }
      private void propSetServiceEvent(HL7Connect.Cda.ServiceEvent value)
      {
        wrapped().serviceEvent = value.wrapped();
      }
      ///<summary>
      /// represents the main Act, such as a colonoscopy or an appendectomy, being documented. 
      /// 
      /// In some cases, the ServiceEvent is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "History and Physical Report" and the procedure being documented is a "History and Physical" act. A ServiceEvent can further specialize the act inherent in the ClinicalDocument.code, such as where the ClinicalDocument.code is simply "Procedure Report" and the procedure was a "colonoscopy". If ServiceEvent is included, it must be equivalent to or further specialize the value inherent in the ClinicalDocument.code, and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. ServiceEvent.effectiveTime can be used to indicate the time the actual event (as opposed to the encounter surrounding the event) took place.
      ///</summary>
      public HL7Connect.Cda.ServiceEvent serviceEvent { get { return propGetServiceEvent(); } set { propSetServiceEvent(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// This optional class represents the setting of the clinical encounter during which the documented act(s) or ServiceEvent occurred. Documents are not necessarily generated during an encounter, such as when a clinician, in response to an abnormal lab result, attempts to contact the patient but can't, and writes a Progress Note. 
    /// 
    /// In some cases, the setting of the encounter is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "Diabetes Clinic Progress Note". The setting of an encounter can also be transmitted in the HealthCareFacility.code attribute. If HealthCareFacility.code is sent, it should be equivalent to or further specialize the value inherent in the ClinicalDocument.code (such as where the ClinicalDocument.code is simply "Clinic Progress Note" and the value of HealthCareFacility.code is "cardiology clinic"), and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. EncompassingEncounter.dischargeDispositionCode can be used to depict the disposition of the patient at the time of hospital discharge (e.g., discharged to home, expired, against medical advice, etc.).
    ///</summary>
    public class EncompassingEncounter : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA EncompassingEncounter
      ///</summary>
      public EncompassingEncounter() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEncompassingEncounter()) {} 

      internal EncompassingEncounter(IcdaEncompassingEncounter com) : base(com) {} 

      internal new HCcdaEncompassingEncounter wrapped() { return (HCcdaEncompassingEncounter) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code depicting the disposition of the patient at the time of discharge (e.g., discharged to home, expired, against medical advice, etc.). While the encounter is still "active" (the encounter doesn't have an end date yet) this attribute should be interpreted as the expected discharge disposition. When the encounter is "completed" this field contains the actual discharge disposition.
      ///</summary>
      private HL7Connect.Cda.CD propGetDischargeDispositionCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().dischargeDispositionCode);
      }
      private void propSetDischargeDispositionCode(HL7Connect.Cda.CD value)
      {
        wrapped().dischargeDispositionCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code depicting the disposition of the patient at the time of discharge (e.g., discharged to home, expired, against medical advice, etc.). While the encounter is still "active" (the encounter doesn't have an end date yet) this attribute should be interpreted as the expected discharge disposition. When the encounter is "completed" this field contains the actual discharge disposition.
      ///</summary>
      public HL7Connect.Cda.CD dischargeDispositionCode { get { return propGetDischargeDispositionCode(); } set { propSetDischargeDispositionCode(value); } }

      ///<summary>
      /// The responsibleParty participant represents the participant having primary legal responsibility for the encounter. This differs from the legalAuthenticator participant in that the legalAuthenticator may or may not be the responsible party, and is serving a medical records function by signing off on the document, moving it into a completed state.
      ///</summary>
      private HL7Connect.Cda.ResponsibleParty propGetResponsibleParty()
      {
        return HL7Connect.Cda.WrapperFactory.ResponsibleParty(wrapped().responsibleParty);
      }
      private void propSetResponsibleParty(HL7Connect.Cda.ResponsibleParty value)
      {
        wrapped().responsibleParty = value.wrapped();
      }
      ///<summary>
      /// The responsibleParty participant represents the participant having primary legal responsibility for the encounter. This differs from the legalAuthenticator participant in that the legalAuthenticator may or may not be the responsible party, and is serving a medical records function by signing off on the document, moving it into a completed state.
      ///</summary>
      public HL7Connect.Cda.ResponsibleParty responsibleParty { get { return propGetResponsibleParty(); } set { propSetResponsibleParty(value); } }

      ///<summary>
      /// The encounterParticipant participant represents clinicians directly associated with the encounter (e.g. by initiating, terminating, or overseeing it).
      ///</summary>
      private HL7Connect.Cda.EncounterParticipantList propGetEncounterParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.EncounterParticipantList(wrapped().encounterParticipant);
      }
      private void propSetEncounterParticipant(HL7Connect.Cda.EncounterParticipantList value)
      {
        wrapped().encounterParticipant = value.wrapped();
      }
      ///<summary>
      /// The encounterParticipant participant represents clinicians directly associated with the encounter (e.g. by initiating, terminating, or overseeing it).
      ///</summary>
      public HL7Connect.Cda.EncounterParticipantList encounterParticipant { get { return propGetEncounterParticipant(); } set { propSetEncounterParticipant(value); } }

      ///<summary>
      /// relates a healthcare facility (HealthCareFacility class) to the encounter to indicate where the encounter took place. The entity playing the role of HealthCareFacility is a place (Place class). The entity scoping the HealthCareFacility role is an organization (Organization class). 
      /// 
      /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow. When the location is an organization, this is indicated by the presence of a scoping Organization, without a playing Place.
      ///</summary>
      private HL7Connect.Cda.Location propGetLocation()
      {
        return HL7Connect.Cda.WrapperFactory.Location(wrapped().location);
      }
      private void propSetLocation(HL7Connect.Cda.Location value)
      {
        wrapped().location = value.wrapped();
      }
      ///<summary>
      /// relates a healthcare facility (HealthCareFacility class) to the encounter to indicate where the encounter took place. The entity playing the role of HealthCareFacility is a place (Place class). The entity scoping the HealthCareFacility role is an organization (Organization class). 
      /// 
      /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow. When the location is an organization, this is indicated by the presence of a scoping Organization, without a playing Place.
      ///</summary>
      public HL7Connect.Cda.Location location { get { return propGetLocation(); } set { propSetLocation(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
    ///</summary>
    public class Encounter : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA Encounter
      ///</summary>
      public Encounter() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEncounter()) {} 

      internal Encounter(IcdaEncounter com) : base(com) {} 

      internal new HCcdaEncounter wrapped() { return (HCcdaEncounter) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      private HL7Connect.Cda.CD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.CD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      public HL7Connect.Cda.CD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

    }

    ///<summary>
    /// The encounterParticipant participant represents clinicians directly associated with the encounter (e.g. by initiating, terminating, or overseeing it).
    ///</summary>
    public class EncounterParticipant : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA EncounterParticipant
      ///</summary>
      public EncounterParticipant() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEncounterParticipant()) {} 

      internal EncounterParticipant(IcdaEncounterParticipant com) : base(com) {} 

      internal new HCcdaEncounterParticipant wrapped() { return (HCcdaEncounterParticipant) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

    }

    ///<summary>
    /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role.
    ///</summary>
    public class Entity : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Entity
      ///</summary>
      public Entity() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEntity()) {} 

      internal Entity(IcdaEntity com) : base(com) {} 

      internal new HCcdaEntity wrapped() { return (HCcdaEntity) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A textual or multimedia depiction of the Entity.                                                      Discussion: The content of the description is not considered part of the functional information communicated between systems. Descriptions are meant to be shown to interested human individuals. All information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Rationale: Names and descriptions of entities are typically more meaningful to human viewers than numeric, mnemonic or abbreviated code values. The description allows for additional context about the entity to be conveyed to human viewers without impacting the functional components of the message.
      ///</summary>
      private HL7Connect.Cda.ED propGetDesc()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Desc);
      }
      private void propSetDesc(HL7Connect.Cda.ED value)
      {
        wrapped().Desc = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A textual or multimedia depiction of the Entity.                                                      Discussion: The content of the description is not considered part of the functional information communicated between systems. Descriptions are meant to be shown to interested human individuals. All information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Rationale: Names and descriptions of entities are typically more meaningful to human viewers than numeric, mnemonic or abbreviated code values. The description allows for additional context about the entity to be conveyed to human viewers without impacting the functional components of the message.
      ///</summary>
      public HL7Connect.Cda.ED desc { get { return propGetDesc(); } set { propSetDesc(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// In terms of the relationship between a section and its entries, CDA defines a default general case, and a more specific case that can be used when applicable. 
    /// 
    /// The entry relationship is defaulted to "COMP" (component), for the general case where the only assertion is that the related entries are contained within the source section and no other semantics are implied. In this case, the narrative is the original authenticated content. The CDA entries are created by various techniques (e.g., natural language processing, a human coder, a structured data entry tool that outputs both entries and a text report). The method of entry creation may be indicated by the entry participants (e.g., by identifying the algorithm or person that generated them). Relationships between various entries (such as two Observations or an Observation and an ObservationMedia) are encoded using the relationship types defined in entryRelationship.
    ///</summary>
    public class Entry : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Entry
      ///</summary>
      public Entry() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEntry()) {} 

      internal Entry(IcdaEntry com) : base(com) {} 

      internal new HCcdaEntry wrapped() { return (HCcdaEntry) com; }

      ///<summary>
      /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
      ///</summary>
      private HL7Connect.Cda.Act propGetAct()
      {
        return HL7Connect.Cda.WrapperFactory.Act(wrapped().act);
      }
      private void propSetAct(HL7Connect.Cda.Act value)
      {
        wrapped().act = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
      ///</summary>
      public HL7Connect.Cda.Act act { get { return propGetAct(); } set { propSetAct(value); } }

      ///<summary>
      /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
      ///</summary>
      private HL7Connect.Cda.Encounter propGetEncounter()
      {
        return HL7Connect.Cda.WrapperFactory.Encounter(wrapped().encounter);
      }
      private void propSetEncounter(HL7Connect.Cda.Encounter value)
      {
        wrapped().encounter = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
      ///</summary>
      public HL7Connect.Cda.Encounter encounter { get { return propGetEncounter(); } set { propSetEncounter(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class, used for representing coded and other observations.
      ///</summary>
      private HL7Connect.Cda.Observation propGetObservation()
      {
        return HL7Connect.Cda.WrapperFactory.Observation(wrapped().observation);
      }
      private void propSetObservation(HL7Connect.Cda.Observation value)
      {
        wrapped().observation = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class, used for representing coded and other observations.
      ///</summary>
      public HL7Connect.Cda.Observation observation { get { return propGetObservation(); } set { propSetObservation(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
      ///</summary>
      private HL7Connect.Cda.ObservationMedia propGetObservationMedia()
      {
        return HL7Connect.Cda.WrapperFactory.ObservationMedia(wrapped().observationMedia);
      }
      private void propSetObservationMedia(HL7Connect.Cda.ObservationMedia value)
      {
        wrapped().observationMedia = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
      ///</summary>
      public HL7Connect.Cda.ObservationMedia observationMedia { get { return propGetObservationMedia(); } set { propSetObservationMedia(value); } }

      ///<summary>
      /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
      ///</summary>
      private HL7Connect.Cda.Organizer propGetOrganizer()
      {
        return HL7Connect.Cda.WrapperFactory.Organizer(wrapped().organizer);
      }
      private void propSetOrganizer(HL7Connect.Cda.Organizer value)
      {
        wrapped().organizer = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
      ///</summary>
      public HL7Connect.Cda.Organizer organizer { get { return propGetOrganizer(); } set { propSetOrganizer(value); } }

      ///<summary>
      /// A derivative of the RIM Procedure class, used for representing procedures.
      ///</summary>
      private HL7Connect.Cda.Procedure propGetProcedure()
      {
        return HL7Connect.Cda.WrapperFactory.Procedure(wrapped().procedure_);
      }
      private void propSetProcedure(HL7Connect.Cda.Procedure value)
      {
        wrapped().procedure_ = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Procedure class, used for representing procedures.
      ///</summary>
      public HL7Connect.Cda.Procedure procedure { get { return propGetProcedure(); } set { propSetProcedure(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
      ///</summary>
      private HL7Connect.Cda.RegionOfInterest propGetRegionOfInterest()
      {
        return HL7Connect.Cda.WrapperFactory.RegionOfInterest(wrapped().regionOfInterest);
      }
      private void propSetRegionOfInterest(HL7Connect.Cda.RegionOfInterest value)
      {
        wrapped().regionOfInterest = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
      ///</summary>
      public HL7Connect.Cda.RegionOfInterest regionOfInterest { get { return propGetRegionOfInterest(); } set { propSetRegionOfInterest(value); } }

      ///<summary>
      /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
      ///</summary>
      private HL7Connect.Cda.SubstanceAdministration propGetSubstanceAdministration()
      {
        return HL7Connect.Cda.WrapperFactory.SubstanceAdministration(wrapped().substanceAdministration);
      }
      private void propSetSubstanceAdministration(HL7Connect.Cda.SubstanceAdministration value)
      {
        wrapped().substanceAdministration = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
      ///</summary>
      public HL7Connect.Cda.SubstanceAdministration substanceAdministration { get { return propGetSubstanceAdministration(); } set { propSetSubstanceAdministration(value); } }

      ///<summary>
      /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another.
      ///</summary>
      private HL7Connect.Cda.Supply propGetSupply()
      {
        return HL7Connect.Cda.WrapperFactory.Supply(wrapped().supply);
      }
      private void propSetSupply(HL7Connect.Cda.Supply value)
      {
        wrapped().supply = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another.
      ///</summary>
      public HL7Connect.Cda.Supply supply { get { return propGetSupply(); } set { propSetSupply(value); } }

      ///<summary>
      /// Choice of act, encounter, observation, observationMedia, organizer, procedure_, regionOfInterest, substanceAdministration or supply
      ///</summary>
      private HL7Connect.Cda.ClinicalStatement propGetClinicalStatement()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalStatement(wrapped().clinicalStatement);
      }
      ///<summary>
      /// Choice of act, encounter, observation, observationMedia, organizer, procedure_, regionOfInterest, substanceAdministration or supply
      ///</summary>
      public HL7Connect.Cda.ClinicalStatement clinicalStatement { get { return propGetClinicalStatement(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      private bool propGetContextConductionInd()
      {
        return wrapped().contextConductionInd != 0;
      }
      private void propSetContextConductionInd(bool value)
      {
        wrapped().contextConductionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// If true, associations in the parent act are conducted across the ActRelationship to the child act.                                                      Discussion: Only associations that have been added to the context of an Act and are marked "propagating" will be conducted. (See contextControlCode on ActRelationship and Participation)                        The identification of an Act as a parent or child (and therefore the direction context will be conducted) is determined by how the association is traversed when it is serialized. The first act to be encountered is considered to be the parent. Context conducts across the ActRelationship to the second (child) Act.                        Refer to ActRelationship.contextControlCode for rationale and examples.
      ///</summary>
      public bool contextConductionInd { get { return propGetContextConductionInd(); } set { propSetContextConductionInd(value); } }

      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      private bool propGetHasContextConductionInd()
      {
        return wrapped().HasContextConductionInd != 0;
      }
      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      public bool HasContextConductionInd { get { return propGetHasContextConductionInd(); } }

    }

    ///<summary>
    /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
    /// 
    /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
    ///</summary>
    public class EntryRelationship : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA EntryRelationship
      ///</summary>
      public EntryRelationship() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newEntryRelationship()) {} 

      internal EntryRelationship(IcdaEntryRelationship com) : base(com) {} 

      internal new HCcdaEntryRelationship wrapped() { return (HCcdaEntryRelationship) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An integer specifying the relative sequential or temporal ordering of this relationship among other like-types relationships having the same source Act.                                                      Discussion: This attribute is part of the workflow control suite of attributes. An action plan is a composite Act with component Acts. In a sequential plan, each component has a sequenceNumber that specifies the ordering of the plan steps. Multiple components with the same sequenceNumber make a branch. Branches can be exclusive (case-switch) or can indicate parallel processes indicated by the splitCode.                        If value is null, the relative position of the target Act is unspecified. (i.e. it may occur anywhere.)                        Use the 'priorityNumber' attribute to indicate relative preference instead of order of occurrence.
      ///</summary>
      private HL7Connect.Cda.INT propGetSequenceNumber()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().sequenceNumber);
      }
      private void propSetSequenceNumber(HL7Connect.Cda.INT value)
      {
        wrapped().sequenceNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An integer specifying the relative sequential or temporal ordering of this relationship among other like-types relationships having the same source Act.                                                      Discussion: This attribute is part of the workflow control suite of attributes. An action plan is a composite Act with component Acts. In a sequential plan, each component has a sequenceNumber that specifies the ordering of the plan steps. Multiple components with the same sequenceNumber make a branch. Branches can be exclusive (case-switch) or can indicate parallel processes indicated by the splitCode.                        If value is null, the relative position of the target Act is unspecified. (i.e. it may occur anywhere.)                        Use the 'priorityNumber' attribute to indicate relative preference instead of order of occurrence.
      ///</summary>
      public HL7Connect.Cda.INT sequenceNumber { get { return propGetSequenceNumber(); } set { propSetSequenceNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// This attribute indicates whether or not the source Act is intended to be interpreted independently of the target Act. The indicator cannot prevent an individual or application from separating the Acts, but indicates the author's desire and willingness to attest to the content of the source Act if separated from the target Act. Note that the default for this attribute will typically be "TRUE". Also note that this attribute is orthogonal and unrelated to the RIM's context/inheritance mechanism. If the context of an Act is propagated to nested Acts, it is assumed that those nested Acts are not intended to be interpreted without the propagated context.
      ///</summary>
      private HL7Connect.Cda.BL propGetSeperatableInd()
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().seperatableInd);
      }
      private void propSetSeperatableInd(HL7Connect.Cda.BL value)
      {
        wrapped().seperatableInd = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// This attribute indicates whether or not the source Act is intended to be interpreted independently of the target Act. The indicator cannot prevent an individual or application from separating the Acts, but indicates the author's desire and willingness to attest to the content of the source Act if separated from the target Act. Note that the default for this attribute will typically be "TRUE". Also note that this attribute is orthogonal and unrelated to the RIM's context/inheritance mechanism. If the context of an Act is propagated to nested Acts, it is assumed that those nested Acts are not intended to be interpreted without the propagated context.
      ///</summary>
      public HL7Connect.Cda.BL seperatableInd { get { return propGetSeperatableInd(); } set { propSetSeperatableInd(value); } }

      ///<summary>
      /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
      ///</summary>
      private HL7Connect.Cda.Act propGetAct()
      {
        return HL7Connect.Cda.WrapperFactory.Act(wrapped().act);
      }
      private void propSetAct(HL7Connect.Cda.Act value)
      {
        wrapped().act = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Act class, to be used when the other more specific classes aren't appropriate
      ///</summary>
      public HL7Connect.Cda.Act act { get { return propGetAct(); } set { propSetAct(value); } }

      ///<summary>
      /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
      ///</summary>
      private HL7Connect.Cda.Encounter propGetEncounter()
      {
        return HL7Connect.Cda.WrapperFactory.Encounter(wrapped().encounter);
      }
      private void propSetEncounter(HL7Connect.Cda.Encounter value)
      {
        wrapped().encounter = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM PatientEncounter class, used to represent related encounters, such as follow-up visits or referenced past encounters
      ///</summary>
      public HL7Connect.Cda.Encounter encounter { get { return propGetEncounter(); } set { propSetEncounter(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class, used for representing coded and other observations.
      ///</summary>
      private HL7Connect.Cda.Observation propGetObservation()
      {
        return HL7Connect.Cda.WrapperFactory.Observation(wrapped().observation);
      }
      private void propSetObservation(HL7Connect.Cda.Observation value)
      {
        wrapped().observation = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class, used for representing coded and other observations.
      ///</summary>
      public HL7Connect.Cda.Observation observation { get { return propGetObservation(); } set { propSetObservation(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
      ///</summary>
      private HL7Connect.Cda.ObservationMedia propGetObservationMedia()
      {
        return HL7Connect.Cda.WrapperFactory.ObservationMedia(wrapped().observationMedia);
      }
      private void propSetObservationMedia(HL7Connect.Cda.ObservationMedia value)
      {
        wrapped().observationMedia = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
      ///</summary>
      public HL7Connect.Cda.ObservationMedia observationMedia { get { return propGetObservationMedia(); } set { propSetObservationMedia(value); } }

      ///<summary>
      /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
      ///</summary>
      private HL7Connect.Cda.Organizer propGetOrganizer()
      {
        return HL7Connect.Cda.WrapperFactory.Organizer(wrapped().organizer);
      }
      private void propSetOrganizer(HL7Connect.Cda.Organizer value)
      {
        wrapped().organizer = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
      ///</summary>
      public HL7Connect.Cda.Organizer organizer { get { return propGetOrganizer(); } set { propSetOrganizer(value); } }

      ///<summary>
      /// A derivative of the RIM Procedure class, used for representing procedures.
      ///</summary>
      private HL7Connect.Cda.Procedure propGetProcedure()
      {
        return HL7Connect.Cda.WrapperFactory.Procedure(wrapped().procedure_);
      }
      private void propSetProcedure(HL7Connect.Cda.Procedure value)
      {
        wrapped().procedure_ = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Procedure class, used for representing procedures.
      ///</summary>
      public HL7Connect.Cda.Procedure procedure { get { return propGetProcedure(); } set { propSetProcedure(value); } }

      ///<summary>
      /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
      ///</summary>
      private HL7Connect.Cda.RegionOfInterest propGetRegionOfInterest()
      {
        return HL7Connect.Cda.WrapperFactory.RegionOfInterest(wrapped().regionOfInterest);
      }
      private void propSetRegionOfInterest(HL7Connect.Cda.RegionOfInterest value)
      {
        wrapped().regionOfInterest = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
      ///</summary>
      public HL7Connect.Cda.RegionOfInterest regionOfInterest { get { return propGetRegionOfInterest(); } set { propSetRegionOfInterest(value); } }

      ///<summary>
      /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
      ///</summary>
      private HL7Connect.Cda.SubstanceAdministration propGetSubstanceAdministration()
      {
        return HL7Connect.Cda.WrapperFactory.SubstanceAdministration(wrapped().substanceAdministration);
      }
      private void propSetSubstanceAdministration(HL7Connect.Cda.SubstanceAdministration value)
      {
        wrapped().substanceAdministration = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
      ///</summary>
      public HL7Connect.Cda.SubstanceAdministration substanceAdministration { get { return propGetSubstanceAdministration(); } set { propSetSubstanceAdministration(value); } }

      ///<summary>
      /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another.
      ///</summary>
      private HL7Connect.Cda.Supply propGetSupply()
      {
        return HL7Connect.Cda.WrapperFactory.Supply(wrapped().supply);
      }
      private void propSetSupply(HL7Connect.Cda.Supply value)
      {
        wrapped().supply = value.wrapped();
      }
      ///<summary>
      /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another.
      ///</summary>
      public HL7Connect.Cda.Supply supply { get { return propGetSupply(); } set { propSetSupply(value); } }

      ///<summary>
      /// Choice of act, encounter, observation, observationMedia, organizer, procedure_, regionOfInterest, substanceAdministration or supply
      ///</summary>
      private HL7Connect.Cda.ClinicalStatement propGetClinicalStatement()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalStatement(wrapped().clinicalStatement);
      }
      ///<summary>
      /// Choice of act, encounter, observation, observationMedia, organizer, procedure_, regionOfInterest, substanceAdministration or supply
      ///</summary>
      public HL7Connect.Cda.ClinicalStatement clinicalStatement { get { return propGetClinicalStatement(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

      ///<summary>
      /// The entryRelationship.inversionInd can be set to "true" to indicate that the relationship should be interpreted as if the roles of the source and target entries were reversed. In the example in the table above, "treadmill test" RSON (has reason) "chest pain". Inverted, this would have "chest pain" as the source and "treadmill test" as the target: "chest pain" RSON (inverted) "treadmill test". Inversion can be useful when the current context is describing the target of an act relationship that needs to be related back to the source.
      ///</summary>
      private bool propGetInversionInd()
      {
        return wrapped().inversionInd != 0;
      }
      private void propSetInversionInd(bool value)
      {
        wrapped().inversionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// The entryRelationship.inversionInd can be set to "true" to indicate that the relationship should be interpreted as if the roles of the source and target entries were reversed. In the example in the table above, "treadmill test" RSON (has reason) "chest pain". Inverted, this would have "chest pain" as the source and "treadmill test" as the target: "chest pain" RSON (inverted) "treadmill test". Inversion can be useful when the current context is describing the target of an act relationship that needs to be related back to the source.
      ///</summary>
      public bool inversionInd { get { return propGetInversionInd(); } set { propSetInversionInd(value); } }

      ///<summary>
      /// false if inversionInd is null, true if inversionInd is either true or false
      ///</summary>
      private bool propGetHasInversionInd()
      {
        return wrapped().HasInversionInd != 0;
      }
      ///<summary>
      /// false if inversionInd is null, true if inversionInd is either true or false
      ///</summary>
      public bool HasInversionInd { get { return propGetHasInversionInd(); } }

      ///<summary>
      /// The entryRelationship.contextConductionInd differs from the otherwise common use of this attribute (see CDA Context (ï¿½ 4.4 )) in that in all other cases where this attribute is used, the value is fixed at "true", whereas here the value is defaulted to "true", and can be changed to "false" when referencing an entry in the same document. Setting the context conduction to false when referencing an entry in the same document keeps clear the fact that the referenced object retains its original context.
      ///</summary>
      private bool propGetContextConductionInd()
      {
        return wrapped().contextConductionInd != 0;
      }
      private void propSetContextConductionInd(bool value)
      {
        wrapped().contextConductionInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// The entryRelationship.contextConductionInd differs from the otherwise common use of this attribute (see CDA Context (ï¿½ 4.4 )) in that in all other cases where this attribute is used, the value is fixed at "true", whereas here the value is defaulted to "true", and can be changed to "false" when referencing an entry in the same document. Setting the context conduction to false when referencing an entry in the same document keeps clear the fact that the referenced object retains its original context.
      ///</summary>
      public bool contextConductionInd { get { return propGetContextConductionInd(); } set { propSetContextConductionInd(value); } }

      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      private bool propGetHasContextConductionInd()
      {
        return wrapped().HasContextConductionInd != 0;
      }
      ///<summary>
      /// false if contextConductionInd is null, true if contextConductionInd is either true or false
      ///</summary>
      public bool HasContextConductionInd { get { return propGetHasContextConductionInd(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator that asserts that the meaning of the link is negated.                                                      Examples: If the relationship without negation specifies that Act A has Act B as a component, then the negation indicator specifies that Act A does *not* have Act B as a component. If B is a reason for A, then negation means that B is *not* a reason for A. If B is a pre-condition for A, then negation means that B is *not* a precondition for A.                                                      Discussion: As the examples show, the use of this attribute is quite limited, notably contrast this with the Act.negationInd that actually requires that the described Act not exist, not be done, etc. whereas the ActRelationship.negationInd merely negates this relationship between source and target act, but does not change the meaning of each Act. This is mostly used for clarifying statements.                         Note also the difference between negation and the contrary. A contraindication is the contrary of an indication (reason) but not the negation of the reason. The fact that lower back pain is not a reason to prescribe antibiotics doesn't mean that antibiotics are contraindicated with lower back pain.
      ///</summary>
      private bool propGetNegationInd()
      {
        return wrapped().negationInd != 0;
      }
      private void propSetNegationInd(bool value)
      {
        wrapped().negationInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator that asserts that the meaning of the link is negated.                                                      Examples: If the relationship without negation specifies that Act A has Act B as a component, then the negation indicator specifies that Act A does *not* have Act B as a component. If B is a reason for A, then negation means that B is *not* a reason for A. If B is a pre-condition for A, then negation means that B is *not* a precondition for A.                                                      Discussion: As the examples show, the use of this attribute is quite limited, notably contrast this with the Act.negationInd that actually requires that the described Act not exist, not be done, etc. whereas the ActRelationship.negationInd merely negates this relationship between source and target act, but does not change the meaning of each Act. This is mostly used for clarifying statements.                         Note also the difference between negation and the contrary. A contraindication is the contrary of an indication (reason) but not the negation of the reason. The fact that lower back pain is not a reason to prescribe antibiotics doesn't mean that antibiotics are contraindicated with lower back pain.
      ///</summary>
      public bool negationInd { get { return propGetNegationInd(); } set { propSetNegationInd(value); } }

      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      private bool propGetHasNegationInd()
      {
        return wrapped().HasNegationInd != 0;
      }
      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      public bool HasNegationInd { get { return propGetHasNegationInd(); } }

    }

    ///<summary>
    /// ExternalDocument is a derivative of the RIM Document class, used for representing external documents. ExternalDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the external document
    ///</summary>
    public class ExternalActChoice : HL7Connect.Cda.CDABase
    {

      internal ExternalActChoice(IcdaExternalActChoice com) : base(com) {} 

      internal new HCcdaExternalActChoice wrapped() { return (HCcdaExternalActChoice) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// ExternalAct is a derivative of the RIM Act class, to be used when the other more specific classes are not appropriate.
    ///</summary>
    public class ExternalAct : HL7Connect.Cda.ExternalActChoice
    {

      ///<summary>
      /// Create a CDA ExternalAct
      ///</summary>
      public ExternalAct() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newExternalAct()) {} 

      internal ExternalAct(IcdaExternalAct com) : base(com) {} 

      internal new HCcdaExternalAct wrapped() { return (HCcdaExternalAct) com; }

    }

    ///<summary>
    /// ExternalDocument is a derivative of the RIM Document class, used for representing external documents. ExternalDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the external document
    ///</summary>
    public class ExternalDocument : HL7Connect.Cda.ExternalActChoice
    {

      ///<summary>
      /// Create a CDA ExternalDocument
      ///</summary>
      public ExternalDocument() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newExternalDocument()) {} 

      internal ExternalDocument(IcdaExternalDocument com) : base(com) {} 

      internal new HCcdaExternalDocument wrapped() { return (HCcdaExternalDocument) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A report identifier that remains constant across all revisions that derive from a common original.                         An original report is the first version of a report. It gets a new unique value for setId, and has the value of versionNumber set to equal "1".                         An addendum is an appendage to an existing report that contains supplemental information. The appendage is itself an original report. The parent report being appended is referenced via an ActRelationship, with ActRelationship.typeCode set to equal "APND" (for "appends"). The parent report being appended remains in place and its content and status are unaltered.                         A replacement report replaces an existing report. The replacement report uses the same value for setId as the parent report being replaced, and increments the value of versionNumber by 1. The state of the parent report being replaced should become "superceded", but is still retained in the system for historical reference.
      ///</summary>
      private HL7Connect.Cda.II propGetSetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().setId);
      }
      private void propSetSetId(HL7Connect.Cda.II value)
      {
        wrapped().setId = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A report identifier that remains constant across all revisions that derive from a common original.                         An original report is the first version of a report. It gets a new unique value for setId, and has the value of versionNumber set to equal "1".                         An addendum is an appendage to an existing report that contains supplemental information. The appendage is itself an original report. The parent report being appended is referenced via an ActRelationship, with ActRelationship.typeCode set to equal "APND" (for "appends"). The parent report being appended remains in place and its content and status are unaltered.                         A replacement report replaces an existing report. The replacement report uses the same value for setId as the parent report being replaced, and increments the value of versionNumber by 1. The state of the parent report being replaced should become "superceded", but is still retained in the system for historical reference.
      ///</summary>
      public HL7Connect.Cda.II setId { get { return propGetSetId(); } set { propSetSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Version number is an integer starting at '1' and incrementing by 1. The first instance or original report should always be valued as '1'. The version number value must be incremented by one when a report is replaced, but can also be incremented more often to meet local requirements.
      ///</summary>
      private HL7Connect.Cda.INT propGetVersionNumber()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().versionNumber);
      }
      private void propSetVersionNumber(HL7Connect.Cda.INT value)
      {
        wrapped().versionNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Version number is an integer starting at '1' and incrementing by 1. The first instance or original report should always be valued as '1'. The version number value must be incremented by one when a report is replaced, but can also be incremented more often to meet local requirements.
      ///</summary>
      public HL7Connect.Cda.INT versionNumber { get { return propGetVersionNumber(); } set { propSetVersionNumber(value); } }

    }

    ///<summary>
    /// ExternalObservation is a derivative of the RIM Observation class, used for representing external coded and other observations.
    ///</summary>
    public class ExternalObservation : HL7Connect.Cda.ExternalActChoice
    {

      ///<summary>
      /// Create a CDA ExternalObservation
      ///</summary>
      public ExternalObservation() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newExternalObservation()) {} 

      internal ExternalObservation(IcdaExternalObservation com) : base(com) {} 

      internal new HCcdaExternalObservation wrapped() { return (HCcdaExternalObservation) com; }

    }

    ///<summary>
    /// ExternalProcedure is a derivative of the RIM Procedure class, used for representing external procedures
    ///</summary>
    public class ExternalProcedure : HL7Connect.Cda.ExternalActChoice
    {

      ///<summary>
      /// Create a CDA ExternalProcedure
      ///</summary>
      public ExternalProcedure() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newExternalProcedure()) {} 

      internal ExternalProcedure(IcdaExternalProcedure com) : base(com) {} 

      internal new HCcdaExternalProcedure wrapped() { return (HCcdaExternalProcedure) com; }

    }

    ///<summary>
    /// A patient's guardian is a person or organization in the role of guardian
    ///</summary>
    public class Guardian : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Guardian
      ///</summary>
      public Guardian() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newGuardian()) {} 

      internal Guardian(IcdaGuardian com) : base(com) {} 

      internal new HCcdaGuardian wrapped() { return (HCcdaGuardian) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// person in the role of guardian
      ///</summary>
      private HL7Connect.Cda.Person propGetGuardianPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().guardianPerson);
      }
      private void propSetGuardianPerson(HL7Connect.Cda.Person value)
      {
        wrapped().guardianPerson = value.wrapped();
      }
      ///<summary>
      /// person in the role of guardian
      ///</summary>
      public HL7Connect.Cda.Person guardianPerson { get { return propGetGuardianPerson(); } set { propSetGuardianPerson(value); } }

      ///<summary>
      /// organization in the role of guardian
      ///</summary>
      private HL7Connect.Cda.Organization propGetGuardianOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().guardianOrganization);
      }
      private void propSetGuardianOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().guardianOrganization = value.wrapped();
      }
      ///<summary>
      /// organization in the role of guardian
      ///</summary>
      public HL7Connect.Cda.Organization guardianOrganization { get { return propGetGuardianOrganization(); } set { propSetGuardianOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow.
    ///</summary>
    public class HealthCareFacility : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA HealthCareFacility
      ///</summary>
      public HealthCareFacility() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newHealthCareFacility()) {} 

      internal HealthCareFacility(IcdaHealthCareFacility com) : base(com) {} 

      internal new HCcdaHealthCareFacility wrapped() { return (HCcdaHealthCareFacility) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// The location participant (location class) relates a healthcare facility (HealthCareFacility class) to the encounter to indicate where the encounter took place. The entity playing the role of HealthCareFacility is a place (Place class). The entity scoping the HealthCareFacility role is an organization (Organization class). 
      /// 
      /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow. When the location is an organization, this is indicated by the presence of a serviceProviderOrganization, without a playing Place.
      ///</summary>
      private HL7Connect.Cda.Place propGetLocation()
      {
        return HL7Connect.Cda.WrapperFactory.Place(wrapped().location);
      }
      private void propSetLocation(HL7Connect.Cda.Place value)
      {
        wrapped().location = value.wrapped();
      }
      ///<summary>
      /// The location participant (location class) relates a healthcare facility (HealthCareFacility class) to the encounter to indicate where the encounter took place. The entity playing the role of HealthCareFacility is a place (Place class). The entity scoping the HealthCareFacility role is an organization (Organization class). 
      /// 
      /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow. When the location is an organization, this is indicated by the presence of a serviceProviderOrganization, without a playing Place.
      ///</summary>
      public HL7Connect.Cda.Place location { get { return propGetLocation(); } set { propSetLocation(value); } }

      ///<summary>
      /// Organisation that owns / controls the healthcare facility
      ///</summary>
      private HL7Connect.Cda.Organization propGetServiceProviderOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().serviceProviderOrganization);
      }
      private void propSetServiceProviderOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().serviceProviderOrganization = value.wrapped();
      }
      ///<summary>
      /// Organisation that owns / controls the healthcare facility
      ///</summary>
      public HL7Connect.Cda.Organization serviceProviderOrganization { get { return propGetServiceProviderOrganization(); } set { propSetServiceProviderOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

    }

    ///<summary>
    /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma. 
    /// 
    /// An informant can be a person in one of two roles. The RelatedEntity role is used to represent an informant without a role.id (e.g. a parent or guy on the street). The informant in this case bears some formal or personal relationship to the patient. The role is unscoped, with the assumption that the patient is always the implied scoper. RelatedEntity.code can be used to specify the nature of the relationship. The AssignedEntity role is used for an identified informant, and is scoped by an Organization.
    ///</summary>
    public class Informant12 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Informant12
      ///</summary>
      public Informant12() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newInformant12()) {} 

      internal Informant12(IcdaInformant12 com) : base(com) {} 

      internal new HCcdaInformant12 wrapped() { return (HCcdaInformant12) com; }

      ///<summary>
      /// The AssignedEntity role is used for an identified informant, and is scoped by an Organization.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// The AssignedEntity role is used for an identified informant, and is scoped by an Organization.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// The RelatedEntity role is used to represent an informant without a role.id (e.g. a parent or guy on the street). The informant in this case bears some formal or personal relationship to the patient. The role is unscoped, with the assumption that the patient is always the implied scoper.
      ///</summary>
      private HL7Connect.Cda.RelatedEntity propGetRelatedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.RelatedEntity(wrapped().relatedEntity);
      }
      private void propSetRelatedEntity(HL7Connect.Cda.RelatedEntity value)
      {
        wrapped().relatedEntity = value.wrapped();
      }
      ///<summary>
      /// The RelatedEntity role is used to represent an informant without a role.id (e.g. a parent or guy on the street). The informant in this case bears some formal or personal relationship to the patient. The role is unscoped, with the assumption that the patient is always the implied scoper.
      ///</summary>
      public HL7Connect.Cda.RelatedEntity relatedEntity { get { return propGetRelatedEntity(); } set { propSetRelatedEntity(value); } }

      ///<summary>
      /// Choice of assignedEntity or relatedEntity
      ///</summary>
      private HL7Connect.Cda.InformantChoice propGetInformantChoice()
      {
        return HL7Connect.Cda.WrapperFactory.InformantChoice(wrapped().informantChoice);
      }
      ///<summary>
      /// Choice of assignedEntity or relatedEntity
      ///</summary>
      public HL7Connect.Cda.InformantChoice informantChoice { get { return propGetInformantChoice(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// Represents a recipient who should receive a copy of the document. 
    /// 
    /// NOTE: The information recipient is an entity to whom a copy of a document is directed, at the time of document authorship. It is not the same as the cumulative set of persons to whom the document has subsequently been disclosed, over the life-time of the patient. Such a disclosure list would not be contained within the document, and it outside the scope of CDA.
    ///</summary>
    public class InformationRecipient : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA InformationRecipient
      ///</summary>
      public InformationRecipient() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newInformationRecipient()) {} 

      internal InformationRecipient(IcdaInformationRecipient com) : base(com) {} 

      internal new HCcdaInformationRecipient wrapped() { return (HCcdaInformationRecipient) com; }

      ///<summary>
      /// the recipient who should receive a copy of the document.
      ///</summary>
      private HL7Connect.Cda.IntendedRecipient propGetIntendedRecipient()
      {
        return HL7Connect.Cda.WrapperFactory.IntendedRecipient(wrapped().intendedRecipient);
      }
      private void propSetIntendedRecipient(HL7Connect.Cda.IntendedRecipient value)
      {
        wrapped().intendedRecipient = value.wrapped();
      }
      ///<summary>
      /// the recipient who should receive a copy of the document.
      ///</summary>
      public HL7Connect.Cda.IntendedRecipient intendedRecipient { get { return propGetIntendedRecipient(); } set { propSetIntendedRecipient(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

    }

    ///<summary>
    /// represents an order that is fulfilled by this document. For instance, a provider orders an X-Ray. The X-Ray is performed. A radiologist reads the X-Ray and generates a report. The X-Ray order identifier is transmitted in the Order class, the performed X-Ray procedure is transmitted in the ServiceEvent class, and the ClinicalDocument.code would be valued with "Diagnostic Imaging Report".
    ///</summary>
    public class InFulfillmentOf : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA InFulfillmentOf
      ///</summary>
      public InFulfillmentOf() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newInFulfillmentOf()) {} 

      internal InFulfillmentOf(IcdaInFulfillmentOf com) : base(com) {} 

      internal new HCcdaInFulfillmentOf wrapped() { return (HCcdaInFulfillmentOf) com; }

      ///<summary>
      /// represents an order that is fulfilled by this document. For instance, a provider orders an X-Ray. The X-Ray is performed. A radiologist reads the X-Ray and generates a report. The X-Ray order identifier is transmitted in the Order class, the performed X-Ray procedure is transmitted in the ServiceEvent class, and the ClinicalDocument.code would be valued with "Diagnostic Imaging Report".
      ///</summary>
      private HL7Connect.Cda.Order propGetOrder()
      {
        return HL7Connect.Cda.WrapperFactory.Order(wrapped().order);
      }
      private void propSetOrder(HL7Connect.Cda.Order value)
      {
        wrapped().order = value.wrapped();
      }
      ///<summary>
      /// represents an order that is fulfilled by this document. For instance, a provider orders an X-Ray. The X-Ray is performed. A radiologist reads the X-Ray and generates a report. The X-Ray order identifier is transmitted in the Order class, the performed X-Ray procedure is transmitted in the ServiceEvent class, and the ClinicalDocument.code would be valued with "Diagnostic Imaging Report".
      ///</summary>
      public HL7Connect.Cda.Order order { get { return propGetOrder(); } set { propSetOrder(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// Where a person is the intended recipient, the playing entity is a person, optionally scoped by an organization (Organization class).
    ///</summary>
    public class IntendedRecipient : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA IntendedRecipient
      ///</summary>
      public IntendedRecipient() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newIntendedRecipient()) {} 

      internal IntendedRecipient(IcdaIntendedRecipient com) : base(com) {} 

      internal new HCcdaIntendedRecipient wrapped() { return (HCcdaIntendedRecipient) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// Where a person is the intended recipient, the playing entity is a person, optionally scoped by an organization (Organization class).
      ///</summary>
      private HL7Connect.Cda.Person propGetInformationRecipient()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().informationRecipient);
      }
      private void propSetInformationRecipient(HL7Connect.Cda.Person value)
      {
        wrapped().informationRecipient = value.wrapped();
      }
      ///<summary>
      /// Where a person is the intended recipient, the playing entity is a person, optionally scoped by an organization (Organization class).
      ///</summary>
      public HL7Connect.Cda.Person informationRecipient { get { return propGetInformationRecipient(); } set { propSetInformationRecipient(value); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetReceivedOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().receivedOrganization);
      }
      private void propSetReceivedOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().receivedOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization receivedOrganization { get { return propGetReceivedOrganization(); } set { propSetReceivedOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

    }

    ///<summary>
    /// The LabeledDrug class, which is an Entity class playing the Role of Manufactured Product, identifies the drug that is consumed in the substance administration
    ///</summary>
    public class LabeledDrug : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA LabeledDrug
      ///</summary>
      public LabeledDrug() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newLabeledDrug()) {} 

      internal LabeledDrug(IcdaLabeledDrug com) : base(com) {} 

      internal new HCcdaLabeledDrug wrapped() { return (HCcdaLabeledDrug) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.EN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.EN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.EN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// A patient's language communication skills can be expressed in the associated LanguageCommunication class
    ///</summary>
    public class LanguageCommunication : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA LanguageCommunication
      ///</summary>
      public LanguageCommunication() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newLanguageCommunication()) {} 

      internal LanguageCommunication(IcdaLanguageCommunication com) : base(com) {} 

      internal new HCcdaLanguageCommunication wrapped() { return (HCcdaLanguageCommunication) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing a language for which the Entity has some level of proficiency for written or spoken communication.                                                      Examples: Spanish, Italian, German, English, American Sign, etc.                                                      Discussion: Communication via spoken or written language is not solely restricted to LivingSubjects. Devices that communicate with persons using human language also must specify in which languages they are capable. Automated voice response systems respond to human language and communicate with other devices or persons using human language.                                                       Rationale: Many individuals and devices have the capability to communicate at varying levels in multiple languages. This code specifies a language capability that the entity wishes to make known.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing a language for which the Entity has some level of proficiency for written or spoken communication.                                                      Examples: Spanish, Italian, German, English, American Sign, etc.                                                      Discussion: Communication via spoken or written language is not solely restricted to LivingSubjects. Devices that communicate with persons using human language also must specify in which languages they are capable. Automated voice response systems respond to human language and communicate with other devices or persons using human language.                                                       Rationale: Many individuals and devices have the capability to communicate at varying levels in multiple languages. This code specifies a language capability that the entity wishes to make known.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the method of expression of the language                                                      Examples: expressed spoken, expressed written, expressed signed, received spoken, received written, received signed
      ///</summary>
      private HL7Connect.Cda.CD propGetModeCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().modeCode);
      }
      private void propSetModeCode(HL7Connect.Cda.CD value)
      {
        wrapped().modeCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the method of expression of the language                                                      Examples: expressed spoken, expressed written, expressed signed, received spoken, received written, received signed
      ///</summary>
      public HL7Connect.Cda.CD modeCode { get { return propGetModeCode(); } set { propSetModeCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the level of proficiency in a language.                                                      Examples: excellent, good, fair, poor
      ///</summary>
      private HL7Connect.Cda.CD propGetProficiencyLevelCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().proficiencyLevelCode);
      }
      private void propSetProficiencyLevelCode(HL7Connect.Cda.CD value)
      {
        wrapped().proficiencyLevelCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the level of proficiency in a language.                                                      Examples: excellent, good, fair, poor
      ///</summary>
      public HL7Connect.Cda.CD proficiencyLevelCode { get { return propGetProficiencyLevelCode(); } set { propSetProficiencyLevelCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator specifying whether or not the language is preferred by the entity for the associated mode.
      ///</summary>
      private HL7Connect.Cda.BL propGetPreferenceInd()
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().preferenceInd);
      }
      private void propSetPreferenceInd(HL7Connect.Cda.BL value)
      {
        wrapped().preferenceInd = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator specifying whether or not the language is preferred by the entity for the associated mode.
      ///</summary>
      public HL7Connect.Cda.BL preferenceInd { get { return propGetPreferenceInd(); } set { propSetPreferenceInd(value); } }

    }

    ///<summary>
    /// Represents a participant who has legally authenticated the document. 
    /// 
    /// The CDA is a standard that specifies the structure of exchanged clinical documents. In the case where a local document is transformed into a CDA document for exchange, authentication occurs on the local document, and that fact is reflected in the exchanged CDA document. A CDA document can reflect the unauthenticated, authenticated, or legally authenticated state. The unauthenticated state exists when no authentication information has been recorded (i.e., it is the absence of being either authenticated or legally authenticated). While electronic signatures are not captured in a CDA document, both authentication and legal authentication require that a document has been signed manually or electronically by the responsible individual. A legalAuthenticator has a required legalAuthenticator.time indicating the time of authentication, and a required legalAuthenticator.signatureCode, indicating that a signature has been obtained and is on file.
    ///</summary>
    public class LegalAuthenticator : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA LegalAuthenticator
      ///</summary>
      public LegalAuthenticator() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newLegalAuthenticator()) {} 

      internal LegalAuthenticator(IcdaLegalAuthenticator com) : base(com) {} 

      internal new HCcdaLegalAuthenticator wrapped() { return (HCcdaLegalAuthenticator) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.TS propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.TS value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.TS time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying whether and how the participant has attested his participation through a signature and or whether such a signature is needed.                                                      Examples: A surgical Procedure act object (representing a procedure report) requires a signature of the performing and responsible surgeon, and possibly other participants. (See also: Participation.signatureText.)
      ///</summary>
      private HL7Connect.Cda.CS propGetSignatureCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().signatureCode);
      }
      private void propSetSignatureCode(HL7Connect.Cda.CS value)
      {
        wrapped().signatureCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying whether and how the participant has attested his participation through a signature and or whether such a signature is needed.                                                      Examples: A surgical Procedure act object (representing a procedure report) requires a signature of the performing and responsible surgeon, and possibly other participants. (See also: Participation.signatureText.)
      ///</summary>
      public HL7Connect.Cda.CS signatureCode { get { return propGetSignatureCode(); } set { propSetSignatureCode(value); } }

      ///<summary>
      /// the participant who has legally authenticated the document
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// the participant who has legally authenticated the document
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// The location participant (location class) relates a healthcare facility (HealthCareFacility class) to the encounter to indicate where the encounter took place. The entity playing the role of HealthCareFacility is a place (Place class). The entity scoping the HealthCareFacility role is an organization (Organization class). 
    /// 
    /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow. When the location is an organization, this is indicated by the presence of a scoping Organization, without a playing Place.
    ///</summary>
    public class Location : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Location
      ///</summary>
      public Location() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newLocation()) {} 

      internal Location(IcdaLocation com) : base(com) {} 

      internal new HCcdaLocation wrapped() { return (HCcdaLocation) com; }

      ///<summary>
      /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow.
      ///</summary>
      private HL7Connect.Cda.HealthCareFacility propGetHealthCareFacility()
      {
        return HL7Connect.Cda.WrapperFactory.HealthCareFacility(wrapped().healthCareFacility);
      }
      private void propSetHealthCareFacility(HL7Connect.Cda.HealthCareFacility value)
      {
        wrapped().healthCareFacility = value.wrapped();
      }
      ///<summary>
      /// The setting of an encounter (e.g. cardiology clinic, primary care clinic, rehabilitation hospital, skilled nursing facility) can be expressed in HealthCareFacility.code. Note that setting and physical location are not the same. There is a many-to-many relationship between setting and the physical location where care is delivered. Thus, a particular room can provide the location for cardiology clinic one day, and for primary care clinic another day; and cardiology clinic today might be held in one physical location, but in another physical location tomorrow.
      ///</summary>
      public HL7Connect.Cda.HealthCareFacility healthCareFacility { get { return propGetHealthCareFacility(); } set { propSetHealthCareFacility(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// In CDA, Release One, it was possible to specify those individuals responsible for the device. This functionality has been deprecated in CDA, Release Two. The MaintainedEntity class is present for backwards compatibility, and its use is discouraged, except where needed to support the transformation of CDA, Release One documents
    ///</summary>
    public class MaintainedEntity : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA MaintainedEntity
      ///</summary>
      public MaintainedEntity() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newMaintainedEntity()) {} 

      internal MaintainedEntity(IcdaMaintainedEntity com) : base(com) {} 

      internal new HCcdaMaintainedEntity wrapped() { return (HCcdaMaintainedEntity) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the period during which the Role is in effect, if such time limit is applicable and known.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the period during which the Role is in effect, if such time limit is applicable and known.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// An entity that is a person
      ///</summary>
      private HL7Connect.Cda.Person propGetMaintainingPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().maintainingPerson);
      }
      private void propSetMaintainingPerson(HL7Connect.Cda.Person value)
      {
        wrapped().maintainingPerson = value.wrapped();
      }
      ///<summary>
      /// An entity that is a person
      ///</summary>
      public HL7Connect.Cda.Person maintainingPerson { get { return propGetMaintainingPerson(); } set { propSetMaintainingPerson(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// used to bring in the LabeledDrug or Material entity that describes the administered substance
    ///</summary>
    public class ManufacturedProduct : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ManufacturedProduct
      ///</summary>
      public ManufacturedProduct() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newManufacturedProduct()) {} 

      internal ManufacturedProduct(IcdaManufacturedProduct com) : base(com) {} 

      internal new HCcdaManufacturedProduct wrapped() { return (HCcdaManufacturedProduct) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// The LabeledDrug class, which is an Entity class playing the Role of Manufactured Product, identifies the drug that is consumed in the substance administration
      ///</summary>
      private HL7Connect.Cda.LabeledDrug propGetManufacturedLabeledDrug()
      {
        return HL7Connect.Cda.WrapperFactory.LabeledDrug(wrapped().manufacturedLabeledDrug);
      }
      private void propSetManufacturedLabeledDrug(HL7Connect.Cda.LabeledDrug value)
      {
        wrapped().manufacturedLabeledDrug = value.wrapped();
      }
      ///<summary>
      /// The LabeledDrug class, which is an Entity class playing the Role of Manufactured Product, identifies the drug that is consumed in the substance administration
      ///</summary>
      public HL7Connect.Cda.LabeledDrug manufacturedLabeledDrug { get { return propGetManufacturedLabeledDrug(); } set { propSetManufacturedLabeledDrug(value); } }

      ///<summary>
      /// used to identify non-drug administered substances such as vaccines and blood products
      ///</summary>
      private HL7Connect.Cda.Material propGetManufacturedMaterial()
      {
        return HL7Connect.Cda.WrapperFactory.Material(wrapped().manufacturedMaterial);
      }
      private void propSetManufacturedMaterial(HL7Connect.Cda.Material value)
      {
        wrapped().manufacturedMaterial = value.wrapped();
      }
      ///<summary>
      /// used to identify non-drug administered substances such as vaccines and blood products
      ///</summary>
      public HL7Connect.Cda.Material manufacturedMaterial { get { return propGetManufacturedMaterial(); } set { propSetManufacturedMaterial(value); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetManufacturerOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().manufacturerOrganization);
      }
      private void propSetManufacturerOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().manufacturerOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization manufacturerOrganization { get { return propGetManufacturerOrganization(); } set { propSetManufacturerOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// used to identify non-drug administered substances such as vaccines and blood products
    ///</summary>
    public class Material : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Material
      ///</summary>
      public Material() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newMaterial()) {} 

      internal Material(IcdaMaterial com) : base(com) {} 

      internal new HCcdaMaterial wrapped() { return (HCcdaMaterial) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.EN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.EN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.EN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An alphanumeric string used to identify a particular batch of manufactured material.                                                       Discussion: The lot name is usually printed on the label attached to the container holding the substance and/or on the packaging which houses the container. Note that a lot number is not meant to be a unique identifier, but is meaningful only when the product kind and manufacturer are also identified.
      ///</summary>
      private HL7Connect.Cda.ST propGetLotNumberText()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().lotNumberText);
      }
      private void propSetLotNumberText(HL7Connect.Cda.ST value)
      {
        wrapped().lotNumberText = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An alphanumeric string used to identify a particular batch of manufactured material.                                                       Discussion: The lot name is usually printed on the label attached to the container holding the substance and/or on the packaging which houses the container. Note that a lot number is not meant to be a unique identifier, but is meaningful only when the product kind and manufacturer are also identified.
      ///</summary>
      public HL7Connect.Cda.ST lotNumberText { get { return propGetLotNumberText(); } set { propSetLotNumberText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// The NonXMLBody class represents a document body that is in some format other than XML. NonXMLBody.text is used to reference data that is stored externally to the CDA document or to encode the data directly inline. 
    /// 
    /// Rendering a referenced non-XML body requires a software tool that recognizes the particular MIME media type of the blob.
    ///</summary>
    public class NonXMLBody : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA NonXMLBody
      ///</summary>
      public NonXMLBody() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newNonXMLBody()) {} 

      internal NonXMLBody(IcdaNonXMLBody com) : base(com) {} 

      internal new HCcdaNonXMLBody wrapped() { return (HCcdaNonXMLBody) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that controls the disclosure of information about this Act, regardless of mood.                                                      Discussion: It is important to note that the necessary confidentiality of the medical record cannot be achieved solely through confidentiality codes to mask individual record items from certain types of users. There are two important problems with per-item confidentiality: one is inference and the other is the danger of holding back information that may be critical in a certain care situation. Inference means that filtered sensitive information can still be assumed given the other information that was not filtered. The simplest form of inference is that even the existence of a test order for an HIV Western Blot test or a T4/T8 lymphocyte count is a strong indication for an existing HIV infection, even if the results are not known. Very often, diagnoses can be inferred from medication, such as Zidovudin for treatment of HIV infections. The problem of hiding individual items becomes especially difficult with current medications, since the continuing administration of the medication must be assured.                        To mitigate some of the inference-risk, aggregations of data should assume the confidentiality level of the most confidential action in the aggregation.
      ///</summary>
      private HL7Connect.Cda.CD propGetConfidentialityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().confidentialityCode);
      }
      private void propSetConfidentialityCode(HL7Connect.Cda.CD value)
      {
        wrapped().confidentialityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that controls the disclosure of information about this Act, regardless of mood.                                                      Discussion: It is important to note that the necessary confidentiality of the medical record cannot be achieved solely through confidentiality codes to mask individual record items from certain types of users. There are two important problems with per-item confidentiality: one is inference and the other is the danger of holding back information that may be critical in a certain care situation. Inference means that filtered sensitive information can still be assumed given the other information that was not filtered. The simplest form of inference is that even the existence of a test order for an HIV Western Blot test or a T4/T8 lymphocyte count is a strong indication for an existing HIV infection, even if the results are not known. Very often, diagnoses can be inferred from medication, such as Zidovudin for treatment of HIV infections. The problem of hiding individual items becomes especially difficult with current medications, since the continuing administration of the medication must be assured.                        To mitigate some of the inference-risk, aggregations of data should assume the confidentiality level of the most confidential action in the aggregation.
      ///</summary>
      public HL7Connect.Cda.CD confidentialityCode { get { return propGetConfidentialityCode(); } set { propSetConfidentialityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// A derivative of the RIM Observation class, used for representing coded and other observations.
    ///</summary>
    public class Observation : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA Observation
      ///</summary>
      public Observation() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newObservation()) {} 

      internal Observation(IcdaObservation com) : base(com) {} 

      internal new HCcdaObservation wrapped() { return (HCcdaObservation) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A character string containing a formal language expression that specifies how the Act's attributes are (should be or have been) derived from input parameters associated with derivation relationships.                                                      Discussion: Derived observations can be defined through association with other observations using ActRelationships of type "derivation". For example, to define a derived observation for Mean Corpuscular Hemoglobin (MCH) one will associate the MCH observation with a Hemoglobin (HGB) observation and a Red Blood cell Count (RBC) observation. And the derivation expression encodes the formula: MCH = HGB / RBC.                        The derivation expression is represented as a character string.                        [Note: The syntax of that expression is yet to be fully specified. There would be a single standard expression language rather than an optional choice between many expression languages. The syntax would be based on a de-facto standard for many object-oriented languages, such as C++, Java, OCL etc. A concrete specification of this expression language is being worked on now and drafts can be expected within the year 2003.]
      ///</summary>
      private HL7Connect.Cda.ST propGetDerivationExpr()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().derivationExpr);
      }
      private void propSetDerivationExpr(HL7Connect.Cda.ST value)
      {
        wrapped().derivationExpr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A character string containing a formal language expression that specifies how the Act's attributes are (should be or have been) derived from input parameters associated with derivation relationships.                                                      Discussion: Derived observations can be defined through association with other observations using ActRelationships of type "derivation". For example, to define a derived observation for Mean Corpuscular Hemoglobin (MCH) one will associate the MCH observation with a Hemoglobin (HGB) observation and a Red Blood cell Count (RBC) observation. And the derivation expression encodes the formula: MCH = HGB / RBC.                        The derivation expression is represented as a character string.                        [Note: The syntax of that expression is yet to be fully specified. There would be a single standard expression language rather than an optional choice between many expression languages. The syntax would be based on a de-facto standard for many object-oriented languages, such as C++, Java, OCL etc. A concrete specification of this expression language is being worked on now and drafts can be expected within the year 2003.]
      ///</summary>
      public HL7Connect.Cda.ST derivationExpr { get { return propGetDerivationExpr(); } set { propSetDerivationExpr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      private HL7Connect.Cda.CD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.CD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      public HL7Connect.Cda.CD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of integer numbers stating the minimal and maximal number of repetitions of the Act.                                                      Examples: An oral surgeon's advice to a patient after tooth extraction might be: "replace the gauze every hour for 1 to 3 times until bleeding has stopped completely." This translates to repeatNumber with low boundary 1 and high boundary 3.                                                      Discussion: This attribute is a member of the workflow control suite of attributes.                         The number of repeats is additionally constrained by time. The act will repeat at least the minimal number of times and at most, the maximal number of times. Repetitions will also terminate when the time exceeds the maximal Act.effectiveTime, whichever comes first.                                                      Usage: On an Act in Event mood, the repeatNumber is usally 1. If greater than 1, the Act is representing a summary of several event occurrences occurring over the time interval described by effectiveTime                        To distinguish occurrences of acts within a sequence of repetitions, use ActRelationship.sequenceNumber
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.INT> propGetRepeatNumber()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.INT>(wrapped().repeatNumber);
      }
      private void propSetRepeatNumber(HL7Connect.Cda.IVL<HL7Connect.Cda.INT> value)
      {
        wrapped().repeatNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of integer numbers stating the minimal and maximal number of repetitions of the Act.                                                      Examples: An oral surgeon's advice to a patient after tooth extraction might be: "replace the gauze every hour for 1 to 3 times until bleeding has stopped completely." This translates to repeatNumber with low boundary 1 and high boundary 3.                                                      Discussion: This attribute is a member of the workflow control suite of attributes.                         The number of repeats is additionally constrained by time. The act will repeat at least the minimal number of times and at most, the maximal number of times. Repetitions will also terminate when the time exceeds the maximal Act.effectiveTime, whichever comes first.                                                      Usage: On an Act in Event mood, the repeatNumber is usally 1. If greater than 1, the Act is representing a summary of several event occurrences occurring over the time interval described by effectiveTime                        To distinguish occurrences of acts within a sequence of repetitions, use ActRelationship.sequenceNumber
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.INT> repeatNumber { get { return propGetRepeatNumber(); } set { propSetRepeatNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      private HL7Connect.Cda.ListANY propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ListANY(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.ListANY value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      public HL7Connect.Cda.ListANY value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// One or more codes specifying a rough qualitative interpretation of the observation, such as "normal", "abnormal", "below normal", "change up", "resistant", "susceptible", etc.                                                      Discussion: These interpretation codes are sometimes called "abnormal flags", however, the judgment of normalcy is just one of the common rough interpretations, and is often not relevant. For example, the susceptibility interpretations are not about "normalcy", and for any observation of a pathologic condition, it does not make sense to state the normalcy, since pathologic conditions are never considered "normal."
      ///</summary>
      private HL7Connect.Cda.ListCD propGetInterpretationCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().interpretationCode);
      }
      private void propSetInterpretationCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().interpretationCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// One or more codes specifying a rough qualitative interpretation of the observation, such as "normal", "abnormal", "below normal", "change up", "resistant", "susceptible", etc.                                                      Discussion: These interpretation codes are sometimes called "abnormal flags", however, the judgment of normalcy is just one of the common rough interpretations, and is often not relevant. For example, the susceptibility interpretations are not about "normalcy", and for any observation of a pathologic condition, it does not make sense to state the normalcy, since pathologic conditions are never considered "normal."
      ///</summary>
      public HL7Connect.Cda.ListCD interpretationCode { get { return propGetInterpretationCode(); } set { propSetInterpretationCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that provides additional detail about the means or technique used to ascertain the observation.                                                      Examples: Blood pressure measurement method: arterial puncture vs. sphygmomanometer (Riva-Rocci), sitting vs. supine position, etc.                                                       Constraints: In all observations the method is already partially specified by the Act.code. In this case, the methodCode *need not* be used at all. The methodCode *may* still be used to identify this method more clearly in addition to what is implied from the Act.code. However, an information consumer system or process *should not* depend on this methodCode information for method detail that is implied by the Act.code.                         If the methodCode is used to express method detail that is also implied by the Act.code, the methodCode *must not* be in conflict with the implied method of the Act.code.                                                      Discussion: In all observations the method is already partially specified by simply knowing the kind of observation (observation definition, Act.code) and this implicit information about the method does not need to be specified in Observation.methodCode. For example, many LOINC codes are defined for specific methods as long as the method makes a practical difference in interpretation. Thus, using LOINC, the difference between susceptibility studies using the "minimal inhibitory concentration" (MIC) or the "agar diffusion method" (Kirby-Baur) are specifically assigned different codes. The methodCode therefore is only an additional qualifier to specify what may not be known already from the Act.code.                        Also, some variances in methods may be tied to the particular device used. The methodCode should not be used to identify the specific device or test-kit material used in the observation. Such information about devices or test-kits should be associated with the observation as "device" participations.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetMethodCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().methodCode);
      }
      private void propSetMethodCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().methodCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that provides additional detail about the means or technique used to ascertain the observation.                                                      Examples: Blood pressure measurement method: arterial puncture vs. sphygmomanometer (Riva-Rocci), sitting vs. supine position, etc.                                                       Constraints: In all observations the method is already partially specified by the Act.code. In this case, the methodCode *need not* be used at all. The methodCode *may* still be used to identify this method more clearly in addition to what is implied from the Act.code. However, an information consumer system or process *should not* depend on this methodCode information for method detail that is implied by the Act.code.                         If the methodCode is used to express method detail that is also implied by the Act.code, the methodCode *must not* be in conflict with the implied method of the Act.code.                                                      Discussion: In all observations the method is already partially specified by simply knowing the kind of observation (observation definition, Act.code) and this implicit information about the method does not need to be specified in Observation.methodCode. For example, many LOINC codes are defined for specific methods as long as the method makes a practical difference in interpretation. Thus, using LOINC, the difference between susceptibility studies using the "minimal inhibitory concentration" (MIC) or the "agar diffusion method" (Kirby-Baur) are specifically assigned different codes. The methodCode therefore is only an additional qualifier to specify what may not be known already from the Act.code.                        Also, some variances in methods may be tied to the particular device used. The methodCode should not be used to identify the specific device or test-kit material used in the observation. Such information about devices or test-kits should be associated with the observation as "device" participations.
      ///</summary>
      public HL7Connect.Cda.ListCD methodCode { get { return propGetMethodCode(); } set { propSetMethodCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying detail about the anatomical site or system that is the focus of the observation if this information is not already implied by the observation definition or Act.code.                                                      Constraints: The targetSiteCode value, if specified, *must not* conflict with what is implied about the target site or system from the observation definition and the Act.code.                                                      Discussion: Most observation target sites are implied by the observation definition and Act.code, or Observation.value. For example, "heart murmur" always has the heart as target. This attribute is used only when the observation target site needs to be refined, to distinguish right and left etc.                         If the subject of the Observation is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses. For example, if the subject is a lake, the site could be inflow and outflow, etc. If the subject is a lymphatic node, "hilus," "periphery," etc. would still be valid target sites.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetTargetSiteCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().targetSiteCode);
      }
      private void propSetTargetSiteCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().targetSiteCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying detail about the anatomical site or system that is the focus of the observation if this information is not already implied by the observation definition or Act.code.                                                      Constraints: The targetSiteCode value, if specified, *must not* conflict with what is implied about the target site or system from the observation definition and the Act.code.                                                      Discussion: Most observation target sites are implied by the observation definition and Act.code, or Observation.value. For example, "heart murmur" always has the heart as target. This attribute is used only when the observation target site needs to be refined, to distinguish right and left etc.                         If the subject of the Observation is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses. For example, if the subject is a lake, the site could be inflow and outflow, etc. If the subject is a lymphatic node, "hilus," "periphery," etc. would still be valid target sites.
      ///</summary>
      public HL7Connect.Cda.ListCD targetSiteCode { get { return propGetTargetSiteCode(); } set { propSetTargetSiteCode(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// An Observation can have zero to many referenceRange relationships, which relate an Observation to the ObservationRange class, where the expected range of values for a particular observation can be specified.
      ///</summary>
      private HL7Connect.Cda.ReferenceRangeList propGetReferenceRange()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceRangeList(wrapped().referenceRange);
      }
      private void propSetReferenceRange(HL7Connect.Cda.ReferenceRangeList value)
      {
        wrapped().referenceRange = value.wrapped();
      }
      ///<summary>
      /// An Observation can have zero to many referenceRange relationships, which relate an Observation to the ObservationRange class, where the expected range of values for a particular observation can be specified.
      ///</summary>
      public HL7Connect.Cda.ReferenceRangeList referenceRange { get { return propGetReferenceRange(); } set { propSetReferenceRange(value); } }

      ///<summary>
      /// Observation.negationInd, when set to "true", is a positive assertion that the Observation as a whole is negated. Some properties such as Observation.id, Observation.moodCode, and the participations are not negated. These properties always have the same meaning: i.e., the author remains the author of the negative Observation. An observation statement with negationInd is still a statement about the specific fact described by the Observation. For instance, a negated "finding of wheezing on July 1" means that the author positively denies that there was wheezing on July 1, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation.
      ///</summary>
      private bool propGetNegationInd()
      {
        return wrapped().negationInd != 0;
      }
      private void propSetNegationInd(bool value)
      {
        wrapped().negationInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Observation.negationInd, when set to "true", is a positive assertion that the Observation as a whole is negated. Some properties such as Observation.id, Observation.moodCode, and the participations are not negated. These properties always have the same meaning: i.e., the author remains the author of the negative Observation. An observation statement with negationInd is still a statement about the specific fact described by the Observation. For instance, a negated "finding of wheezing on July 1" means that the author positively denies that there was wheezing on July 1, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation.
      ///</summary>
      public bool negationInd { get { return propGetNegationInd(); } set { propSetNegationInd(value); } }

      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      private bool propGetHasNegationInd()
      {
        return wrapped().HasNegationInd != 0;
      }
      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      public bool HasNegationInd { get { return propGetHasNegationInd(); } }

    }

    ///<summary>
    /// A derivative of the RIM Observation class that represents multimedia that is logically part of the current document. This class is only for multimedia that is logically part of the attested content of the document. Rendering a referenced ObservationMedia requires a software tool that recognizes the particular MIME media type.
    ///</summary>
    public class ObservationMedia : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA ObservationMedia
      ///</summary>
      public ObservationMedia() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newObservationMedia()) {} 

      internal ObservationMedia(IcdaObservationMedia com) : base(com) {} 

      internal new HCcdaObservationMedia wrapped() { return (HCcdaObservationMedia) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      private HL7Connect.Cda.ED propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.ED value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      public HL7Connect.Cda.ED value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// XML ID - target of an ID reference in the structured text. 
      /// 
      /// Note that in XML this is the "ID" attribute, but has been renamed for the sake of some non-case sensitive implementations
      ///</summary>
      private string propGetID_()
      {
        return wrapped().ID_;
      }
      private void propSetID_(string value)
      {
        wrapped().ID_ = value;
      }
      ///<summary>
      /// XML ID - target of an ID reference in the structured text. 
      /// 
      /// Note that in XML this is the "ID" attribute, but has been renamed for the sake of some non-case sensitive implementations
      ///</summary>
      public string ID_ { get { return propGetID_(); } set { propSetID_(value); } }

    }

    ///<summary>
    /// An Observation can have zero to many referenceRange relationships, which relate an Observation to the ObservationRange class, where the expected range of values for a particular observation can be specified.
    ///</summary>
    public class ObservationRange : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ObservationRange
      ///</summary>
      public ObservationRange() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newObservationRange()) {} 

      internal ObservationRange(IcdaObservationRange com) : base(com) {} 

      internal new HCcdaObservationRange wrapped() { return (HCcdaObservationRange) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      private HL7Connect.Cda.ANY propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ANY(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.ANY value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      public HL7Connect.Cda.ANY value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// One or more codes specifying a rough qualitative interpretation of the observation, such as "normal", "abnormal", "below normal", "change up", "resistant", "susceptible", etc.                                                      Discussion: These interpretation codes are sometimes called "abnormal flags", however, the judgment of normalcy is just one of the common rough interpretations, and is often not relevant. For example, the susceptibility interpretations are not about "normalcy", and for any observation of a pathologic condition, it does not make sense to state the normalcy, since pathologic conditions are never considered "normal."
      ///</summary>
      private HL7Connect.Cda.CD propGetInterpretationCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().interpretationCode);
      }
      private void propSetInterpretationCode(HL7Connect.Cda.CD value)
      {
        wrapped().interpretationCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// One or more codes specifying a rough qualitative interpretation of the observation, such as "normal", "abnormal", "below normal", "change up", "resistant", "susceptible", etc.                                                      Discussion: These interpretation codes are sometimes called "abnormal flags", however, the judgment of normalcy is just one of the common rough interpretations, and is often not relevant. For example, the susceptibility interpretations are not about "normalcy", and for any observation of a pathologic condition, it does not make sense to state the normalcy, since pathologic conditions are never considered "normal."
      ///</summary>
      public HL7Connect.Cda.CD interpretationCode { get { return propGetInterpretationCode(); } set { propSetInterpretationCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// This class represents those orders that are fulfilled by this document. For instance, a provider orders an X-Ray. The X-Ray is performed. A radiologist reads the X-Ray and generates a report. The X-Ray order identifier is transmitted in the Order class, the performed X-Ray procedure is transmitted in the ServiceEvent class, and the ClinicalDocument.code would be valued with "Diagnostic Imaging Report".
    ///</summary>
    public class Order : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Order
      ///</summary>
      public Order() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newOrder()) {} 

      internal Order(IcdaOrder com) : base(com) {} 

      internal new HCcdaOrder wrapped() { return (HCcdaOrder) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      private HL7Connect.Cda.CD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.CD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      public HL7Connect.Cda.CD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// A social or legal structure formed by human beings.
    ///</summary>
    public class Organization : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Organization
      ///</summary>
      public Organization() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newOrganization()) {} 

      internal Organization(IcdaOrganization com) : base(com) {} 

      internal new HCcdaOrganization wrapped() { return (HCcdaOrganization) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.ListEN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.ListEN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.ListEN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The postal and/or residential address of an organization.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The postal and/or residential address of an organization.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the industrial category of an organization entity.                                                      Examples: 11231-Chicken Egg Production, 6211- Offices of Physicians, 621511-Medical Laboratories, 524114-Direct Health and Medical Insurance Carriers
      ///</summary>
      private HL7Connect.Cda.CD propGetStandardIndustryClassCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().standardIndustryClassCode);
      }
      private void propSetStandardIndustryClassCode(HL7Connect.Cda.CD value)
      {
        wrapped().standardIndustryClassCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the industrial category of an organization entity.                                                      Examples: 11231-Chicken Egg Production, 6211- Offices of Physicians, 621511-Medical Laboratories, 524114-Direct Health and Medical Insurance Carriers
      ///</summary>
      public HL7Connect.Cda.CD standardIndustryClassCode { get { return propGetStandardIndustryClassCode(); } set { propSetStandardIndustryClassCode(value); } }

      ///<summary>
      /// An organization can be part of a larger organization. Where there is a need to include whole-part relationships, the OrganizationPartOf role can be used. OrganizationPartOf.statusCode indicates the state of the whole-part relationship (e.g. "active", "terminated"). OrganizationPartOf.effectiveTime is an interval of time specifying the period during which the whole-part relationhship is in effect, if such time limit is applicable and known.
      ///</summary>
      private HL7Connect.Cda.OrganizationPartOf propGetAsOrganizationPartOf()
      {
        return HL7Connect.Cda.WrapperFactory.OrganizationPartOf(wrapped().asOrganizationPartOf);
      }
      private void propSetAsOrganizationPartOf(HL7Connect.Cda.OrganizationPartOf value)
      {
        wrapped().asOrganizationPartOf = value.wrapped();
      }
      ///<summary>
      /// An organization can be part of a larger organization. Where there is a need to include whole-part relationships, the OrganizationPartOf role can be used. OrganizationPartOf.statusCode indicates the state of the whole-part relationship (e.g. "active", "terminated"). OrganizationPartOf.effectiveTime is an interval of time specifying the period during which the whole-part relationhship is in effect, if such time limit is applicable and known.
      ///</summary>
      public HL7Connect.Cda.OrganizationPartOf asOrganizationPartOf { get { return propGetAsOrganizationPartOf(); } set { propSetAsOrganizationPartOf(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// An organization can be part of a larger organization. Where there is a need to include whole-part relationships, the OrganizationPartOf role can be used. OrganizationPartOf.statusCode indicates the state of the whole-part relationship (e.g. "active", "terminated"). OrganizationPartOf.effectiveTime is an interval of time specifying the period during which the whole-part relationhship is in effect, if such time limit is applicable and known.
    ///</summary>
    public class OrganizationPartOf : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA OrganizationPartOf
      ///</summary>
      public OrganizationPartOf() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newOrganizationPartOf()) {} 

      internal OrganizationPartOf(IcdaOrganizationPartOf com) : base(com) {} 

      internal new HCcdaOrganizationPartOf wrapped() { return (HCcdaOrganizationPartOf) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of this Role as defined in the state-transition model.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of this Role as defined in the state-transition model.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the period during which the Role is in effect, if such time limit is applicable and known.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the period during which the Role is in effect, if such time limit is applicable and known.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetWholeOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().wholeOrganization);
      }
      private void propSetWholeOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().wholeOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization wholeOrganization { get { return propGetWholeOrganization(); } set { propSetWholeOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// A derivative of the RIM Act class, which can be used to create arbitrary groupings of other CDA entries that share a common context. An Organizer can contain other Organizers and/or other CDA entries, by traversing the component relationship. An Organizer can refer to external acts by traversing the reference relationship. An Organizer cannot be the source of an entryRelationship relationship.
    ///</summary>
    public class Organizer : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA Organizer
      ///</summary>
      public Organizer() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newOrganizer()) {} 

      internal Organizer(IcdaOrganizer com) : base(com) {} 

      internal new HCcdaOrganizer wrapped() { return (HCcdaOrganizer) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// The "component" Act Relationship is used to nest content. Context propagates to nested content
      ///</summary>
      private HL7Connect.Cda.Component4List propGetComponent()
      {
        return HL7Connect.Cda.WrapperFactory.Component4List(wrapped().Component);
      }
      private void propSetComponent(HL7Connect.Cda.Component4List value)
      {
        wrapped().Component = value.wrapped();
      }
      ///<summary>
      /// The "component" Act Relationship is used to nest content. Context propagates to nested content
      ///</summary>
      public HL7Connect.Cda.Component4List component { get { return propGetComponent(); } set { propSetComponent(value); } }

    }

    ///<summary>
    /// The ParentDocument represents the source of a document revision, addenda, or transformation. ParentDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the parent document. It is not to be used to embed the related document, and thus ParentDocument.text.BIN is precluded from use.
    ///</summary>
    public class ParentDocument : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ParentDocument
      ///</summary>
      public ParentDocument() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newParentDocument()) {} 

      internal ParentDocument(IcdaParentDocument com) : base(com) {} 

      internal new HCcdaParentDocument wrapped() { return (HCcdaParentDocument) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A report identifier that remains constant across all revisions that derive from a common original.                         An original report is the first version of a report. It gets a new unique value for setId, and has the value of versionNumber set to equal "1".                         An addendum is an appendage to an existing report that contains supplemental information. The appendage is itself an original report. The parent report being appended is referenced via an ActRelationship, with ActRelationship.typeCode set to equal "APND" (for "appends"). The parent report being appended remains in place and its content and status are unaltered.                         A replacement report replaces an existing report. The replacement report uses the same value for setId as the parent report being replaced, and increments the value of versionNumber by 1. The state of the parent report being replaced should become "superceded", but is still retained in the system for historical reference.
      ///</summary>
      private HL7Connect.Cda.II propGetSetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().setId);
      }
      private void propSetSetId(HL7Connect.Cda.II value)
      {
        wrapped().setId = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A report identifier that remains constant across all revisions that derive from a common original.                         An original report is the first version of a report. It gets a new unique value for setId, and has the value of versionNumber set to equal "1".                         An addendum is an appendage to an existing report that contains supplemental information. The appendage is itself an original report. The parent report being appended is referenced via an ActRelationship, with ActRelationship.typeCode set to equal "APND" (for "appends"). The parent report being appended remains in place and its content and status are unaltered.                         A replacement report replaces an existing report. The replacement report uses the same value for setId as the parent report being replaced, and increments the value of versionNumber by 1. The state of the parent report being replaced should become "superceded", but is still retained in the system for historical reference.
      ///</summary>
      public HL7Connect.Cda.II setId { get { return propGetSetId(); } set { propSetSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Version number is an integer starting at '1' and incrementing by 1. The first instance or original report should always be valued as '1'. The version number value must be incremented by one when a report is replaced, but can also be incremented more often to meet local requirements.
      ///</summary>
      private HL7Connect.Cda.INT propGetVersionNumber()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().versionNumber);
      }
      private void propSetVersionNumber(HL7Connect.Cda.INT value)
      {
        wrapped().versionNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Version number is an integer starting at '1' and incrementing by 1. The first instance or original report should always be valued as '1'. The version number value must be incremented by one when a report is replaced, but can also be incremented more often to meet local requirements.
      ///</summary>
      public HL7Connect.Cda.INT versionNumber { get { return propGetVersionNumber(); } set { propSetVersionNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// Can be used to represent any other participant that cannot be represented with one of the more specific participants
    ///</summary>
    public class Participant1 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Participant1
      ///</summary>
      public Participant1() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newParticipant1()) {} 

      internal Participant1(IcdaParticipant1 com) : base(com) {} 

      internal new HCcdaParticipant1 wrapped() { return (HCcdaParticipant1) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An optional code specifying additional detail about the function that the Participation has in the Act, if such detail is not implied by the Participation.typeCode.                                                      Examples: First surgeon, second surgeon (or first assistant surgeon, the one facing the primary surgeon), second assistant (often standing next to the primary surgeon), potentially a third assistant, scrub nurse, circulating nurse, nurse assistant, anesthetist, attending anesthetist, anesthesia nurse, technician who positions the patient, postoperative watch nurse, assistants, midwives, students, etc.                                                      Constraints: This code, if specified at all, *must not* be in conflict with the Participation.typeCode.                         No HL7 standard specification may be written to technically depend on the functionCode. If that is deemed necessary, such concepts should be defined in the Participation.typeCode instead.                                                      Discussion: This code can accommodate the huge variety and nuances of functions that participants may perform in the act. The number and kinds of functions applicable depends on the special kind of act. E.g., each operation and method may require a different number of assistant surgeons or nurses.                        Since participation functions refer to what people do in an Act, these are really sub-activities that may all occur in parallel. If any more detail needs to be said about these activities other than just who does them, one should consider using component acts instead.
      ///</summary>
      private HL7Connect.Cda.CD propGetFunctionCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().functionCode);
      }
      private void propSetFunctionCode(HL7Connect.Cda.CD value)
      {
        wrapped().functionCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An optional code specifying additional detail about the function that the Participation has in the Act, if such detail is not implied by the Participation.typeCode.                                                      Examples: First surgeon, second surgeon (or first assistant surgeon, the one facing the primary surgeon), second assistant (often standing next to the primary surgeon), potentially a third assistant, scrub nurse, circulating nurse, nurse assistant, anesthetist, attending anesthetist, anesthesia nurse, technician who positions the patient, postoperative watch nurse, assistants, midwives, students, etc.                                                      Constraints: This code, if specified at all, *must not* be in conflict with the Participation.typeCode.                         No HL7 standard specification may be written to technically depend on the functionCode. If that is deemed necessary, such concepts should be defined in the Participation.typeCode instead.                                                      Discussion: This code can accommodate the huge variety and nuances of functions that participants may perform in the act. The number and kinds of functions applicable depends on the special kind of act. E.g., each operation and method may require a different number of assistant surgeons or nurses.                        Since participation functions refer to what people do in an Act, these are really sub-activities that may all occur in parallel. If any more detail needs to be said about these activities other than just who does them, one should consider using component acts instead.
      ///</summary>
      public HL7Connect.Cda.CD functionCode { get { return propGetFunctionCode(); } set { propSetFunctionCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// a person or organization in the role of a participating entity
      ///</summary>
      private HL7Connect.Cda.AssociatedEntity propGetAssociatedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssociatedEntity(wrapped().associatedEntity);
      }
      private void propSetAssociatedEntity(HL7Connect.Cda.AssociatedEntity value)
      {
        wrapped().associatedEntity = value.wrapped();
      }
      ///<summary>
      /// a person or organization in the role of a participating entity
      ///</summary>
      public HL7Connect.Cda.AssociatedEntity associatedEntity { get { return propGetAssociatedEntity(); } set { propSetAssociatedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// Can be used to represent any other participant that cannot be represented with one of the more specific participants
    ///</summary>
    public class Participant2 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Participant2
      ///</summary>
      public Participant2() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newParticipant2()) {} 

      internal Participant2(IcdaParticipant2 com) : base(com) {} 

      internal new HCcdaParticipant2 wrapped() { return (HCcdaParticipant2) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the extent to which the Entity playing the participating Role (usually as a target Participation) is aware of the associated Act.                                                      Examples: For diagnostic observations, is the patient, family member or other participant aware of the patient's terminal illness?                                                      Discussion: If the awareness, denial, unconsciousness, etc. is the subject of medical considerations (e.g., part of the problem list), one should use explicit observations in these matters as well, and should not solely rely on this simple attribute in the Participation.
      ///</summary>
      private HL7Connect.Cda.CD propGetAwarenessCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().awarenessCode);
      }
      private void propSetAwarenessCode(HL7Connect.Cda.CD value)
      {
        wrapped().awarenessCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the extent to which the Entity playing the participating Role (usually as a target Participation) is aware of the associated Act.                                                      Examples: For diagnostic observations, is the patient, family member or other participant aware of the patient's terminal illness?                                                      Discussion: If the awareness, denial, unconsciousness, etc. is the subject of medical considerations (e.g., part of the problem list), one should use explicit observations in these matters as well, and should not solely rely on this simple attribute in the Participation.
      ///</summary>
      public HL7Connect.Cda.CD awarenessCode { get { return propGetAwarenessCode(); } set { propSetAwarenessCode(value); } }

      ///<summary>
      /// Describes how the entity is participating in the act.
      ///</summary>
      private HL7Connect.Cda.ParticipantRole propGetParticipantRole()
      {
        return HL7Connect.Cda.WrapperFactory.ParticipantRole(wrapped().participantRole);
      }
      private void propSetParticipantRole(HL7Connect.Cda.ParticipantRole value)
      {
        wrapped().participantRole = value.wrapped();
      }
      ///<summary>
      /// Describes how the entity is participating in the act.
      ///</summary>
      public HL7Connect.Cda.ParticipantRole participantRole { get { return propGetParticipantRole(); } set { propSetParticipantRole(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// Describes how the entity is participating in the act.
    ///</summary>
    public class ParticipantRole : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ParticipantRole
      ///</summary>
      public ParticipantRole() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newParticipantRole()) {} 

      internal ParticipantRole(IcdaParticipantRole com) : base(com) {} 

      internal new HCcdaParticipantRole wrapped() { return (HCcdaParticipantRole) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// An entity used in an activity, without being substantially changed through that activity.
      ///</summary>
      private HL7Connect.Cda.Device propGetPlayingDevice()
      {
        return HL7Connect.Cda.WrapperFactory.Device(wrapped().playingDevice);
      }
      private void propSetPlayingDevice(HL7Connect.Cda.Device value)
      {
        wrapped().playingDevice = value.wrapped();
      }
      ///<summary>
      /// An entity used in an activity, without being substantially changed through that activity.
      ///</summary>
      public HL7Connect.Cda.Device playingDevice { get { return propGetPlayingDevice(); } set { propSetPlayingDevice(value); } }

      ///<summary>
      /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role by playing the role
      ///</summary>
      private HL7Connect.Cda.PlayingEntity propGetPlayingEntity()
      {
        return HL7Connect.Cda.WrapperFactory.PlayingEntity(wrapped().playingEntity);
      }
      private void propSetPlayingEntity(HL7Connect.Cda.PlayingEntity value)
      {
        wrapped().playingEntity = value.wrapped();
      }
      ///<summary>
      /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role by playing the role
      ///</summary>
      public HL7Connect.Cda.PlayingEntity playingEntity { get { return propGetPlayingEntity(); } set { propSetPlayingEntity(value); } }

      ///<summary>
      /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role.
      ///</summary>
      private HL7Connect.Cda.Entity propGetScopingEntity()
      {
        return HL7Connect.Cda.WrapperFactory.Entity(wrapped().scopingEntity);
      }
      private void propSetScopingEntity(HL7Connect.Cda.Entity value)
      {
        wrapped().scopingEntity = value.wrapped();
      }
      ///<summary>
      /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role.
      ///</summary>
      public HL7Connect.Cda.Entity scopingEntity { get { return propGetScopingEntity(); } set { propSetScopingEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

    }

    ///<summary>
    /// A person that receives health care services from a provider.
    ///</summary>
    public class Patient : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Patient
      ///</summary>
      public Patient() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPatient()) {} 

      internal Patient(IcdaPatient com) : base(com) {} 

      internal new HCcdaPatient wrapped() { return (HCcdaPatient) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      private HL7Connect.Cda.II propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.II value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Entity.                                                      Rationale: Successful communication only requires that an entity have a single identifier assigned to it. However, it is recognized that as different systems maintain different databases, there may be different instance identifiers assigned by different systems. Note that an instance identifier is a pure identifier and not a classifier. For Material, serial numbers assigned by specific manufacturers, catalog numbers of specific distributors, or inventory numbers issued by owners, may also be represented by the Role.id, which allows a more clear expression of the fact that such a code is assigned by a specific party associated with that material.
      ///</summary>
      public HL7Connect.Cda.II id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.ListEN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.ListEN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.ListEN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the gender (sex) of a Living subject.                                                      Examples: female, male                                                       Discussion: This attribute does not include terms related to clinical gender. Gender is a complex physiological, genetic and sociological concept that requires multiple observations in order to be comprehensively described. The purpose of this attribute is to provide a high level classification that can additionally be used for the appropriate allocation of inpatient bed assignment.                                                      Constraints: This code is used for administrative purposes.                         ExtRef: This information is reported on UB FL 15.
      ///</summary>
      private HL7Connect.Cda.CD propGetAdministrativeGenderCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().administrativeGenderCode);
      }
      private void propSetAdministrativeGenderCode(HL7Connect.Cda.CD value)
      {
        wrapped().administrativeGenderCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the gender (sex) of a Living subject.                                                      Examples: female, male                                                       Discussion: This attribute does not include terms related to clinical gender. Gender is a complex physiological, genetic and sociological concept that requires multiple observations in order to be comprehensively described. The purpose of this attribute is to provide a high level classification that can additionally be used for the appropriate allocation of inpatient bed assignment.                                                      Constraints: This code is used for administrative purposes.                         ExtRef: This information is reported on UB FL 15.
      ///</summary>
      public HL7Connect.Cda.CD administrativeGenderCode { get { return propGetAdministrativeGenderCode(); } set { propSetAdministrativeGenderCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The date and time of a living subject's birth or hatching.
      ///</summary>
      private HL7Connect.Cda.TS propGetBirthTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().birthTime);
      }
      private void propSetBirthTime(HL7Connect.Cda.TS value)
      {
        wrapped().birthTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The date and time of a living subject's birth or hatching.
      ///</summary>
      public HL7Connect.Cda.TS birthTime { get { return propGetBirthTime(); } set { propSetBirthTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the domestic partnership status of a person.                                                      Examples: Married, separated, divorced, widowed, common-law marriage.                                                      Rationale: This information is reported on UB FL 16
      ///</summary>
      private HL7Connect.Cda.CD propGetMaritalStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().maritalStatusCode);
      }
      private void propSetMaritalStatusCode(HL7Connect.Cda.CD value)
      {
        wrapped().maritalStatusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the domestic partnership status of a person.                                                      Examples: Married, separated, divorced, widowed, common-law marriage.                                                      Rationale: This information is reported on UB FL 16
      ///</summary>
      public HL7Connect.Cda.CD maritalStatusCode { get { return propGetMaritalStatusCode(); } set { propSetMaritalStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary religious preference of a person (e.g. Hinduism, Islam, Roman Catholic Church).
      ///</summary>
      private HL7Connect.Cda.CD propGetReligiousAffiliationCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().religiousAffiliationCode);
      }
      private void propSetReligiousAffiliationCode(HL7Connect.Cda.CD value)
      {
        wrapped().religiousAffiliationCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary religious preference of a person (e.g. Hinduism, Islam, Roman Catholic Church).
      ///</summary>
      public HL7Connect.Cda.CD religiousAffiliationCode { get { return propGetReligiousAffiliationCode(); } set { propSetReligiousAffiliationCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the race of a person.
      ///</summary>
      private HL7Connect.Cda.CD propGetRaceCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().raceCode);
      }
      private void propSetRaceCode(HL7Connect.Cda.CD value)
      {
        wrapped().raceCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the race of a person.
      ///</summary>
      public HL7Connect.Cda.CD raceCode { get { return propGetRaceCode(); } set { propSetRaceCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The ethnic group of the person.
      ///</summary>
      private HL7Connect.Cda.CD propGetEthnicGroupCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().ethnicGroupCode);
      }
      private void propSetEthnicGroupCode(HL7Connect.Cda.CD value)
      {
        wrapped().ethnicGroupCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The ethnic group of the person.
      ///</summary>
      public HL7Connect.Cda.CD ethnicGroupCode { get { return propGetEthnicGroupCode(); } set { propSetEthnicGroupCode(value); } }

      ///<summary>
      /// A list of Guardian
      ///</summary>
      private HL7Connect.Cda.GuardianList propGetGuardian()
      {
        return HL7Connect.Cda.WrapperFactory.GuardianList(wrapped().guardian);
      }
      private void propSetGuardian(HL7Connect.Cda.GuardianList value)
      {
        wrapped().guardian = value.wrapped();
      }
      ///<summary>
      /// A list of Guardian
      ///</summary>
      public HL7Connect.Cda.GuardianList guardian { get { return propGetGuardian(); } set { propSetGuardian(value); } }

      ///<summary>
      /// A Patient's birthplace is represented as a relationship between a patient and a place
      ///</summary>
      private HL7Connect.Cda.Birthplace propGetBirthplace()
      {
        return HL7Connect.Cda.WrapperFactory.Birthplace(wrapped().birthplace);
      }
      private void propSetBirthplace(HL7Connect.Cda.Birthplace value)
      {
        wrapped().birthplace = value.wrapped();
      }
      ///<summary>
      /// A Patient's birthplace is represented as a relationship between a patient and a place
      ///</summary>
      public HL7Connect.Cda.Birthplace birthplace { get { return propGetBirthplace(); } set { propSetBirthplace(value); } }

      ///<summary>
      /// A list of LanguageCommunication
      ///</summary>
      private HL7Connect.Cda.LanguageCommunicationList propGetLanguageCommunication()
      {
        return HL7Connect.Cda.WrapperFactory.LanguageCommunicationList(wrapped().languageCommunication);
      }
      private void propSetLanguageCommunication(HL7Connect.Cda.LanguageCommunicationList value)
      {
        wrapped().languageCommunication = value.wrapped();
      }
      ///<summary>
      /// A list of LanguageCommunication
      ///</summary>
      public HL7Connect.Cda.LanguageCommunicationList languageCommunication { get { return propGetLanguageCommunication(); } set { propSetLanguageCommunication(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// A person that is a patient (receiving healthcare from a provider)
    ///</summary>
    public class PatientRole : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA PatientRole
      ///</summary>
      public PatientRole() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPatientRole()) {} 

      internal PatientRole(IcdaPatientRole com) : base(com) {} 

      internal new HCcdaPatientRole wrapped() { return (HCcdaPatientRole) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// A person that receives health care services from a provider.
      ///</summary>
      private HL7Connect.Cda.Patient propGetPatient()
      {
        return HL7Connect.Cda.WrapperFactory.Patient(wrapped().patient);
      }
      private void propSetPatient(HL7Connect.Cda.Patient value)
      {
        wrapped().patient = value.wrapped();
      }
      ///<summary>
      /// A person that receives health care services from a provider.
      ///</summary>
      public HL7Connect.Cda.Patient patient { get { return propGetPatient(); } set { propSetPatient(value); } }

      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      private HL7Connect.Cda.Organization propGetProviderOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().providerOrganization);
      }
      private void propSetProviderOrganization(HL7Connect.Cda.Organization value)
      {
        wrapped().providerOrganization = value.wrapped();
      }
      ///<summary>
      /// A social or legal structure formed by human beings.
      ///</summary>
      public HL7Connect.Cda.Organization providerOrganization { get { return propGetProviderOrganization(); } set { propSetProviderOrganization(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
    ///</summary>
    public class Performer1 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Performer1
      ///</summary>
      public Performer1() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPerformer1()) {} 

      internal Performer1(IcdaPerformer1 com) : base(com) {} 

      internal new HCcdaPerformer1 wrapped() { return (HCcdaPerformer1) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An optional code specifying additional detail about the function that the Participation has in the Act, if such detail is not implied by the Participation.typeCode.                                                      Examples: First surgeon, second surgeon (or first assistant surgeon, the one facing the primary surgeon), second assistant (often standing next to the primary surgeon), potentially a third assistant, scrub nurse, circulating nurse, nurse assistant, anesthetist, attending anesthetist, anesthesia nurse, technician who positions the patient, postoperative watch nurse, assistants, midwives, students, etc.                                                      Constraints: This code, if specified at all, *must not* be in conflict with the Participation.typeCode.                         No HL7 standard specification may be written to technically depend on the functionCode. If that is deemed necessary, such concepts should be defined in the Participation.typeCode instead.                                                      Discussion: This code can accommodate the huge variety and nuances of functions that participants may perform in the act. The number and kinds of functions applicable depends on the special kind of act. E.g., each operation and method may require a different number of assistant surgeons or nurses.                        Since participation functions refer to what people do in an Act, these are really sub-activities that may all occur in parallel. If any more detail needs to be said about these activities other than just who does them, one should consider using component acts instead.
      ///</summary>
      private HL7Connect.Cda.CD propGetFunctionCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().functionCode);
      }
      private void propSetFunctionCode(HL7Connect.Cda.CD value)
      {
        wrapped().functionCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An optional code specifying additional detail about the function that the Participation has in the Act, if such detail is not implied by the Participation.typeCode.                                                      Examples: First surgeon, second surgeon (or first assistant surgeon, the one facing the primary surgeon), second assistant (often standing next to the primary surgeon), potentially a third assistant, scrub nurse, circulating nurse, nurse assistant, anesthetist, attending anesthetist, anesthesia nurse, technician who positions the patient, postoperative watch nurse, assistants, midwives, students, etc.                                                      Constraints: This code, if specified at all, *must not* be in conflict with the Participation.typeCode.                         No HL7 standard specification may be written to technically depend on the functionCode. If that is deemed necessary, such concepts should be defined in the Participation.typeCode instead.                                                      Discussion: This code can accommodate the huge variety and nuances of functions that participants may perform in the act. The number and kinds of functions applicable depends on the special kind of act. E.g., each operation and method may require a different number of assistant surgeons or nurses.                        Since participation functions refer to what people do in an Act, these are really sub-activities that may all occur in parallel. If any more detail needs to be said about these activities other than just who does them, one should consider using component acts instead.
      ///</summary>
      public HL7Connect.Cda.CD functionCode { get { return propGetFunctionCode(); } set { propSetFunctionCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

    }

    ///<summary>
    /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
    ///</summary>
    public class Performer2 : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Performer2
      ///</summary>
      public Performer2() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPerformer2()) {} 

      internal Performer2(IcdaPerformer2 com) : base(com) {} 

      internal new HCcdaPerformer2 wrapped() { return (HCcdaPerformer2) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the time during which the participant is involved in the act through this Participation.                                                      Rationale: Participation time is needed when the participant's involvement in the act spans only part of the Act's time. Participation time is also used to indicate the time at which certain very common sub-activities happen that are not worth mentioning in full acts.                                                      Examples: 1) The time data was entered into the originating system is the Participation.time of the "data entry" participation.                        2) The end of the participation time of an author is the time associated with the signature.                        3) The Participation.time of a co-signing participation is also the time of that co-signature.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the modality by which the Entity playing the Role is participating in the Act.                                                      Examples: Physically present, over the telephone, written communication.                                                       Rationale: Particularly for author (originator) participants this is used to specify whether the information represented by the act was initially provided verbally, (hand-)written, or electronically.
      ///</summary>
      private HL7Connect.Cda.CD propGetModeCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().modeCode);
      }
      private void propSetModeCode(HL7Connect.Cda.CD value)
      {
        wrapped().modeCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the modality by which the Entity playing the Role is participating in the Act.                                                      Examples: Physically present, over the telephone, written communication.                                                       Rationale: Particularly for author (originator) participants this is used to specify whether the information represented by the act was initially provided verbally, (hand-)written, or electronically.
      ///</summary>
      public HL7Connect.Cda.CD modeCode { get { return propGetModeCode(); } set { propSetModeCode(value); } }

      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// An entity that is a person
    ///</summary>
    public class Person : HL7Connect.Cda.AuthorChoice
    {

      ///<summary>
      /// Create a CDA Person
      ///</summary>
      public Person() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPerson()) {} 

      internal Person(IcdaPerson com) : base(com) {} 

      internal new HCcdaPerson wrapped() { return (HCcdaPerson) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.ListEN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.ListEN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.ListEN name { get { return propGetName(); } set { propSetName(value); } }

    }

    ///<summary>
    /// a location - identified by a name and/or address
    ///</summary>
    public class Place : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Place
      ///</summary>
      public Place() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPlace()) {} 

      internal Place(IcdaPlace com) : base(com) {} 

      internal new HCcdaPlace wrapped() { return (HCcdaPlace) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.EN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.EN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.EN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The physical address of this place.                                                       Constraints: Must be the address that allows the physical location of the place on a map.
      ///</summary>
      private HL7Connect.Cda.AD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.AD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.AD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The physical address of this place.                                                       Constraints: Must be the address that allows the physical location of the place on a map.
      ///</summary>
      public HL7Connect.Cda.AD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role by playing the role
    ///</summary>
    public class PlayingEntity : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA PlayingEntity
      ///</summary>
      public PlayingEntity() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPlayingEntity()) {} 

      internal PlayingEntity(IcdaPlayingEntity com) : base(com) {} 

      internal new HCcdaPlayingEntity wrapped() { return (HCcdaPlayingEntity) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the specific kind of Entity the instance represents.                                                      Examples: A medical building, a Doberman Pinscher, a blood collection tube, a tissue biopsy.                                                      Rationale: For each Entity, the value for this attribute is drawn from one of several coding systems depending on the Entity.classCode, such as living subjects (animal and plant taxonomies), chemical substance (e.g., IUPAC code), organizations, insurance company, government agency, hospital, park, lake, syringe, etc. It is possible that Entity.code may be so fine grained that it represents a single instance. An example is the CDC vaccine manufacturer code, modeled as a concept vocabulary, when in fact each concept refers to a single instance.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The number or quantity of the Entity, with appropriate units, congruent with the value of Entity.determinerCode.                                                       Examples: With undetermined kinds, the quantity is but a reference quantity for the specification of the proportion of ingredients or components (e.g. through a has-part, has-ingredient, or has-content Role). For example, a kind of group with 60% females is Person(quantity = 100) has-part Person(quantity = 60; sex = female). Amoxicillin 500 mg per tablet is Material(Tablet, quantity = 1) has-ingredient Material(Amoxicillin, quantity = 500 mg). Glucose 5% (D5W) is Material(D5W, quantity = 1 kg) has-ingredient Material(Glucose, quantity = 50 g).                        Material-specific quantity relations are expressed using the fact that the data type of this attribute is a set of physical quantity (SET&lt;PQ&gt;). If more than one quantity value are specified in this set, each element in this set is considered to specify the same amount of the material. For example, for one liter of water one could use the set 1 L, 1 kg, 55.56 mol to specify the volume, mass, and amount of substance for the same amount of water, this is equivalent with specifying the mass density (volumic mass 1 kg/L) and the molar mass (18 g/mol). For Glucose one could specify 180 g, 1 mol according to the molar mass (180 g/mol).                                                      Discussion: When the Entity instance is a portion of a substance, the quantity specifies the amount of that substance comprised by that portion. For an undetermined substance (kind) the quantity serves two purposes at the same time: (a) it provides a means of relations between quantities specific for that substance, and (b) it is a reference quantity for the specification of ingredients or components. In all cases, the quantity is an extensive "amount" kind of quantity (e.g., number, length, volume, mass, surface area, energy, etc.). Note that most relative or fractional quantities are not amounts, in particular, mass fraction, substance concentration, mass ratios, percentages, etc. are not extensive quantities and are prohibited values for this attribute.                                                      Constraints: For Entities with determinerCode = INSTANCE, the quantity is 1. For an Entity with determinerCode = QUANTIFIED_KIND, the quantity is the number of individual members in the group; for an Entity with a determinerCode = KIND, the value is undetermined.
      ///</summary>
      private HL7Connect.Cda.ListPQ propGetQuantity()
      {
        return HL7Connect.Cda.WrapperFactory.ListPQ(wrapped().quantity);
      }
      private void propSetQuantity(HL7Connect.Cda.ListPQ value)
      {
        wrapped().quantity = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The number or quantity of the Entity, with appropriate units, congruent with the value of Entity.determinerCode.                                                       Examples: With undetermined kinds, the quantity is but a reference quantity for the specification of the proportion of ingredients or components (e.g. through a has-part, has-ingredient, or has-content Role). For example, a kind of group with 60% females is Person(quantity = 100) has-part Person(quantity = 60; sex = female). Amoxicillin 500 mg per tablet is Material(Tablet, quantity = 1) has-ingredient Material(Amoxicillin, quantity = 500 mg). Glucose 5% (D5W) is Material(D5W, quantity = 1 kg) has-ingredient Material(Glucose, quantity = 50 g).                        Material-specific quantity relations are expressed using the fact that the data type of this attribute is a set of physical quantity (SET&lt;PQ&gt;). If more than one quantity value are specified in this set, each element in this set is considered to specify the same amount of the material. For example, for one liter of water one could use the set 1 L, 1 kg, 55.56 mol to specify the volume, mass, and amount of substance for the same amount of water, this is equivalent with specifying the mass density (volumic mass 1 kg/L) and the molar mass (18 g/mol). For Glucose one could specify 180 g, 1 mol according to the molar mass (180 g/mol).                                                      Discussion: When the Entity instance is a portion of a substance, the quantity specifies the amount of that substance comprised by that portion. For an undetermined substance (kind) the quantity serves two purposes at the same time: (a) it provides a means of relations between quantities specific for that substance, and (b) it is a reference quantity for the specification of ingredients or components. In all cases, the quantity is an extensive "amount" kind of quantity (e.g., number, length, volume, mass, surface area, energy, etc.). Note that most relative or fractional quantities are not amounts, in particular, mass fraction, substance concentration, mass ratios, percentages, etc. are not extensive quantities and are prohibited values for this attribute.                                                      Constraints: For Entities with determinerCode = INSTANCE, the quantity is 1. For an Entity with determinerCode = QUANTIFIED_KIND, the quantity is the number of individual members in the group; for an Entity with a determinerCode = KIND, the value is undetermined.
      ///</summary>
      public HL7Connect.Cda.ListPQ quantity { get { return propGetQuantity(); } set { propSetQuantity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.ListEN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.ListEN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.ListEN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A textual or multimedia depiction of the Entity.                                                      Discussion: The content of the description is not considered part of the functional information communicated between systems. Descriptions are meant to be shown to interested human individuals. All information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Rationale: Names and descriptions of entities are typically more meaningful to human viewers than numeric, mnemonic or abbreviated code values. The description allows for additional context about the entity to be conveyed to human viewers without impacting the functional components of the message.
      ///</summary>
      private HL7Connect.Cda.ED propGetDesc()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Desc);
      }
      private void propSetDesc(HL7Connect.Cda.ED value)
      {
        wrapped().Desc = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A textual or multimedia depiction of the Entity.                                                      Discussion: The content of the description is not considered part of the functional information communicated between systems. Descriptions are meant to be shown to interested human individuals. All information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Rationale: Names and descriptions of entities are typically more meaningful to human viewers than numeric, mnemonic or abbreviated code values. The description allows for additional context about the entity to be conveyed to human viewers without impacting the functional components of the message.
      ///</summary>
      public HL7Connect.Cda.ED desc { get { return propGetDesc(); } set { propSetDesc(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
    ///</summary>
    public class Precondition : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Precondition
      ///</summary>
      public Precondition() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newPrecondition()) {} 

      internal Precondition(IcdaPrecondition com) : base(com) {} 

      internal new HCcdaPrecondition wrapped() { return (HCcdaPrecondition) com; }

      ///<summary>
      /// a condition that must hold true before some over activity occurs
      ///</summary>
      private HL7Connect.Cda.Criterion propGetCriterion()
      {
        return HL7Connect.Cda.WrapperFactory.Criterion(wrapped().criterion);
      }
      private void propSetCriterion(HL7Connect.Cda.Criterion value)
      {
        wrapped().criterion = value.wrapped();
      }
      ///<summary>
      /// a condition that must hold true before some over activity occurs
      ///</summary>
      public HL7Connect.Cda.Criterion criterion { get { return propGetCriterion(); } set { propSetCriterion(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// A derivative of the RIM Procedure class, used for representing procedures.
    ///</summary>
    public class Procedure : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA Procedure
      ///</summary>
      public Procedure() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newProcedure()) {} 

      internal Procedure(IcdaProcedure com) : base(com) {} 

      internal new HCcdaProcedure wrapped() { return (HCcdaProcedure) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      private HL7Connect.Cda.CD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.CD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      public HL7Connect.Cda.CD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Identifies the means or technique used to perform the procedure.                                                      Discussion: For any Procedure there may be several different methods to achieve by and large the same result, but may be important to know when interpreting a report more thoroughly (e.g., cholecystectomy: open vs. laparoscopic). Method concepts can be "pre-coordinated" in the Act definition. There are many possible methods, which all depend heavily on the particular kind of Procedure, so that defining a vocabulary domain of all methods is difficult. However, a code system might be designed such that it specifies a set of available methods for each defined Procedure concept. Thus, a user ordering a Procedure could select one of several variances of the act by means of the method code. Available method variances may also be defined in a master service catalog for each defined Procedure. In act definition records (Act.moodCode = DEF) the methodCode attribute is a set of all available method codes that a user may select while ordering, or expect while receiving results.                        For Substance Administrations, the routeCode frequently conveys the method. This attribute is only needed if the routeCode requires further specification. For example, if the routeCode is "by mouth", no further information about the method may be required. If, however, routeCode is intravenous or intra-muscular, the precise method of administration may be specified in this attribute (e.g., "slow bolus injection" or "Z-track injection" respectively).                        Route of administration (routeCode), site of administration (approachSiteCode) and the method of administration are closely related in Substance Administrations. All three (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetMethodCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().methodCode);
      }
      private void propSetMethodCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().methodCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Identifies the means or technique used to perform the procedure.                                                      Discussion: For any Procedure there may be several different methods to achieve by and large the same result, but may be important to know when interpreting a report more thoroughly (e.g., cholecystectomy: open vs. laparoscopic). Method concepts can be "pre-coordinated" in the Act definition. There are many possible methods, which all depend heavily on the particular kind of Procedure, so that defining a vocabulary domain of all methods is difficult. However, a code system might be designed such that it specifies a set of available methods for each defined Procedure concept. Thus, a user ordering a Procedure could select one of several variances of the act by means of the method code. Available method variances may also be defined in a master service catalog for each defined Procedure. In act definition records (Act.moodCode = DEF) the methodCode attribute is a set of all available method codes that a user may select while ordering, or expect while receiving results.                        For Substance Administrations, the routeCode frequently conveys the method. This attribute is only needed if the routeCode requires further specification. For example, if the routeCode is "by mouth", no further information about the method may be required. If, however, routeCode is intravenous or intra-muscular, the precise method of administration may be specified in this attribute (e.g., "slow bolus injection" or "Z-track injection" respectively).                        Route of administration (routeCode), site of administration (approachSiteCode) and the method of administration are closely related in Substance Administrations. All three (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.
      ///</summary>
      public HL7Connect.Cda.ListCD methodCode { get { return propGetMethodCode(); } set { propSetMethodCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The anatomical site or system through which the procedure reaches its target (see targetSiteCode).                                                      Examples:                                                   Nephrectomy can have a trans-abdominal or a primarily retroperitoneal approach                        An arteria pulmonalis catheter targets a pulmonary artery but the approach site is typically the vena carotis interna or the vena subclavia, at the neck or the fossa subclavia respectively.                        For Substance Administration, it is the detailed anatomical site where the medication enters or is applied to the subject.                        For non-invasive procedures, e.g., acupuncture, the approach site is the punctured area of the skin.                                                      Discussion: If the subject of the Act is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses.                        Some approach sites can also be "pre-coordinated" in the Act definition, so that there is never an option to select different body sites. The same information structure can handle both the pre-coordinated and the post-coordinated approach.                        In Substance Administration, the route (routeCode), site of administration (approachSiteCode), the method of administration (methodCode) and the device used in administration are closely related. All four (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetApproachSiteCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().approachSiteCode);
      }
      private void propSetApproachSiteCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().approachSiteCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The anatomical site or system through which the procedure reaches its target (see targetSiteCode).                                                      Examples:                                                   Nephrectomy can have a trans-abdominal or a primarily retroperitoneal approach                        An arteria pulmonalis catheter targets a pulmonary artery but the approach site is typically the vena carotis interna or the vena subclavia, at the neck or the fossa subclavia respectively.                        For Substance Administration, it is the detailed anatomical site where the medication enters or is applied to the subject.                        For non-invasive procedures, e.g., acupuncture, the approach site is the punctured area of the skin.                                                      Discussion: If the subject of the Act is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses.                        Some approach sites can also be "pre-coordinated" in the Act definition, so that there is never an option to select different body sites. The same information structure can handle both the pre-coordinated and the post-coordinated approach.                        In Substance Administration, the route (routeCode), site of administration (approachSiteCode), the method of administration (methodCode) and the device used in administration are closely related. All four (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.
      ///</summary>
      public HL7Connect.Cda.ListCD approachSiteCode { get { return propGetApproachSiteCode(); } set { propSetApproachSiteCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The anatomical site or system that is the focus of the procedure.                                                      Examples:                                                   A Nephrectomy's target site is the right or left kidney                        An arteria pulmonalis catheter targets a pulmonary artery.                        For non-invasive procedures, e.g., acupuncture, the target site is the organ/system that is sought to be influenced (e.g., "the liver").                                                      Discussion: If the subject of the Act is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses.                        Some target sites can also be "pre-coordinated" in the Act definition, so that there is never an option to select different body sites. The same information structure can handle both the pre-coordinated and the post-coordinated approach.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetTargetSiteCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().targetSiteCode);
      }
      private void propSetTargetSiteCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().targetSiteCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The anatomical site or system that is the focus of the procedure.                                                      Examples:                                                   A Nephrectomy's target site is the right or left kidney                        An arteria pulmonalis catheter targets a pulmonary artery.                        For non-invasive procedures, e.g., acupuncture, the target site is the organ/system that is sought to be influenced (e.g., "the liver").                                                      Discussion: If the subject of the Act is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses.                        Some target sites can also be "pre-coordinated" in the Act definition, so that there is never an option to select different body sites. The same information structure can handle both the pre-coordinated and the post-coordinated approach.
      ///</summary>
      public HL7Connect.Cda.ListCD targetSiteCode { get { return propGetTargetSiteCode(); } set { propSetTargetSiteCode(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// Procedure.negationInd, when set to "true", is a positive assertion that the Procedure as a whole is negated. Some properties such as Procedure.id, Procedure.moodCode, and the participations are not affected. These properties always have the same meaning: i.e., the author remains the author of the negative Procedure. A procedure statement with negationInd is still a statement about the specific fact described by the Procedure. For instance, a negated "appendectomy performed" means that the author positively denies that there was ever an appendectomy performed, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation.
      ///</summary>
      private bool propGetNegationInd()
      {
        return wrapped().negationInd != 0;
      }
      private void propSetNegationInd(bool value)
      {
        wrapped().negationInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Procedure.negationInd, when set to "true", is a positive assertion that the Procedure as a whole is negated. Some properties such as Procedure.id, Procedure.moodCode, and the participations are not affected. These properties always have the same meaning: i.e., the author remains the author of the negative Procedure. A procedure statement with negationInd is still a statement about the specific fact described by the Procedure. For instance, a negated "appendectomy performed" means that the author positively denies that there was ever an appendectomy performed, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation.
      ///</summary>
      public bool negationInd { get { return propGetNegationInd(); } set { propSetNegationInd(value); } }

      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      private bool propGetHasNegationInd()
      {
        return wrapped().HasNegationInd != 0;
      }
      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      public bool HasNegationInd { get { return propGetHasNegationInd(); } }

    }

    ///<summary>
    /// The dispensed product is associated with the Supply act via a product participant, which connects to the same ManufacturedProduct role used for SubstanceAdministration
    ///</summary>
    public class Product : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Product
      ///</summary>
      public Product() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newProduct()) {} 

      internal Product(IcdaProduct com) : base(com) {} 

      internal new HCcdaProduct wrapped() { return (HCcdaProduct) com; }

      ///<summary>
      /// used to bring in the LabeledDrug or Material entity that describes the administered substance
      ///</summary>
      private HL7Connect.Cda.ManufacturedProduct propGetManufacturedProduct()
      {
        return HL7Connect.Cda.WrapperFactory.ManufacturedProduct(wrapped().manufacturedProduct);
      }
      private void propSetManufacturedProduct(HL7Connect.Cda.ManufacturedProduct value)
      {
        wrapped().manufacturedProduct = value.wrapped();
      }
      ///<summary>
      /// used to bring in the LabeledDrug or Material entity that describes the administered substance
      ///</summary>
      public HL7Connect.Cda.ManufacturedProduct manufacturedProduct { get { return propGetManufacturedProduct(); } set { propSetManufacturedProduct(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// The recordTarget represents the medical record that this document belongs to. 
    /// 
    /// A clinical document typically has exactly one recordTarget participant. In the uncommon case where a clinical document (such as a group encounter note) is placed into more than one patient chart, more than one recordTarget participants can be stated.
    ///</summary>
    public class RecordTarget : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA RecordTarget
      ///</summary>
      public RecordTarget() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRecordTarget()) {} 

      internal RecordTarget(IcdaRecordTarget com) : base(com) {} 

      internal new HCcdaRecordTarget wrapped() { return (HCcdaRecordTarget) com; }

      ///<summary>
      /// A person that is a patient (receiving healthcare from a provider)
      ///</summary>
      private HL7Connect.Cda.PatientRole propGetPatientRole()
      {
        return HL7Connect.Cda.WrapperFactory.PatientRole(wrapped().patientRole);
      }
      private void propSetPatientRole(HL7Connect.Cda.PatientRole value)
      {
        wrapped().patientRole = value.wrapped();
      }
      ///<summary>
      /// A person that is a patient (receiving healthcare from a provider)
      ///</summary>
      public HL7Connect.Cda.PatientRole patientRole { get { return propGetPatientRole(); } set { propSetPatientRole(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
    /// 
    /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
    ///</summary>
    public class Reference : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Reference
      ///</summary>
      public Reference() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newReference()) {} 

      internal Reference(IcdaReference com) : base(com) {} 

      internal new HCcdaReference wrapped() { return (HCcdaReference) com; }

      ///<summary>
      /// the attribute reference.seperatableInd indicates whether or not the source is intended to be interpreted independently of the target. The indicator cannot prevent an individual or application from separating the source and target, but indicates the author's desire and willingness to attest to the content of the source if separated from the target. Typically, where seperatableInd is "false", the exchanged package should include the target of the reference so that the recipient can render it.
      ///</summary>
      private HL7Connect.Cda.BL propGetSeperatableInd()
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().seperatableInd);
      }
      private void propSetSeperatableInd(HL7Connect.Cda.BL value)
      {
        wrapped().seperatableInd = value.wrapped();
      }
      ///<summary>
      /// the attribute reference.seperatableInd indicates whether or not the source is intended to be interpreted independently of the target. The indicator cannot prevent an individual or application from separating the source and target, but indicates the author's desire and willingness to attest to the content of the source if separated from the target. Typically, where seperatableInd is "false", the exchanged package should include the target of the reference so that the recipient can render it.
      ///</summary>
      public HL7Connect.Cda.BL seperatableInd { get { return propGetSeperatableInd(); } set { propSetSeperatableInd(value); } }

      ///<summary>
      /// ExternalAct is a derivative of the RIM Act class, to be used when the other more specific classes are not appropriate.
      ///</summary>
      private HL7Connect.Cda.ExternalAct propGetExternalAct()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalAct(wrapped().externalAct);
      }
      private void propSetExternalAct(HL7Connect.Cda.ExternalAct value)
      {
        wrapped().externalAct = value.wrapped();
      }
      ///<summary>
      /// ExternalAct is a derivative of the RIM Act class, to be used when the other more specific classes are not appropriate.
      ///</summary>
      public HL7Connect.Cda.ExternalAct externalAct { get { return propGetExternalAct(); } set { propSetExternalAct(value); } }

      ///<summary>
      /// ExternalObservation is a derivative of the RIM Observation class, used for representing external coded and other observations
      ///</summary>
      private HL7Connect.Cda.ExternalObservation propGetExternalObservation()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalObservation(wrapped().externalObservation);
      }
      private void propSetExternalObservation(HL7Connect.Cda.ExternalObservation value)
      {
        wrapped().externalObservation = value.wrapped();
      }
      ///<summary>
      /// ExternalObservation is a derivative of the RIM Observation class, used for representing external coded and other observations
      ///</summary>
      public HL7Connect.Cda.ExternalObservation externalObservation { get { return propGetExternalObservation(); } set { propSetExternalObservation(value); } }

      ///<summary>
      /// ExternalProcedure is a derivative of the RIM Procedure class, used for representing external procedures.
      ///</summary>
      private HL7Connect.Cda.ExternalProcedure propGetExternalProcedure()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalProcedure(wrapped().externalProcedure);
      }
      private void propSetExternalProcedure(HL7Connect.Cda.ExternalProcedure value)
      {
        wrapped().externalProcedure = value.wrapped();
      }
      ///<summary>
      /// ExternalProcedure is a derivative of the RIM Procedure class, used for representing external procedures.
      ///</summary>
      public HL7Connect.Cda.ExternalProcedure externalProcedure { get { return propGetExternalProcedure(); } set { propSetExternalProcedure(value); } }

      ///<summary>
      /// ExternalDocument is a derivative of the RIM Document class, used for representing external documents. ExternalDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the external document.
      ///</summary>
      private HL7Connect.Cda.ExternalDocument propGetExternalDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalDocument(wrapped().externalDocument);
      }
      private void propSetExternalDocument(HL7Connect.Cda.ExternalDocument value)
      {
        wrapped().externalDocument = value.wrapped();
      }
      ///<summary>
      /// ExternalDocument is a derivative of the RIM Document class, used for representing external documents. ExternalDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the external document.
      ///</summary>
      public HL7Connect.Cda.ExternalDocument externalDocument { get { return propGetExternalDocument(); } set { propSetExternalDocument(value); } }

      ///<summary>
      /// Choice of externalAct, externalObservation, externalProcedure, or externalDocument
      ///</summary>
      private HL7Connect.Cda.ExternalActChoice propGetExternalActChoice()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalActChoice(wrapped().externalActChoice);
      }
      ///<summary>
      /// Choice of externalAct, externalObservation, externalProcedure, or externalDocument
      ///</summary>
      public HL7Connect.Cda.ExternalActChoice externalActChoice { get { return propGetExternalActChoice(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

    }

    ///<summary>
    /// An Observation can have zero to many referenceRange relationships, which relate an Observation to the ObservationRange class, where the expected range of values for a particular observation can be specified.
    ///</summary>
    public class ReferenceRange : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ReferenceRange
      ///</summary>
      public ReferenceRange() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newReferenceRange()) {} 

      internal ReferenceRange(IcdaReferenceRange com) : base(com) {} 

      internal new HCcdaReferenceRange wrapped() { return (HCcdaReferenceRange) com; }

      ///<summary>
      /// An Observation can have zero to many referenceRange relationships, which relate an Observation to the ObservationRange class, where the expected range of values for a particular observation can be specified.
      ///</summary>
      private HL7Connect.Cda.ObservationRange propGetObservationRange()
      {
        return HL7Connect.Cda.WrapperFactory.ObservationRange(wrapped().observationRange);
      }
      private void propSetObservationRange(HL7Connect.Cda.ObservationRange value)
      {
        wrapped().observationRange = value.wrapped();
      }
      ///<summary>
      /// An Observation can have zero to many referenceRange relationships, which relate an Observation to the ObservationRange class, where the expected range of values for a particular observation can be specified.
      ///</summary>
      public HL7Connect.Cda.ObservationRange observationRange { get { return propGetObservationRange(); } set { propSetObservationRange(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// A value. The meaning of unsorted is presently unknown (!)
    ///</summary>
    public class RegionOfInterest_value : HL7Connect.Cda.INT
    {

      ///<summary>
      /// Create a CDA RegionOfInterest_value
      ///</summary>
      public RegionOfInterest_value() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRegionOfInterest_value()) {} 

      internal RegionOfInterest_value(IcdaRegionOfInterest_value com) : base(com) {} 

      internal new HCcdaRegionOfInterest_value wrapped() { return (HCcdaRegionOfInterest_value) com; }

      ///<summary>
      /// The meaning of unsorted is presently unknown (!)
      ///</summary>
      private bool propGetUnsorted()
      {
        return wrapped().unsorted != 0;
      }
      private void propSetUnsorted(bool value)
      {
        wrapped().unsorted = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// The meaning of unsorted is presently unknown (!)
      ///</summary>
      public bool unsorted { get { return propGetUnsorted(); } set { propSetUnsorted(value); } }

      ///<summary>
      /// false if unsorted is null, true if unsorted is either true or false
      ///</summary>
      private bool propGetHasUnsorted()
      {
        return wrapped().HasUnsorted != 0;
      }
      ///<summary>
      /// false if unsorted is null, true if unsorted is either true or false
      ///</summary>
      public bool HasUnsorted { get { return propGetHasUnsorted(); } }

    }

    ///<summary>
    /// A derivative of the RIM Observation class that represents a region of interest on an image, using an overlay shape. RegionOfInterest is used to make reference to specific regions in images, e.g., to specify the site of a physical finding by "circling" a region in a schematic picture of a human body. The units of the coordinate values in RegionOfInterest.value are in pixels, expressed as a list of integers. The origin is in the upper left hand corner, with positive X values going to the right and positive Y values going down. The relationship between a RegionOfInterest and its referenced ObservationMedia or ExternalObservation is specified by traversing the entryRelationship or reference class, respectively, where typeCode equals "SUBJ". A RegionOfInterest must reference exactly one ObservationMedia or one ExternalObservation. If the RegionOfInterest is the target of a &lt;renderMultimedia&gt; reference, then it shall only reference a ObservationMedia and not an ExternalObservation.
    ///</summary>
    public class RegionOfInterest : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA RegionOfInterest
      ///</summary>
      public RegionOfInterest() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRegionOfInterest()) {} 

      internal RegionOfInterest(IcdaRegionOfInterest com) : base(com) {} 

      internal new HCcdaRegionOfInterest wrapped() { return (HCcdaRegionOfInterest) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CS propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CS value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CS code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      private HL7Connect.Cda.RegionOfInterest_valueList propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.RegionOfInterest_valueList(wrapped().Value);
      }
      private void propSetValue(HL7Connect.Cda.RegionOfInterest_valueList value)
      {
        wrapped().Value = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Information that is assigned or determined by the observation action.                                                       Constraints: The Observation.value, if not otherwise constrained, can be of any data type.                        The appropriate data type of the Observation.value varies with the kind of Observation and can generally be described in Observation definitions or in a simple relation that pairs Act.codes to value data types.                        The following guidelines govern the choice of the appropriate value data type.                        (1) Quantitative measurements use the data type Physical Quantity (PQ) in general. A PQ is essentially a real number with a unit. This is the general preference for all numeric values, subject to a few exceptions listed below.                         Numeric values *must not* be communicated as simply a character string (ST).                         (2) Titer (e.g., 1:64) and very few other ratios use the data type Ratio (RTO). For titers, the ratio would be a ratio of two integer numbers (e.g., 1:128). Other ratios may relate different quantitative data types, such as a "price" specified in Physical Quantity over Monetary Amount.                        Sometimes by local conventions titers are reported as just the denominator (e.g., 32 instead of 1/32). Such conventions are confusing and *should* be converted into correct ratios in HL7 messages.                         (3) Index values (a number without unit) uses the Real Number (REAL) data type. When a quantity does not have a proper unit, one can just send the number as a real number. Alternatively one can use a PQ with a dimensionless unit (e.g., 1 or %). An integer number should only be sent when the measurement is by definition an integer, which is an extremely rare case and then is most likely an ordinal (see below).                        (4) Ranges (e.g., &lt;3; 12-20) must be expressed as Interval of Physical Quantity (IVL&lt;PQ&gt;) or intervals of other quantity data types.                        Sometimes such intervals are used to report the uncertainty of measurement value. For uncertainty there are dedicated data type extensions available.                         (5) Ordinals (e.g., +, ++, +++; or I, IIa, IIb, III, IV) use the Coded Ordinal (CO) data type.                         (6) Nominal results ("taxons", e.g., organism type). use any of the coded data types (CD, CE) that specify at least a code and a coding system, and optionally original text, translations to other coding systems and sometimes qualifiers.                         (7) Imaging results use the Encapsulated Data (ED) type. The encapsulated data type allows one to send an image (e.g., chest X-ray) or a movie (e.g., coronary angiography, cardiac echo) as alternatively inline binary data or as a reference to an external address where the data can be downloaded on demand.                        (8) Waveforms can be sent using the Correlated Observation Sequences templates that provide all the data in an HL7 framework. In addition one can use the Encapsulated Data (ED) data type to send waveforms in other than HL7 formats or to refer to waveform data for on-demand download.                         (9) The character string data type may exceptionally be used to convey formalized expressions that do not fit in any of the existing data types. However, the string data type *must not* be used if the meaning can be represented by one of the existing data types.                         (10) Timestamps *should not* be sent in Observations if there are more appropriate places to send those, e.g., usually as Act.effectiveTime of some act. (E.g., "specimen received in lab" is in the effectiveTime of an Act describing the specimen transport to the lab, not in an Observation.                        (11) Sets of values of any data type, enumerated sets as well as intervals, are often used for Observation criteria (event-criterion mood) to specify "normal ranges" or "decision ranges" (for alerts) etc.                        (12) For sequences of observations (repeated measurements of the same property during a relatively short time) a Sequence (LIST) data type is used. Refer to the Correlated Observation Sequences specification for more detail.                        (13) Uncertainty of values is specified using the Probability and Probability Distribution data type extensions (UVP, PPD). If a statistical sample is reported with absolute frequencies of categories a Bag collection (BAG) can be used efficiently.
      ///</summary>
      public HL7Connect.Cda.RegionOfInterest_valueList value { get { return propGetValue(); } set { propSetValue(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// XML ID - target of an ID reference in the structured text. 
      /// 
      /// Note that in XML this is the "ID" attribute, but has been renamed for the sake of some non-case sensitive implementations
      ///</summary>
      private string propGetID_()
      {
        return wrapped().ID_;
      }
      private void propSetID_(string value)
      {
        wrapped().ID_ = value;
      }
      ///<summary>
      /// XML ID - target of an ID reference in the structured text. 
      /// 
      /// Note that in XML this is the "ID" attribute, but has been renamed for the sake of some non-case sensitive implementations
      ///</summary>
      public string ID_ { get { return propGetID_(); } set { propSetID_(value); } }

    }

    ///<summary>
    /// represents the source of a document revision, addenda, or transformation
    ///</summary>
    public class RelatedDocument : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA RelatedDocument
      ///</summary>
      public RelatedDocument() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRelatedDocument()) {} 

      internal RelatedDocument(IcdaRelatedDocument com) : base(com) {} 

      internal new HCcdaRelatedDocument wrapped() { return (HCcdaRelatedDocument) com; }

      ///<summary>
      /// The ParentDocument represents the source of a document revision, addenda, or transformation. ParentDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the parent document. It is not to be used to embed the related document, and thus ParentDocument.text.BIN is precluded from use.
      ///</summary>
      private HL7Connect.Cda.ParentDocument propGetParentDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ParentDocument(wrapped().parentDocument);
      }
      private void propSetParentDocument(HL7Connect.Cda.ParentDocument value)
      {
        wrapped().parentDocument = value.wrapped();
      }
      ///<summary>
      /// The ParentDocument represents the source of a document revision, addenda, or transformation. ParentDocument.text is modeled as an ED data type - allowing for the expression of the MIME type of the parent document. It is not to be used to embed the related document, and thus ParentDocument.text.BIN is precluded from use.
      ///</summary>
      public HL7Connect.Cda.ParentDocument parentDocument { get { return propGetParentDocument(); } set { propSetParentDocument(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      private void propSetTypeCode(string value)
      {
        wrapped().typeCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the meaning and purpose of every ActRelationship instance. Each of its values implies specific constraints to what kinds of Act objects can be related and in which way.                                                      Discussion: The types of act relationships fall under one of 5 categories:                        1.) (De)-composition, with composite (source) and component (target).                        2.) Sequel which includes follow-up, fulfillment, instantiation, replacement, transformation, etc. that all have in common that source and target are Acts of essentially the same kind but with variances in mood and other attributes, and where the target exists before the source and the source refers to the target that it links back to.                        3.) Pre-condition, trigger, reason, contraindication, with the conditioned Act at the source and the condition or reason at the target.                        4.) Post-condition, outcome, goal and risk, with the Act at the source having the outcome or goal at the target.                        5.) A host of functional relationships including support, cause, derivation, etc. generalized under the notion of "pertinence".
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } set { propSetTypeCode(value); } }

    }

    ///<summary>
    /// The RelatedEntity role is used to represent an informant without a role.id (e.g. a parent or guy on the street). The informant in this case bears some formal or personal relationship to the patient. The role is unscoped, with the assumption that the patient is always the implied scoper.
    ///</summary>
    public class RelatedEntity : HL7Connect.Cda.InformantChoice
    {

      ///<summary>
      /// Create a CDA RelatedEntity
      ///</summary>
      public RelatedEntity() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRelatedEntity()) {} 

      internal RelatedEntity(IcdaRelatedEntity com) : base(com) {} 

      internal new HCcdaRelatedEntity wrapped() { return (HCcdaRelatedEntity) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the period during which the Role is in effect, if such time limit is applicable and known.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of time specifying the period during which the Role is in effect, if such time limit is applicable and known.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// An entity that is a person
      ///</summary>
      private HL7Connect.Cda.Person propGetRelatedPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().relatedPerson);
      }
      private void propSetRelatedPerson(HL7Connect.Cda.Person value)
      {
        wrapped().relatedPerson = value.wrapped();
      }
      ///<summary>
      /// An entity that is a person
      ///</summary>
      public HL7Connect.Cda.Person relatedPerson { get { return propGetRelatedPerson(); } set { propSetRelatedPerson(value); } }

    }

    ///<summary>
    /// represents the primary target of the entries recorded in the document or section
    ///</summary>
    public class RelatedSubject : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA RelatedSubject
      ///</summary>
      public RelatedSubject() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newRelatedSubject()) {} 

      internal RelatedSubject(IcdaRelatedSubject com) : base(com) {} 

      internal new HCcdaRelatedSubject wrapped() { return (HCcdaRelatedSubject) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code further specifying the kind of Role.                                                      Discussion:  The Role.code must conceptually be a proper specialization of Role.classCode. Role.code does not modify Role.classCode. Rather, each is a complete concept or a Role-like relationship between two Entities, but Role.code may be more specific than Role.classCode.                        The Role.code may not be coded if only an un-coded name for the type of role is commonly used.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddr()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().addr);
      }
      private void propSetAddr(HL7Connect.Cda.ListAD value)
      {
        wrapped().addr = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListAD addr { get { return propGetAddr(); } set { propSetAddr(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecom()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().telecom);
      }
      private void propSetTelecom(HL7Connect.Cda.ListTEL value)
      {
        wrapped().telecom = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A telecommunication address for the Entity while in the Role.
      ///</summary>
      public HL7Connect.Cda.ListTEL telecom { get { return propGetTelecom(); } set { propSetTelecom(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.SubjectPerson propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.SubjectPerson(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.SubjectPerson value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.SubjectPerson subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

    }

    ///<summary>
    /// The responsibleParty participant represents the participant having primary legal responsibility for the encounter. This differs from the legalAuthenticator participant in that the legalAuthenticator may or may not be the responsible party, and is serving a medical records function by signing off on the document, moving it into a completed state.
    ///</summary>
    public class ResponsibleParty : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ResponsibleParty
      ///</summary>
      public ResponsibleParty() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newResponsibleParty()) {} 

      internal ResponsibleParty(IcdaResponsibleParty com) : base(com) {} 

      internal new HCcdaResponsibleParty wrapped() { return (HCcdaResponsibleParty) com; }

      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      private HL7Connect.Cda.AssignedEntity propGetAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().assignedEntity);
      }
      private void propSetAssignedEntity(HL7Connect.Cda.AssignedEntity value)
      {
        wrapped().assignedEntity = value.wrapped();
      }
      ///<summary>
      /// An assigned entity is a person assigned to the role by the scoping organization.
      ///</summary>
      public HL7Connect.Cda.AssignedEntity assignedEntity { get { return propGetAssignedEntity(); } set { propSetAssignedEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// Sections can nest, can override context propagated from the header, and can contain narrative and CDA entries. 
    /// 
    /// The section has an ID attribute. This attribute serves as the target of a linkHtml reference in narrative. All values of attributes of type XML ID must be unique within the document (per the W3C XML specification).
    ///</summary>
    public class Section : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Section
      ///</summary>
      public Section() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSection()) {} 

      internal Section(IcdaSection com) : base(com) {} 

      internal new HCcdaSection wrapped() { return (HCcdaSection) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.II propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.II value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.II id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// The code specifying the particular kind of section (e.g. Chief Complaint, Review of Systems, Assessment). The value set is drawn from LOINC, and has a CWE coding strength.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// The code specifying the particular kind of section (e.g. Chief Complaint, Review of Systems, Assessment). The value set is drawn from LOINC, and has a CWE coding strength.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// Represents the label of a section. If valued, it is to be rendered as part of the narrative content of the clinical document body.
      ///</summary>
      private HL7Connect.Cda.ST propGetTitle()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().title);
      }
      private void propSetTitle(HL7Connect.Cda.ST value)
      {
        wrapped().title = value.wrapped();
      }
      ///<summary>
      /// Represents the label of a section. If valued, it is to be rendered as part of the narrative content of the clinical document body.
      ///</summary>
      public HL7Connect.Cda.ST title { get { return propGetTitle(); } set { propSetTitle(value); } }

      ///<summary>
      /// Used to store narrative to be rendered. Also referred to as the CDA Narrative Block
      ///</summary>
      private HL7Connect.Cda.SDText propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.SDText(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.SDText value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// Used to store narrative to be rendered. Also referred to as the CDA Narrative Block
      ///</summary>
      public HL7Connect.Cda.SDText text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// A value for Section.confidentialityCode overrides the value propagated from StructuredBody
      ///</summary>
      private HL7Connect.Cda.CD propGetConfidentialityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().confidentialityCode);
      }
      private void propSetConfidentialityCode(HL7Connect.Cda.CD value)
      {
        wrapped().confidentialityCode = value.wrapped();
      }
      ///<summary>
      /// A value for Section.confidentialityCode overrides the value propagated from StructuredBody
      ///</summary>
      public HL7Connect.Cda.CD confidentialityCode { get { return propGetConfidentialityCode(); } set { propSetConfidentialityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// The relationship between a section and its entries is encoded in the intervening "entry" Act Relationship.
      ///</summary>
      private HL7Connect.Cda.EntryList propGetEntry()
      {
        return HL7Connect.Cda.WrapperFactory.EntryList(wrapped().entry);
      }
      private void propSetEntry(HL7Connect.Cda.EntryList value)
      {
        wrapped().entry = value.wrapped();
      }
      ///<summary>
      /// The relationship between a section and its entries is encoded in the intervening "entry" Act Relationship.
      ///</summary>
      public HL7Connect.Cda.EntryList entry { get { return propGetEntry(); } set { propSetEntry(value); } }

      ///<summary>
      /// The "component" Act Relationship is used to nest content. Context propagates to nested content
      ///</summary>
      private HL7Connect.Cda.Component5List propGetComponent()
      {
        return HL7Connect.Cda.WrapperFactory.Component5List(wrapped().Component);
      }
      private void propSetComponent(HL7Connect.Cda.Component5List value)
      {
        wrapped().Component = value.wrapped();
      }
      ///<summary>
      /// The "component" Act Relationship is used to nest content. Context propagates to nested content
      ///</summary>
      public HL7Connect.Cda.Component5List component { get { return propGetComponent(); } set { propSetComponent(value); } }

      ///<summary>
      /// XML ID - target of an ID reference in the structured text. 
      /// 
      /// Note that in XML this is the "ID" attribute, but has been renamed for the sake of some non-case sensitive implementations
      ///</summary>
      private string propGetID_()
      {
        return wrapped().ID_;
      }
      private void propSetID_(string value)
      {
        wrapped().ID_ = value;
      }
      ///<summary>
      /// XML ID - target of an ID reference in the structured text. 
      /// 
      /// Note that in XML this is the "ID" attribute, but has been renamed for the sake of some non-case sensitive implementations
      ///</summary>
      public string ID_ { get { return propGetID_(); } set { propSetID_(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// This class represents the main Act, such as a colonoscopy or an appendectomy, being documented. 
    /// 
    /// In some cases, the ServiceEvent is inherent in the ClinicalDocument.code, such as where ClinicalDocument.code is "History and Physical Report" and the procedure being documented is a "History and Physical" act. A ServiceEvent can further specialize the act inherent in the ClinicalDocument.code, such as where the ClinicalDocument.code is simply "Procedure Report" and the procedure was a "colonoscopy". If ServiceEvent is included, it must be equivalent to or further specialize the value inherent in the ClinicalDocument.code, and shall not conflict with the value inherent in the ClinicalDocument.code, as such a conflict would constitute an ambiguous situation. ServiceEvent.effectiveTime can be used to indicate the time the actual event (as opposed to the encounter surrounding the event) took place.
    ///</summary>
    public class ServiceEvent : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA ServiceEvent
      ///</summary>
      public ServiceEvent() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newServiceEvent()) {} 

      internal ServiceEvent(IcdaServiceEvent com) : base(com) {} 

      internal new HCcdaServiceEvent wrapped() { return (HCcdaServiceEvent) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the Act.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer1List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer1List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer1List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer1List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
    ///</summary>
    public class Specimen : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Specimen
      ///</summary>
      public Specimen() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSpecimen()) {} 

      internal Specimen(IcdaSpecimen com) : base(com) {} 

      internal new HCcdaSpecimen wrapped() { return (HCcdaSpecimen) com; }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenRole propGetSpecimenRole()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenRole(wrapped().specimenRole);
      }
      private void propSetSpecimenRole(HL7Connect.Cda.SpecimenRole value)
      {
        wrapped().specimenRole = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenRole specimenRole { get { return propGetSpecimenRole(); } set { propSetSpecimenRole(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

    }

    ///<summary>
    /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
    ///</summary>
    public class SpecimenRole : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA SpecimenRole
      ///</summary>
      public SpecimenRole() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSpecimenRole()) {} 

      internal SpecimenRole(IcdaSpecimenRole com) : base(com) {} 

      internal new HCcdaSpecimenRole wrapped() { return (HCcdaSpecimenRole) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      private void propSetId(HL7Connect.Cda.ListII value)
      {
        wrapped().ID = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A unique identifier for the player Entity in this Role.
      ///</summary>
      public HL7Connect.Cda.ListII id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role by playing the role
      ///</summary>
      private HL7Connect.Cda.PlayingEntity propGetSpecimenPlayingEntity()
      {
        return HL7Connect.Cda.WrapperFactory.PlayingEntity(wrapped().specimenPlayingEntity);
      }
      private void propSetSpecimenPlayingEntity(HL7Connect.Cda.PlayingEntity value)
      {
        wrapped().specimenPlayingEntity = value.wrapped();
      }
      ///<summary>
      /// A physical thing, group of physical things or an organization capable of participating in Acts while in a role by playing the role
      ///</summary>
      public HL7Connect.Cda.PlayingEntity specimenPlayingEntity { get { return propGetSpecimenPlayingEntity(); } set { propSetSpecimenPlayingEntity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major category of a Role as defined by HL7 vocabulary.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

    }

    ///<summary>
    /// The StructuredBody class represents a CDA document body that is comprised of one or more document sections, optionally with sections
    ///</summary>
    public class StructuredBody : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA StructuredBody
      ///</summary>
      public StructuredBody() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newStructuredBody()) {} 

      internal StructuredBody(IcdaStructuredBody com) : base(com) {} 

      internal new HCcdaStructuredBody wrapped() { return (HCcdaStructuredBody) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that controls the disclosure of information about this Act, regardless of mood.                                                      Discussion: It is important to note that the necessary confidentiality of the medical record cannot be achieved solely through confidentiality codes to mask individual record items from certain types of users. There are two important problems with per-item confidentiality: one is inference and the other is the danger of holding back information that may be critical in a certain care situation. Inference means that filtered sensitive information can still be assumed given the other information that was not filtered. The simplest form of inference is that even the existence of a test order for an HIV Western Blot test or a T4/T8 lymphocyte count is a strong indication for an existing HIV infection, even if the results are not known. Very often, diagnoses can be inferred from medication, such as Zidovudin for treatment of HIV infections. The problem of hiding individual items becomes especially difficult with current medications, since the continuing administration of the medication must be assured.                        To mitigate some of the inference-risk, aggregations of data should assume the confidentiality level of the most confidential action in the aggregation.
      ///</summary>
      private HL7Connect.Cda.CD propGetConfidentialityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().confidentialityCode);
      }
      private void propSetConfidentialityCode(HL7Connect.Cda.CD value)
      {
        wrapped().confidentialityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that controls the disclosure of information about this Act, regardless of mood.                                                      Discussion: It is important to note that the necessary confidentiality of the medical record cannot be achieved solely through confidentiality codes to mask individual record items from certain types of users. There are two important problems with per-item confidentiality: one is inference and the other is the danger of holding back information that may be critical in a certain care situation. Inference means that filtered sensitive information can still be assumed given the other information that was not filtered. The simplest form of inference is that even the existence of a test order for an HIV Western Blot test or a T4/T8 lymphocyte count is a strong indication for an existing HIV infection, even if the results are not known. Very often, diagnoses can be inferred from medication, such as Zidovudin for treatment of HIV infections. The problem of hiding individual items becomes especially difficult with current medications, since the continuing administration of the medication must be assured.                        To mitigate some of the inference-risk, aggregations of data should assume the confidentiality level of the most confidential action in the aggregation.
      ///</summary>
      public HL7Connect.Cda.CD confidentialityCode { get { return propGetConfidentialityCode(); } set { propSetConfidentialityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      private HL7Connect.Cda.CS propGetLanguageCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().languageCode);
      }
      private void propSetLanguageCode(HL7Connect.Cda.CS value)
      {
        wrapped().languageCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The primary language in which this Act statement is specified, particularly the language of the Act.text.
      ///</summary>
      public HL7Connect.Cda.CS languageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// The StructuredBody class is associated with one or more Section classes through a component relationship
      ///</summary>
      private HL7Connect.Cda.Component3List propGetComponent()
      {
        return HL7Connect.Cda.WrapperFactory.Component3List(wrapped().Component);
      }
      private void propSetComponent(HL7Connect.Cda.Component3List value)
      {
        wrapped().Component = value.wrapped();
      }
      ///<summary>
      /// The StructuredBody class is associated with one or more Section classes through a component relationship
      ///</summary>
      public HL7Connect.Cda.Component3List component { get { return propGetComponent(); } set { propSetComponent(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the major type of Act that this Act-instance represents.                                                      Constraints: The classCode domain is a tightly controlled vocabulary, not an external or user-defined vocabulary.                         Every Act-instance must have a classCode. If the act class is not further specified, the most general Act.classCode (ACT) is used.                        The Act.classCode must be a generalization of the specific Act concept (e.g., as expressed in Act.code), in other words, the Act concepts conveyed in an Act must be specializations of the Act.classCode. Especially, the classCode is not a "modifier" or the Act.code that can alter the meaning of a class code. (See Act.code for contrast.)
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code distinguishing whether an Act is conceived of as a factual statement or in some other manner as a command, possibility, goal, etc.                                                      Constraints: An Act-instance must have one and only one moodCode value.                        The moodCode of a single Act-instance never changes. Mood is not state.                        To describe the progression of a business activity from defined to planned to executed, etc. one must instantiate different Act-instances in the different moods and link them using ActRelationship of general type "sequel". (See ActRelationship.typeCode.)                                                      Discussion: The Act.moodCode includes the following notions: (1) event, i.e., factual description of an actions that occurred; (2) definition of possible actions and action plans (the master file layer); (3) intent, i.e., an action plan instantiated for a patient as a care plan or order; (4) goal, i.e., an desired outcome attached to patient problems and plans; and (5) criterion, i.e., a predicate used to evaluate a logical expression.                        The Act.moodCode modifies the meaning of the Act class in a controlled way, just as in natural language, grammatical form of a verb modify the meaning of a sentence in defined ways. For example, if the mood is factual (event), then the entire act object represents a known fact. If the mood expresses a plan (intent), the entire act object represents the expectation of what should be done. The mood does not change the meaning of individual act properties in peculiar ways.                        Since the mood code is a determining factor for the meaning of an entire Act object, the mood must always be known. This means, whenever an act object is instantiated, the mood attribute must be assigned to a valid code, and the mood assignment cannot change throughout the lifetime of an act object.                        As the meaning of an act object is factored in the mood code, the mood code affects the interpretation of the entire Act object and with it every property (attributes and associations). Note that the mood code affects the interpretation of the act object, and the meaning of the act object in turn determines the meaning of the attributes. However, the mood code does not arbitrarily change the meaning of individual attributes.                                                      Inert vs. descriptive properties of Acts: Acts have two kinds of act properties, inert and descriptive properties. Inert properties are not affected by the mood, descriptive properties follow the mood of the object. For example, there is an identifier attribute Act.id, which gives a unique identification to an act object. Being a unique identifier for the object is in no way dependent on the mood of the act object. Therefore, the "interpretation" of the Act.id attribute is inert with respect to the act object's mood.                        By contrast, most of the Act class' attributes are descriptive for what the Act statement expresses. Descriptive properties of the Act class give answer to the questions who, whom, where, with what, how and when the action is done. The questions who, whom, with what, and where are answered by Participations, while how and when are answered by descriptive attributes and ActRelationships. The interpretation of a descriptive attribute is aligned to the interpretation of the entire act object, and controlled by the mood.                                                       Examples: To illustrate the effect of mood code, consider a "blood glucose" observation:                        The DEFINITION mood specifies the Act of "obtaining blood glucose". Participations describe in general the characteristics of the people who must be involved in the act, and the required objects, e.g., specimen, facility, equipment, etc. involved. The Observation.value specifies the absolute domain (range) of the observation (e.g., 15-500 mg/dl).                        In INTENT mood the author of the intent expresses the intent that he or someone else "should obtain blood glucose". The participations are the people actually or supposedly involved in the intended act, especially the author of the intent or any individual assignments for group intents, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the intent is to measure blood glucose, not to measure blood glucose in a specific range. (But compare with GOAL below).                        In REQUEST mood, a kind of intent, the author requests to "please obtain blood glucose". The Participations are the people actually and supposedly involved in the act, especially the placer and the designated filler, and the objects actually or supposedly involved in the act (e.g., specimen sent, equipment requirements, etc.). The Observation.value is usually not specified, since the order is not to measure blood glucose in a specific range.                        In EVENT mood, the author states that "blood glucose was obtained". Participations are the people actually involved in the act, and the objects actually involved (e.g., specimen, facilities, equipment). The Observation.value is the value actually obtained (e.g., 80 mg/dL, or &lt;15 mg/dL).                        In event-CRITERION mood, an author considers a certain class of "obtaining blood glucose" possibly with a certain value (range) as outcome. The Participations constrain the criterion, for instance, to a particular patient. The Observation.value is the range in which the criterion would hold (e.g. &gt; 180 mg/dL or 200-300 mg/dL).                        In GOAL mood (a kind of criterion), the author states that "our goal is to be able to obtain blood glucose with the given value (range)". The Participations are similar to intents, especially the author of the goal and the patient for whom the goal is made. The Observation.value is the range which defined when the goal is met (e.g. 80-120 mg/dl).                                                      Rationale: The notion of "mood" is borrowed from natural language grammar, the mood of a verb (lat. modus verbi).                         The notion of mood also resembles the various extensions of the logic of facts in modal logic and logic with modalities, where the moodCode specifies the modality (fact, possibility, intention, goal, etc.) under which the Act-statement is judged as appropriate or defective.
      ///</summary>
      public string moodCode { get { return propGetMoodCode(); } }

    }

    ///<summary>
    /// The subject participant represents the primary target of the entries recorded in the document. Most of the time the subject is the same as the recordTarget but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
    /// 
    /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
    ///</summary>
    public class Subject : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA Subject
      ///</summary>
      public Subject() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSubject()) {} 

      internal Subject(IcdaSubject com) : base(com) {} 

      internal new HCcdaSubject wrapped() { return (HCcdaSubject) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the extent to which the Entity playing the participating Role (usually as a target Participation) is aware of the associated Act.                                                      Examples: For diagnostic observations, is the patient, family member or other participant aware of the patient's terminal illness?                                                      Discussion: If the awareness, denial, unconsciousness, etc. is the subject of medical considerations (e.g., part of the problem list), one should use explicit observations in these matters as well, and should not solely rely on this simple attribute in the Participation.
      ///</summary>
      private HL7Connect.Cda.CD propGetAwarenessCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().awarenessCode);
      }
      private void propSetAwarenessCode(HL7Connect.Cda.CD value)
      {
        wrapped().awarenessCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the extent to which the Entity playing the participating Role (usually as a target Participation) is aware of the associated Act.                                                      Examples: For diagnostic observations, is the patient, family member or other participant aware of the patient's terminal illness?                                                      Discussion: If the awareness, denial, unconsciousness, etc. is the subject of medical considerations (e.g., part of the problem list), one should use explicit observations in these matters as well, and should not solely rely on this simple attribute in the Participation.
      ///</summary>
      public HL7Connect.Cda.CD awarenessCode { get { return propGetAwarenessCode(); } set { propSetAwarenessCode(value); } }

      ///<summary>
      /// represents the primary target of the entries recorded in the document or section
      ///</summary>
      private HL7Connect.Cda.RelatedSubject propGetRelatedSubject()
      {
        return HL7Connect.Cda.WrapperFactory.RelatedSubject(wrapped().relatedSubject);
      }
      private void propSetRelatedSubject(HL7Connect.Cda.RelatedSubject value)
      {
        wrapped().relatedSubject = value.wrapped();
      }
      ///<summary>
      /// represents the primary target of the entries recorded in the document or section
      ///</summary>
      public HL7Connect.Cda.RelatedSubject relatedSubject { get { return propGetRelatedSubject(); } set { propSetRelatedSubject(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      private string propGetTypeCode()
      {
        return wrapped().typeCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the kind of Participation or involvement the Entity playing the Role associated with the Participation has with regard to the associated Act.                                                      Constraints: The Participant.typeCode contains only categories that have crisp semantic relevance in the scope of HL7. It is a coded attribute without exceptions and no alternative coding systems allowed.
      ///</summary>
      public string typeCode { get { return propGetTypeCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      private string propGetContextControlCode()
      {
        return wrapped().contextControlCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code that specifies how this Participation contributes to the context of the current Act, and whether it may be propagated to descendent Acts whose association allows such propagation (see ActRelationship.contextConductionInd).                                                      Discussion:  Refer to ActRelationship.contextControlCode for rationale, discussion and examples.
      ///</summary>
      public string contextControlCode { get { return propGetContextControlCode(); } }

    }

    ///<summary>
    /// A person who is a subject
    ///</summary>
    public class SubjectPerson : HL7Connect.Cda.CDABase
    {

      ///<summary>
      /// Create a CDA SubjectPerson
      ///</summary>
      public SubjectPerson() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSubjectPerson()) {} 

      internal SubjectPerson(IcdaSubjectPerson com) : base(com) {} 

      internal new HCcdaSubjectPerson wrapped() { return (HCcdaSubjectPerson) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      private HL7Connect.Cda.ListEN propGetName()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().Name);
      }
      private void propSetName(HL7Connect.Cda.ListEN value)
      {
        wrapped().Name = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A non-unique textual identifier or moniker for the Entity.                                                      Examples: Proper names, nicknames, legal names of persons, places or things.                                                      Rationale: Most entities have a commonly used name that can be used to differentiate them from other Entities, but does not provide a unique identifier.
      ///</summary>
      public HL7Connect.Cda.ListEN name { get { return propGetName(); } set { propSetName(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the gender (sex) of a Living subject.                                                      Examples: female, male                                                       Discussion: This attribute does not include terms related to clinical gender. Gender is a complex physiological, genetic and sociological concept that requires multiple observations in order to be comprehensively described. The purpose of this attribute is to provide a high level classification that can additionally be used for the appropriate allocation of inpatient bed assignment.                                                      Constraints: This code is used for administrative purposes.                         ExtRef: This information is reported on UB FL 15.
      ///</summary>
      private HL7Connect.Cda.CD propGetAdministrativeGenderCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().administrativeGenderCode);
      }
      private void propSetAdministrativeGenderCode(HL7Connect.Cda.CD value)
      {
        wrapped().administrativeGenderCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A value representing the gender (sex) of a Living subject.                                                      Examples: female, male                                                       Discussion: This attribute does not include terms related to clinical gender. Gender is a complex physiological, genetic and sociological concept that requires multiple observations in order to be comprehensively described. The purpose of this attribute is to provide a high level classification that can additionally be used for the appropriate allocation of inpatient bed assignment.                                                      Constraints: This code is used for administrative purposes.                         ExtRef: This information is reported on UB FL 15.
      ///</summary>
      public HL7Connect.Cda.CD administrativeGenderCode { get { return propGetAdministrativeGenderCode(); } set { propSetAdministrativeGenderCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The date and time of a living subject's birth or hatching.
      ///</summary>
      private HL7Connect.Cda.TS propGetBirthTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().birthTime);
      }
      private void propSetBirthTime(HL7Connect.Cda.TS value)
      {
        wrapped().birthTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The date and time of a living subject's birth or hatching.
      ///</summary>
      public HL7Connect.Cda.TS birthTime { get { return propGetBirthTime(); } set { propSetBirthTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing the class or category that the Entity instance represents.                                                      Examples: Person, Animal, Chemical Substance, Group, Organization                                                      Rationale: Due to the extremely large number of potential values for a code set representing all physical things in the universe, the class code indicates both the subtype branch of the Entity hierarchy used as well as a high level classifier to represent the instance of Entity. This can be used to constrain the eligible value domains for the Entity.code attribute.
      ///</summary>
      public string classCode { get { return propGetClassCode(); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      private string propGetDeterminerCode()
      {
        return wrapped().determinerCode;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An HL7 defined value representing whether the Entity represents a kind-of or a specific instance.                                                      Examples: 1 human being (an instance), 3 syringes (quantified kind) or the population of Indianapolis (kind of group)                                                      Rationale: An Entity may at times represent information concerning a specific instance (the most common), a quantifiable group with common characteristics or a general type of Entity. This code distinguishes these different representations.
      ///</summary>
      public string determinerCode { get { return propGetDeterminerCode(); } }

    }

    ///<summary>
    /// A derivative of the RIM SubstanceAdministration class, used for representing medication-related events such as medication history or planned medication administration orders.
    ///</summary>
    public class SubstanceAdministration : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA SubstanceAdministration
      ///</summary>
      public SubstanceAdministration() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSubstanceAdministration()) {} 

      internal SubstanceAdministration(IcdaSubstanceAdministration com) : base(com) {} 

      internal new HCcdaSubstanceAdministration wrapped() { return (HCcdaSubstanceAdministration) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// is used to describe the timing of administration. It is modeled using the GTS data type to accommodate various dosing scenarios
      ///</summary>
      private HL7Connect.Cda.QSET<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.QSET<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// is used to describe the timing of administration. It is modeled using the GTS data type to accommodate various dosing scenarios
      ///</summary>
      public HL7Connect.Cda.QSET<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// categorizes the priority of a substance administration
      ///</summary>
      private HL7Connect.Cda.CD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.CD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// categorizes the priority of a substance administration
      ///</summary>
      public HL7Connect.Cda.CD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of integer numbers stating the minimal and maximal number of repetitions of the Act.                                                      Examples: An oral surgeon's advice to a patient after tooth extraction might be: "replace the gauze every hour for 1 to 3 times until bleeding has stopped completely." This translates to repeatNumber with low boundary 1 and high boundary 3.                                                      Discussion: This attribute is a member of the workflow control suite of attributes.                         The number of repeats is additionally constrained by time. The act will repeat at least the minimal number of times and at most, the maximal number of times. Repetitions will also terminate when the time exceeds the maximal Act.effectiveTime, whichever comes first.                                                      Usage: On an Act in Event mood, the repeatNumber is usally 1. If greater than 1, the Act is representing a summary of several event occurrences occurring over the time interval described by effectiveTime                        To distinguish occurrences of acts within a sequence of repetitions, use ActRelationship.sequenceNumber
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.INT> propGetRepeatNumber()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.INT>(wrapped().repeatNumber);
      }
      private void propSetRepeatNumber(HL7Connect.Cda.IVL<HL7Connect.Cda.INT> value)
      {
        wrapped().repeatNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of integer numbers stating the minimal and maximal number of repetitions of the Act.                                                      Examples: An oral surgeon's advice to a patient after tooth extraction might be: "replace the gauze every hour for 1 to 3 times until bleeding has stopped completely." This translates to repeatNumber with low boundary 1 and high boundary 3.                                                      Discussion: This attribute is a member of the workflow control suite of attributes.                         The number of repeats is additionally constrained by time. The act will repeat at least the minimal number of times and at most, the maximal number of times. Repetitions will also terminate when the time exceeds the maximal Act.effectiveTime, whichever comes first.                                                      Usage: On an Act in Event mood, the repeatNumber is usally 1. If greater than 1, the Act is representing a summary of several event occurrences occurring over the time interval described by effectiveTime                        To distinguish occurrences of acts within a sequence of repetitions, use ActRelationship.sequenceNumber
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.INT> repeatNumber { get { return propGetRepeatNumber(); } set { propSetRepeatNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The the physiological path or route for introducing the therapeutic material into or onto the subject.                                                      Discussion: If the route requires further specification, both the site of administration (administrationSiteCode) and the method of adminitration (methodCode) may be used. For example, if the routeCode is intravenous or intra-muscular, it may be necessary to specify the precise site, with approachSiteCode, (e.g., right forearm or left deltoid muscle respectively) and the precise method of administration, with methodCode, (e.g., "slow bolus injection" or "Z-track injection" respectively).                        Route, site of administration (administrationSiteCode), method of adminitration (methodCode) and the device used in administration are closely related. All four (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.                        When the medication is delivered to an environmental site, or a location, the route code indicates a site on its "body".                                                      Examples: per os (PO), sublingual (SL), rectal (PR), per inhalationem (IH), ophtalmic (OP), nasal (NS), otic (OT), vaginal (VG), intra-dermal (ID), subcutaneous (SC), intra-venous (IV), and intra-cardial (IC)
      ///</summary>
      private HL7Connect.Cda.CD propGetRouteCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().routeCode);
      }
      private void propSetRouteCode(HL7Connect.Cda.CD value)
      {
        wrapped().routeCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The the physiological path or route for introducing the therapeutic material into or onto the subject.                                                      Discussion: If the route requires further specification, both the site of administration (administrationSiteCode) and the method of adminitration (methodCode) may be used. For example, if the routeCode is intravenous or intra-muscular, it may be necessary to specify the precise site, with approachSiteCode, (e.g., right forearm or left deltoid muscle respectively) and the precise method of administration, with methodCode, (e.g., "slow bolus injection" or "Z-track injection" respectively).                        Route, site of administration (administrationSiteCode), method of adminitration (methodCode) and the device used in administration are closely related. All four (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.                        When the medication is delivered to an environmental site, or a location, the route code indicates a site on its "body".                                                      Examples: per os (PO), sublingual (SL), rectal (PR), per inhalationem (IH), ophtalmic (OP), nasal (NS), otic (OT), vaginal (VG), intra-dermal (ID), subcutaneous (SC), intra-venous (IV), and intra-cardial (IC)
      ///</summary>
      public HL7Connect.Cda.CD routeCode { get { return propGetRouteCode(); } set { propSetRouteCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The anatomical site or system through which the procedure reaches its target (see targetSiteCode).                                                      Examples:                                                   Nephrectomy can have a trans-abdominal or a primarily retroperitoneal approach                        An arteria pulmonalis catheter targets a pulmonary artery but the approach site is typically the vena carotis interna or the vena subclavia, at the neck or the fossa subclavia respectively.                        For Substance Administration, it is the detailed anatomical site where the medication enters or is applied to the subject.                        For non-invasive procedures, e.g., acupuncture, the approach site is the punctured area of the skin.                                                      Discussion: If the subject of the Act is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses.                        Some approach sites can also be "pre-coordinated" in the Act definition, so that there is never an option to select different body sites. The same information structure can handle both the pre-coordinated and the post-coordinated approach.                        In Substance Administration, the route (routeCode), site of administration (approachSiteCode), the method of administration (methodCode) and the device used in administration are closely related. All four (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetApproachSiteCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().approachSiteCode);
      }
      private void propSetApproachSiteCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().approachSiteCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The anatomical site or system through which the procedure reaches its target (see targetSiteCode).                                                      Examples:                                                   Nephrectomy can have a trans-abdominal or a primarily retroperitoneal approach                        An arteria pulmonalis catheter targets a pulmonary artery but the approach site is typically the vena carotis interna or the vena subclavia, at the neck or the fossa subclavia respectively.                        For Substance Administration, it is the detailed anatomical site where the medication enters or is applied to the subject.                        For non-invasive procedures, e.g., acupuncture, the approach site is the punctured area of the skin.                                                      Discussion: If the subject of the Act is something other than a human patient or animal, the attribute is used analogously to specify a structural landmark of the thing where the act focuses.                        Some approach sites can also be "pre-coordinated" in the Act definition, so that there is never an option to select different body sites. The same information structure can handle both the pre-coordinated and the post-coordinated approach.                        In Substance Administration, the route (routeCode), site of administration (approachSiteCode), the method of administration (methodCode) and the device used in administration are closely related. All four (if present) must be closely coordinated and in agreement. In some cases, the coding system used to specify one may pre-coordinate one or more of the others.
      ///</summary>
      public HL7Connect.Cda.ListCD approachSiteCode { get { return propGetApproachSiteCode(); } set { propSetApproachSiteCode(value); } }

      ///<summary>
      /// indicates how much medication is given per dose
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> propGetDoseQuantity()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.PQ>(wrapped().doseQuantity);
      }
      private void propSetDoseQuantity(HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> value)
      {
        wrapped().doseQuantity = value.wrapped();
      }
      ///<summary>
      /// indicates how much medication is given per dose
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> doseQuantity { get { return propGetDoseQuantity(); } set { propSetDoseQuantity(value); } }

      ///<summary>
      /// can be used to indicate the rate at which the dose is to be administered (e.g., the flow rate for intravenous infusions)
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> propGetRateQuantity()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.PQ>(wrapped().rateQuantity);
      }
      private void propSetRateQuantity(HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> value)
      {
        wrapped().rateQuantity = value.wrapped();
      }
      ///<summary>
      /// can be used to indicate the rate at which the dose is to be administered (e.g., the flow rate for intravenous infusions)
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> rateQuantity { get { return propGetRateQuantity(); } set { propSetRateQuantity(value); } }

      ///<summary>
      /// is used to capture the maximum dose of the medication that can be given over a stated time interval (e.g., maximum daily dose of morphine, maximum lifetime dose of doxorubicin)
      ///</summary>
      private HL7Connect.Cda.RTO propGetMaxDoseQuantity()
      {
        return HL7Connect.Cda.WrapperFactory.RTO(wrapped().maxDoseQuantity);
      }
      private void propSetMaxDoseQuantity(HL7Connect.Cda.RTO value)
      {
        wrapped().maxDoseQuantity = value.wrapped();
      }
      ///<summary>
      /// is used to capture the maximum dose of the medication that can be given over a stated time interval (e.g., maximum daily dose of morphine, maximum lifetime dose of doxorubicin)
      ///</summary>
      public HL7Connect.Cda.RTO maxDoseQuantity { get { return propGetMaxDoseQuantity(); } set { propSetMaxDoseQuantity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code for the administered thing taken from a larger whole. Used if the consumable material is specified as a larger whole but the doseQuantity relates to a specific portion of it rather than the entire consumable material.                                                      Example: The ordering system only has a code for "Budesonide Metered Dose Inhaler" but the dose is to be measured in "number of actuations".                                                      Rationale: In the given example, without an administrationUnitCode the doseQty = 1 would mean that the entire inhaler bottle is to be emptied upon a single administration event. The administrationUnitCode signifying "actuation" (or "puff") specifies that the doseQty relates to this fraction of the medication rather than to the whole.                                                      *Constraints:*                                                   (1) This attribute should be used if and only if the material specified as the player of the Role attaching to the consumable participation is not in itself the finished dose form to be administered but a larger whole, pack, etc.                        (2) IF the material so specified is the proper administered dose form, such as a tablet, capsule, etc. THEN this attribute should be valued NULL (not applicable).                        (3) IF the material so specified is an amorphous substance (liquid, gas, powder, etc.) to be measured as a volume, mass, etc., THEN this attribute should remain NULL (not applicable).                        (4) IF the material so specified is a container, and the content is to be measured as a volume, mass, etc., THEN this attribute should be specified as "measured portion".
      ///</summary>
      private HL7Connect.Cda.CD propGetAdministrationUnitCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().administrationUnitCode);
      }
      private void propSetAdministrationUnitCode(HL7Connect.Cda.CD value)
      {
        wrapped().administrationUnitCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code for the administered thing taken from a larger whole. Used if the consumable material is specified as a larger whole but the doseQuantity relates to a specific portion of it rather than the entire consumable material.                                                      Example: The ordering system only has a code for "Budesonide Metered Dose Inhaler" but the dose is to be measured in "number of actuations".                                                      Rationale: In the given example, without an administrationUnitCode the doseQty = 1 would mean that the entire inhaler bottle is to be emptied upon a single administration event. The administrationUnitCode signifying "actuation" (or "puff") specifies that the doseQty relates to this fraction of the medication rather than to the whole.                                                      *Constraints:*                                                   (1) This attribute should be used if and only if the material specified as the player of the Role attaching to the consumable participation is not in itself the finished dose form to be administered but a larger whole, pack, etc.                        (2) IF the material so specified is the proper administered dose form, such as a tablet, capsule, etc. THEN this attribute should be valued NULL (not applicable).                        (3) IF the material so specified is an amorphous substance (liquid, gas, powder, etc.) to be measured as a volume, mass, etc., THEN this attribute should remain NULL (not applicable).                        (4) IF the material so specified is a container, and the content is to be measured as a volume, mass, etc., THEN this attribute should be specified as "measured portion".
      ///</summary>
      public HL7Connect.Cda.CD administrationUnitCode { get { return propGetAdministrationUnitCode(); } set { propSetAdministrationUnitCode(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// used to bring in the LabeledDrug or Material entity that describes the administered substance
      ///</summary>
      private HL7Connect.Cda.Consumable propGetConsumable()
      {
        return HL7Connect.Cda.WrapperFactory.Consumable(wrapped().consumable);
      }
      private void propSetConsumable(HL7Connect.Cda.Consumable value)
      {
        wrapped().consumable = value.wrapped();
      }
      ///<summary>
      /// used to bring in the LabeledDrug or Material entity that describes the administered substance
      ///</summary>
      public HL7Connect.Cda.Consumable consumable { get { return propGetConsumable(); } set { propSetConsumable(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator specifying that the Act statement is a negation of the Act as described by the descriptive attributes.                                                      Examples: Used with an Observation event, it allows one to say "patient has NO chest pain". With an Observation criterion it negates the criterion analogously, e.g., "if patient has NO chest pain for 3 days ...", or "if systolic blood pressure is *not* within 90-100 mm Hg ..."                                                      Discussion: The negationInd works as a negative existence quantifier. This is best explained on Acts in criterion mood, and then translates into all other moods. In criterion mood without negation, one usually only specifies a few critical attributes and relationships (features) of an Act, i.e., only those that are needed to test the criterion. The more features one specifies, the more constrained (specific) is the criterion. For example, to test for "systolic blood pressure of 90-100 mm Hg", one would use only the descriptive attributes Act.code (for systolic blood pressure) and Observation.value (for 90-100 mm Hg). If one would also specify an effectiveTime, i.e., for "yesterday", the criterion would be more constrained. If the negationInd is true for the above criterion, then the meaning of the test is whether a systolic blood pressure of 90-100 mm Hg yesterday does *not exist* (independent of whether any blood pressure was measured).                        The negationInd negates the Act as described by the descriptive properties (including Act.code, Act.effectiveTime, Observation.value, Act.doseQty, etc.) and any of its components. The inert properties such as Act.id, Act.moodCode, Act.confidentialityCode, and particularly the Author-Participation are *not* negated. These inert properties always have the same meaning: i.e., the author remains to be the author of the negative observation. Also, most ActRelationships (except for components) are not included in the negation.                         For example, a highly confidential order written by Dr. Jones, to explicitly *not* give "succinyl choline" for the "reason" (ActRelationship) of a history of malignant hyperthermia (Observation) negates the descriptive properties "give succinyl choline" (Act.code), but it is still positively an order and written by Dr. Jones and for patient John Smith, and the reason for this order is the patient's history of malignant hyperthermia.                         However, additional detail in descriptive attributes will be part of the negation which then limits the effectiveness of the negated statement. For example, had the order not to give a substance included a doseQuantity, it would mean that the substance should not be given at that particular dose (but any other dose might still be O.K.).                        An act statement with negationInd is still a statement about the specific fact described by the Act. For instance, a negated "finding of wheezing on July 1" means that the author positively denies that there was wheezing on July 1, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation. Conversely, negation indicator does *not* just negate that the fact was affirmed or that the statement had been made. This holds for all moods in the same way, e.g., a negated order is an order *not* to do the described act, not just the lapidary statement that there is no such order.
      ///</summary>
      private bool propGetNegationInd()
      {
        return wrapped().negationInd != 0;
      }
      private void propSetNegationInd(bool value)
      {
        wrapped().negationInd = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator specifying that the Act statement is a negation of the Act as described by the descriptive attributes.                                                      Examples: Used with an Observation event, it allows one to say "patient has NO chest pain". With an Observation criterion it negates the criterion analogously, e.g., "if patient has NO chest pain for 3 days ...", or "if systolic blood pressure is *not* within 90-100 mm Hg ..."                                                      Discussion: The negationInd works as a negative existence quantifier. This is best explained on Acts in criterion mood, and then translates into all other moods. In criterion mood without negation, one usually only specifies a few critical attributes and relationships (features) of an Act, i.e., only those that are needed to test the criterion. The more features one specifies, the more constrained (specific) is the criterion. For example, to test for "systolic blood pressure of 90-100 mm Hg", one would use only the descriptive attributes Act.code (for systolic blood pressure) and Observation.value (for 90-100 mm Hg). If one would also specify an effectiveTime, i.e., for "yesterday", the criterion would be more constrained. If the negationInd is true for the above criterion, then the meaning of the test is whether a systolic blood pressure of 90-100 mm Hg yesterday does *not exist* (independent of whether any blood pressure was measured).                        The negationInd negates the Act as described by the descriptive properties (including Act.code, Act.effectiveTime, Observation.value, Act.doseQty, etc.) and any of its components. The inert properties such as Act.id, Act.moodCode, Act.confidentialityCode, and particularly the Author-Participation are *not* negated. These inert properties always have the same meaning: i.e., the author remains to be the author of the negative observation. Also, most ActRelationships (except for components) are not included in the negation.                         For example, a highly confidential order written by Dr. Jones, to explicitly *not* give "succinyl choline" for the "reason" (ActRelationship) of a history of malignant hyperthermia (Observation) negates the descriptive properties "give succinyl choline" (Act.code), but it is still positively an order and written by Dr. Jones and for patient John Smith, and the reason for this order is the patient's history of malignant hyperthermia.                         However, additional detail in descriptive attributes will be part of the negation which then limits the effectiveness of the negated statement. For example, had the order not to give a substance included a doseQuantity, it would mean that the substance should not be given at that particular dose (but any other dose might still be O.K.).                        An act statement with negationInd is still a statement about the specific fact described by the Act. For instance, a negated "finding of wheezing on July 1" means that the author positively denies that there was wheezing on July 1, and that he takes the same responsibility for such statement and the same requirement to have evidence for such statement than if he had not used negation. Conversely, negation indicator does *not* just negate that the fact was affirmed or that the statement had been made. This holds for all moods in the same way, e.g., a negated order is an order *not* to do the described act, not just the lapidary statement that there is no such order.
      ///</summary>
      public bool negationInd { get { return propGetNegationInd(); } set { propSetNegationInd(value); } }

      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      private bool propGetHasNegationInd()
      {
        return wrapped().HasNegationInd != 0;
      }
      ///<summary>
      /// false if negationInd is null, true if negationInd is either true or false
      ///</summary>
      public bool HasNegationInd { get { return propGetHasNegationInd(); } }

    }

    ///<summary>
    /// A derivative of the RIM Supply class, used for representing the provision of a material by one entity to another. 
    /// 
    /// The Supply class represents dispensing, whereas the SubstanceAdministration class represents administration. Prescriptions are complex activities that involve both an administration request to the patient (e.g. take digoxin 0.125mg by mouth once per day) and a supply request to the pharmacy (e.g. dispense 30 tablets, with 5 refills). This should be represented in CDA by a SubstanceAdministration entry that has a component Supply entry. The nested Supply entry can have Supply.independentInd set to "false" to signal that the Supply cannot stand alone, without it's containing SubstanceAdministration.
    ///</summary>
    public class Supply : HL7Connect.Cda.ClinicalStatement
    {

      ///<summary>
      /// Create a CDA Supply
      ///</summary>
      public Supply() : base(Cda.WrapperFactory.WorkingFactory.wrapped().newSupply()) {} 

      internal Supply(IcdaSupply com) : base(com) {} 

      internal new HCcdaSupply wrapped() { return (HCcdaSupply) com; }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the particular kind of Act that the Act-instance represents within its class.                                                      Constraints: The kind of Act (e.g. physical examination, serum potassium, inpatient encounter, charge financial transaction, etc.) is specified with a code from one of several, typically external, coding systems. The coding system will depend on the class of Act, such as LOINC for observations, etc.                        Conceptually, the Act.code must be a specialization of the Act.classCode. This is why the structure of ActClass domain should be reflected in the superstructure of the ActCode domain and then individual codes or externally referenced vocabularies subordinated under these domains that reflect the ActClass structure.                        Act.classCode and Act.code are not modifiers of each other but the Act.code concept should really imply the Act.classCode concept. For a negative example, it is not appropriate to use an Act.code "potassium" together with and Act.classCode for "laboratory observation" to somehow mean "potassium laboratory observation" and then use the same Act.code for "potassium" together with Act.classCode for "medication" to mean "substitution of potassium". This mutually modifying use of Act.code and Act.classCode is not permitted.                                                      Discussion: Act.code is not a required attribute of Act. Rather than naming the kind of Act using an Act.code, one can specify the Act using only the class code and other attributes and properties of the Act. In general and more commonly, the kind of Act is readily specified by an ActRelationship specifying that this Act instantiates another Act in definition mood. Or, even without reference to an act definition, the act may be readily described by other attributes, ActRelationships and Participations. For example, the kind of SubstanceAdministration may be readily described by referring to the specific drug, as the Participation of an Entity representing that drug.
      ///</summary>
      public HL7Connect.Cda.CD code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      private HL7Connect.Cda.ED propGetText()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().Text);
      }
      private void propSetText(HL7Connect.Cda.ED value)
      {
        wrapped().Text = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A renderable textual or multimedia description (or reference to a description) of the complete information which would reasonably be expected to be displayed to a human reader conveyed by the Act.                                                      Examples: For act definitions, the Act.text can contain textbook-like information about that act. For act orders, the description will contain particular instructions pertaining only to that order.                         The content of the description is not considered part of the functional information communicated between computer systems. For Acts that involve human readers and performers, however, computer systems must show the Act.text field to a human user, who has responsibility for the activity; or at least must indicate the existence of the Act.text information and allow the user to see that information.                        Free text descriptions are used to help an individual interpret the content and context of the act, but all information relevant for automated functions must be communicated using the proper attributes and associated objects.                                                      Usage: The intent is that a user can read Act.text alone without seeing any of the encoded information and have no risk of misinterpreting or lacking full understanding of the full content of the Act. For example, II.root, or CD.codeSystem would not normally be displayed to a human and thus would not need to be exposed as part of Act.text.                        The rendering is expected to include all 'descendant' ActRelationships and Participations recursively navigating child Acts as exposed in that particular 'snapshot'. However, there are several data elements which are NOT expected to be included in the rendering. These are:                        Act.text can include information that is not in the other attributes/associations, but must include all information which is in such attributes or associations (with the exception of those identified above).                        Act.text SHOULD NOT be used for the sharing of computable information. Computable information must be conveyed using discrete attributes. Any information which Act.text contains not elsewhere exposed in encoded information will be opaque to computer systems. For this reason, Act.text should not be used to contain information which negates or significantly modifies the understanding of information encoded in discrete attributes.                        To communicate "supplemental text", an act relationship (e.g. "component" or "subject of") should be created to a separate Act with a bare Act.text attribute should be used to convey the supplemental information, possibly with a code indicating "annotation" or some similar concept.
      ///</summary>
      public HL7Connect.Cda.ED text { get { return propGetText(); } set { propSetText(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code specifying the state of the Act.                                                      *Guidance: *The status reflects the state of the activity. In the case of an Observation, this is the status of the activity of observing, not the status of what is being observed (e.g. disease status, "Active" allergy to penicillin). To convey the status of the subject being observed, consider coordinating it into the code or value attribute of the Observation or using a related Observation.                                                      *Design Advisory: *This attribute was defined in the original RIM as repeating, owing to the presence of nested states in the state machines. In actual practice, however, there is never a need to communicate more than a single status value. therefore, committees are advised to *constrain this attribute to a maximum cardinality of 1* in all message designs.
      ///</summary>
      public HL7Connect.Cda.CS statusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      private HL7Connect.Cda.QSET<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.QSET<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A time expression specifying the focal or operative time of the Act, the primary time for which the Act holds, the time of interest from the perspective of the Act's intention.                                                      Examples: For clinical Observations, the effectiveTime is the time at which the observation holds (is effective) for the patient.                        For contracts, the effectiveTime is the time for which the contract is in effect.                        For consents, the effectiveTime is the time for which the consent is valid.                        For substance administrations, the effective time is the time over which the substance is to be administered, including the frequency of administration (e.g. TID for 10 days)                        For a surgical procedure (operation), the effectiveTime is the time relevant for the patient, i.e., between incision and last suture.                         For transportation acts, the effective time is the time the transported payload is en route.                        For patient encounters, this is the "administrative" time, i.e., the encounter start and end date required to be chosen by business rules, as opposed to the actual time the healthcare encounter related work is performed.                                                      Discussion: The effectiveTime is also known as the "primary" time (Arden Syntax) or the "biologically relevant time" (HL7 v2.x). This attribute is distinguished from activityTime.                        For observations, the time of the observation activity may be much later than the time of the observed feature. For instance, in a Blood Gas Analysis (BGA), a result will always come up several minutes after the specimen was taken, meanwhile the patient's physiological state may have changed significantly.                         For essentially physical activities (surgical procedures, transportations, etc.), the effective time is the time of interest for the Act's intention, i.e., since the intention of a transportation is to deliver a payload from location A to B, the effectiveTime is the time this payload is underway from A to B. However, the Act usually also includes accidental work which is necessary to perform the intention of the Act, but is not relevant for the Act's purpose.                         For example, the time a driver needs to go to the pick-up location A and then return from drop-off location B to some home base, is included in the physical activity, but does not matter from the perspective of the payload's transportation. Another example is: a person's work hours (effectiveTime) may be from 8 AM to 5 PM, no matter whether that person needs 10 minutes for the commute or 2 hours. The commute is necessary to be at work, but it is not essential for the work hours.
      ///</summary>
      public HL7Connect.Cda.QSET<HL7Connect.Cda.TS> effectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetPriorityCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().priorityCode);
      }
      private void propSetPriorityCode(HL7Connect.Cda.ListCD value)
      {
        wrapped().priorityCode = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// A code or set of codes (e.g., for routine, emergency), specifying the urgency under which the Act happened, can happen, is happening, is intended to happen, or is requested/demanded to happen.                                                       Discussion: This attribute is used in orders to indicate the ordered priority, and in event documentation it indicates the actual priority used to perform the act. In definition mood it indicates the available priorities.
      ///</summary>
      public HL7Connect.Cda.ListCD priorityCode { get { return propGetPriorityCode(); } set { propSetPriorityCode(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of integer numbers stating the minimal and maximal number of repetitions of the Act.                                                      Examples: An oral surgeon's advice to a patient after tooth extraction might be: "replace the gauze every hour for 1 to 3 times until bleeding has stopped completely." This translates to repeatNumber with low boundary 1 and high boundary 3.                                                      Discussion: This attribute is a member of the workflow control suite of attributes.                         The number of repeats is additionally constrained by time. The act will repeat at least the minimal number of times and at most, the maximal number of times. Repetitions will also terminate when the time exceeds the maximal Act.effectiveTime, whichever comes first.                                                      Usage: On an Act in Event mood, the repeatNumber is usally 1. If greater than 1, the Act is representing a summary of several event occurrences occurring over the time interval described by effectiveTime                        To distinguish occurrences of acts within a sequence of repetitions, use ActRelationship.sequenceNumber
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.INT> propGetRepeatNumber()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.INT>(wrapped().repeatNumber);
      }
      private void propSetRepeatNumber(HL7Connect.Cda.IVL<HL7Connect.Cda.INT> value)
      {
        wrapped().repeatNumber = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An interval of integer numbers stating the minimal and maximal number of repetitions of the Act.                                                      Examples: An oral surgeon's advice to a patient after tooth extraction might be: "replace the gauze every hour for 1 to 3 times until bleeding has stopped completely." This translates to repeatNumber with low boundary 1 and high boundary 3.                                                      Discussion: This attribute is a member of the workflow control suite of attributes.                         The number of repeats is additionally constrained by time. The act will repeat at least the minimal number of times and at most, the maximal number of times. Repetitions will also terminate when the time exceeds the maximal Act.effectiveTime, whichever comes first.                                                      Usage: On an Act in Event mood, the repeatNumber is usally 1. If greater than 1, the Act is representing a summary of several event occurrences occurring over the time interval described by effectiveTime                        To distinguish occurrences of acts within a sequence of repetitions, use ActRelationship.sequenceNumber
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.INT> repeatNumber { get { return propGetRepeatNumber(); } set { propSetRepeatNumber(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator specifying whether the Act can be manipulated independently of other Acts or whether manipulation of the Act can only be through a super-ordinate composite Act that has this Act as a component. By default the independentInd should be true.                                                      Examples: An Act definition is sometimes marked with independentInd=false if the business rules would not allow this act to be ordered without ordering the containing act group.                        An order may have a component that cannot be aborted independently of the other components.
      ///</summary>
      private HL7Connect.Cda.BL propGetIndependentInd()
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().independentInd);
      }
      private void propSetIndependentInd(HL7Connect.Cda.BL value)
      {
        wrapped().independentInd = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// An indicator specifying whether the Act can be manipulated independently of other Acts or whether manipulation of the Act can only be through a super-ordinate composite Act that has this Act as a component. By default the independentInd should be true.                                                      Examples: An Act definition is sometimes marked with independentInd=false if the business rules would not allow this act to be ordered without ordering the containing act group.                        An order may have a component that cannot be aborted independently of the other components.
      ///</summary>
      public HL7Connect.Cda.BL independentInd { get { return propGetIndependentInd(); } set { propSetIndependentInd(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The amount that was or is to be supplied (depending on the moodCode)                                                      Discussion: This attribute may be used as an alternative to expectedUseTime or both may be used. If both are specified, then the specified quantity is the amount expected to be consumed within the expectedUseTime.                        The unit of measure is restricted to a measured unit such as milliliter and milligram. Non-measured, but countable units such as tablet and capsule must not be specified using the unit component of the PQ data type, except as an annotation, marked by {xxx}. Refer to Data Types Part II Unabridged Specification, Appendix A: Unified Code for Units of Measure. The type of 'countable' information is determined by information in the 'product' entity.
      ///</summary>
      private HL7Connect.Cda.PQ propGetQuantity()
      {
        return HL7Connect.Cda.WrapperFactory.PQ(wrapped().quantity);
      }
      private void propSetQuantity(HL7Connect.Cda.PQ value)
      {
        wrapped().quantity = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// The amount that was or is to be supplied (depending on the moodCode)                                                      Discussion: This attribute may be used as an alternative to expectedUseTime or both may be used. If both are specified, then the specified quantity is the amount expected to be consumed within the expectedUseTime.                        The unit of measure is restricted to a measured unit such as milliliter and milligram. Non-measured, but countable units such as tablet and capsule must not be specified using the unit component of the PQ data type, except as an annotation, marked by {xxx}. Refer to Data Types Part II Unabridged Specification, Appendix A: Unified Code for Units of Measure. The type of 'countable' information is determined by information in the 'product' entity.
      ///</summary>
      public HL7Connect.Cda.PQ quantity { get { return propGetQuantity(); } set { propSetQuantity(value); } }

      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Identifies the period time over which the supplied product is expected to be used, or the length of time the supply is expected to last.                        In some situations, this attribute may be used instead of Supply.quantity to identify the amount supplied by how long it is expected to last, rather than the physical quantity issued. E.g. 90 days supply of medication (based on an ordered dosage), 10 hours of jet fuel, etc. NOTE: When possible, it is always better to specify Supply.quantity, as this tends to be more precise. Supply.expectedUseTime will always be an estimate that can be influenced by external factors.
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetExpectedUseTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().expectedUseTime);
      }
      private void propSetExpectedUseTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().expectedUseTime = value.wrapped();
      }
      ///<summary>
      /// l version="1.0" encoding="UTF-8"?>                         
      /// 
      /// Identifies the period time over which the supplied product is expected to be used, or the length of time the supply is expected to last.                        In some situations, this attribute may be used instead of Supply.quantity to identify the amount supplied by how long it is expected to last, rather than the physical quantity issued. E.g. 90 days supply of medication (based on an ordered dosage), 10 hours of jet fuel, etc. NOTE: When possible, it is always better to specify Supply.quantity, as this tends to be more precise. Supply.expectedUseTime will always be an estimate that can be influenced by external factors.
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> expectedUseTime { get { return propGetExpectedUseTime(); } set { propSetExpectedUseTime(value); } }

      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      private HL7Connect.Cda.Subject propGetSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().subject);
      }
      private void propSetSubject(HL7Connect.Cda.Subject value)
      {
        wrapped().subject = value.wrapped();
      }
      ///<summary>
      /// The subject participant represents the primary target of the entries recorded in the document or section. Most of the time the subject is the same as the recordTarget, but need not be, for instance when the subject is a fetus observed in an obstetrical ultrasound. 
      /// 
      /// The subject participant can be ascribed to a CDA section or a CDA entry. It propagates to nested components, unless overridden. The subject of a document is presumed to be the patient.
      ///</summary>
      public HL7Connect.Cda.Subject subject { get { return propGetSubject(); } set { propSetSubject(value); } }

      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      private HL7Connect.Cda.SpecimenList propGetSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenList(wrapped().specimen);
      }
      private void propSetSpecimen(HL7Connect.Cda.SpecimenList value)
      {
        wrapped().specimen = value.wrapped();
      }
      ///<summary>
      /// A specimen is a part of some entity, typically the subject, that is the target of focused laboratory, radiology or other observations. In many clinical observations, such as physical examination of a patient, the patient is the subject of the observation, and there is no specimen. The specimen participant is only used when observations are made against some substance or object that is taken or derived from the subject.
      ///</summary>
      public HL7Connect.Cda.SpecimenList specimen { get { return propGetSpecimen(); } set { propSetSpecimen(value); } }

      ///<summary>
      /// The dispensed product is associated with the Supply act via a product participant, which connects to the same ManufacturedProduct role used for SubstanceAdministration
      ///</summary>
      private HL7Connect.Cda.Product propGetProduct()
      {
        return HL7Connect.Cda.WrapperFactory.Product(wrapped().product);
      }
      private void propSetProduct(HL7Connect.Cda.Product value)
      {
        wrapped().product = value.wrapped();
      }
      ///<summary>
      /// The dispensed product is associated with the Supply act via a product participant, which connects to the same ManufacturedProduct role used for SubstanceAdministration
      ///</summary>
      public HL7Connect.Cda.Product product { get { return propGetProduct(); } set { propSetProduct(value); } }

      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      private HL7Connect.Cda.Performer2List propGetPerformer()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2List(wrapped().performer);
      }
      private void propSetPerformer(HL7Connect.Cda.Performer2List value)
      {
        wrapped().performer = value.wrapped();
      }
      ///<summary>
      /// The performer is a person who carries out or will carry out a particular act. The performer need not be the principal responsible participant, e.g. a surgery resident operating under supervision of attending surgeon is a performer.
      ///</summary>
      public HL7Connect.Cda.Performer2List performer { get { return propGetPerformer(); } set { propSetPerformer(value); } }

      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      private HL7Connect.Cda.AuthorList propGetAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AuthorList(wrapped().author);
      }
      private void propSetAuthor(HL7Connect.Cda.AuthorList value)
      {
        wrapped().author = value.wrapped();
      }
      ///<summary>
      /// Represents the humans and/or machines that authored the document or section
      ///</summary>
      public HL7Connect.Cda.AuthorList author { get { return propGetAuthor(); } set { propSetAuthor(value); } }

      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      private HL7Connect.Cda.Informant12List propGetInformant()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12List(wrapped().informant);
      }
      private void propSetInformant(HL7Connect.Cda.Informant12List value)
      {
        wrapped().informant = value.wrapped();
      }
      ///<summary>
      /// An informant (or source of information) is a person that provides relevant information, such as the parent of a comatose patient who describes the patient's behavior prior to the onset of coma.
      ///</summary>
      public HL7Connect.Cda.Informant12List informant { get { return propGetInformant(); } set { propSetInformant(value); } }

      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      private HL7Connect.Cda.Participant2List propGetParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2List(wrapped().participant);
      }
      private void propSetParticipant(HL7Connect.Cda.Participant2List value)
      {
        wrapped().participant = value.wrapped();
      }
      ///<summary>
      /// Used to represent other participants not explicitly mentioned by other classes, that were somehow involved in the documented acts.
      ///</summary>
      public HL7Connect.Cda.Participant2List participant { get { return propGetParticipant(); } set { propSetParticipant(value); } }

      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      private HL7Connect.Cda.EntryRelationshipList propGetEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationshipList(wrapped().entryRelationship);
      }
      private void propSetEntryRelationship(HL7Connect.Cda.EntryRelationshipList value)
      {
        wrapped().entryRelationship = value.wrapped();
      }
      ///<summary>
      /// CDA has identified and modeled various link and reference scenarios. These scenarios enable CDA entries to be semantically linked to entries that exist within the same document (by traversing the entryRelationship class) or to objects external to it (by traversing the reference class). 
      /// 
      /// NOTE: The CDA specification permits any CDA entry to relate to any CDA entry using any of the following relationship types. In many cases, this would result in nonsensical relationships. The following table is a guideline for reasonable relationships between CDA entries, and is not a conformance constraint.
      ///</summary>
      public HL7Connect.Cda.EntryRelationshipList entryRelationship { get { return propGetEntryRelationship(); } set { propSetEntryRelationship(value); } }

      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      private HL7Connect.Cda.ReferenceList propGetReference()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceList(wrapped().reference);
      }
      private void propSetReference(HL7Connect.Cda.ReferenceList value)
      {
        wrapped().reference = value.wrapped();
      }
      ///<summary>
      /// CDA entries can reference external objects such as external images and prior reports. These external objects are not part of the authenticated document content. They contain sufficient attributes to enable an explicit reference rather than duplicating the entire referenced object. The CDA entry that wraps the external reference can be used to encode the specific portions of the external reference that are addressed in the narrative block. 
      /// 
      /// Each object allows for an identifier and a code, and contains the RIM Act.text attribute, which can be used to store the URL and MIME type of the object. External objects always have a fixed moodCode of "EVN".
      ///</summary>
      public HL7Connect.Cda.ReferenceList reference { get { return propGetReference(); } set { propSetReference(value); } }

      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      private HL7Connect.Cda.PreconditionList propGetPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.PreconditionList(wrapped().precondition);
      }
      private void propSetPrecondition(HL7Connect.Cda.PreconditionList value)
      {
        wrapped().precondition = value.wrapped();
      }
      ///<summary>
      /// The precondition class, derived from the ActRelationship class, is used along with the Criterion class to express a condition that must hold true before some over activity occurs.
      ///</summary>
      public HL7Connect.Cda.PreconditionList precondition { get { return propGetPrecondition(); } set { propSetPrecondition(value); } }

    }

    public class AuthorList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Author>
    {
      public AuthorList(IcdaAuthorList com) : base(com) {}
      internal new HCcdaAuthorList wrapped() { return (HCcdaAuthorList) com; }
  
      public Author this[int index]
      {
        get { return new Author(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Author item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Author Append()
      {
        return new Author(wrapped().Append());
      }
  
      public void Insert(int index, Author item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Author item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Author item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Author[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Author(wrapped().Item(i));
      }
  
      public bool Remove(Author item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class AuthorListEnumerator : IEnumerator<Author>
      {
        private IcdaAuthorList com;
        int index = -1;
  
        public AuthorListEnumerator(IcdaAuthorList com)
        {
          this.com = com;
        }
  
        public Author Current { get { return new Author(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Author(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Author> GetEnumerator()
      {
        return new AuthorListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new AuthorListEnumerator(wrapped());
      }
  
    }
  
    public class EntryRelationshipList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<EntryRelationship>
    {
      public EntryRelationshipList(IcdaEntryRelationshipList com) : base(com) {}
      internal new HCcdaEntryRelationshipList wrapped() { return (HCcdaEntryRelationshipList) com; }
  
      public EntryRelationship this[int index]
      {
        get { return new EntryRelationship(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(EntryRelationship item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public EntryRelationship Append()
      {
        return new EntryRelationship(wrapped().Append());
      }
  
      public void Insert(int index, EntryRelationship item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(EntryRelationship item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(EntryRelationship item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(EntryRelationship[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new EntryRelationship(wrapped().Item(i));
      }
  
      public bool Remove(EntryRelationship item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class EntryRelationshipListEnumerator : IEnumerator<EntryRelationship>
      {
        private IcdaEntryRelationshipList com;
        int index = -1;
  
        public EntryRelationshipListEnumerator(IcdaEntryRelationshipList com)
        {
          this.com = com;
        }
  
        public EntryRelationship Current { get { return new EntryRelationship(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new EntryRelationship(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<EntryRelationship> GetEnumerator()
      {
        return new EntryRelationshipListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new EntryRelationshipListEnumerator(wrapped());
      }
  
    }
  
    public class Informant12List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Informant12>
    {
      public Informant12List(IcdaInformant12List com) : base(com) {}
      internal new HCcdaInformant12List wrapped() { return (HCcdaInformant12List) com; }
  
      public Informant12 this[int index]
      {
        get { return new Informant12(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Informant12 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Informant12 Append()
      {
        return new Informant12(wrapped().Append());
      }
  
      public void Insert(int index, Informant12 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Informant12 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Informant12 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Informant12[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Informant12(wrapped().Item(i));
      }
  
      public bool Remove(Informant12 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Informant12ListEnumerator : IEnumerator<Informant12>
      {
        private IcdaInformant12List com;
        int index = -1;
  
        public Informant12ListEnumerator(IcdaInformant12List com)
        {
          this.com = com;
        }
  
        public Informant12 Current { get { return new Informant12(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Informant12(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Informant12> GetEnumerator()
      {
        return new Informant12ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Informant12ListEnumerator(wrapped());
      }
  
    }
  
    public class Participant2List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Participant2>
    {
      public Participant2List(IcdaParticipant2List com) : base(com) {}
      internal new HCcdaParticipant2List wrapped() { return (HCcdaParticipant2List) com; }
  
      public Participant2 this[int index]
      {
        get { return new Participant2(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Participant2 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Participant2 Append()
      {
        return new Participant2(wrapped().Append());
      }
  
      public void Insert(int index, Participant2 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Participant2 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Participant2 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Participant2[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Participant2(wrapped().Item(i));
      }
  
      public bool Remove(Participant2 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Participant2ListEnumerator : IEnumerator<Participant2>
      {
        private IcdaParticipant2List com;
        int index = -1;
  
        public Participant2ListEnumerator(IcdaParticipant2List com)
        {
          this.com = com;
        }
  
        public Participant2 Current { get { return new Participant2(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Participant2(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Participant2> GetEnumerator()
      {
        return new Participant2ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Participant2ListEnumerator(wrapped());
      }
  
    }
  
    public class Performer2List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Performer2>
    {
      public Performer2List(IcdaPerformer2List com) : base(com) {}
      internal new HCcdaPerformer2List wrapped() { return (HCcdaPerformer2List) com; }
  
      public Performer2 this[int index]
      {
        get { return new Performer2(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Performer2 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Performer2 Append()
      {
        return new Performer2(wrapped().Append());
      }
  
      public void Insert(int index, Performer2 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Performer2 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Performer2 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Performer2[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Performer2(wrapped().Item(i));
      }
  
      public bool Remove(Performer2 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Performer2ListEnumerator : IEnumerator<Performer2>
      {
        private IcdaPerformer2List com;
        int index = -1;
  
        public Performer2ListEnumerator(IcdaPerformer2List com)
        {
          this.com = com;
        }
  
        public Performer2 Current { get { return new Performer2(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Performer2(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Performer2> GetEnumerator()
      {
        return new Performer2ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Performer2ListEnumerator(wrapped());
      }
  
    }
  
    public class PreconditionList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Precondition>
    {
      public PreconditionList(IcdaPreconditionList com) : base(com) {}
      internal new HCcdaPreconditionList wrapped() { return (HCcdaPreconditionList) com; }
  
      public Precondition this[int index]
      {
        get { return new Precondition(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Precondition item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Precondition Append()
      {
        return new Precondition(wrapped().Append());
      }
  
      public void Insert(int index, Precondition item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Precondition item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Precondition item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Precondition[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Precondition(wrapped().Item(i));
      }
  
      public bool Remove(Precondition item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class PreconditionListEnumerator : IEnumerator<Precondition>
      {
        private IcdaPreconditionList com;
        int index = -1;
  
        public PreconditionListEnumerator(IcdaPreconditionList com)
        {
          this.com = com;
        }
  
        public Precondition Current { get { return new Precondition(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Precondition(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Precondition> GetEnumerator()
      {
        return new PreconditionListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new PreconditionListEnumerator(wrapped());
      }
  
    }
  
    public class ReferenceList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Reference>
    {
      public ReferenceList(IcdaReferenceList com) : base(com) {}
      internal new HCcdaReferenceList wrapped() { return (HCcdaReferenceList) com; }
  
      public Reference this[int index]
      {
        get { return new Reference(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Reference item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Reference Append()
      {
        return new Reference(wrapped().Append());
      }
  
      public void Insert(int index, Reference item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Reference item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Reference item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Reference[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Reference(wrapped().Item(i));
      }
  
      public bool Remove(Reference item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ReferenceListEnumerator : IEnumerator<Reference>
      {
        private IcdaReferenceList com;
        int index = -1;
  
        public ReferenceListEnumerator(IcdaReferenceList com)
        {
          this.com = com;
        }
  
        public Reference Current { get { return new Reference(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Reference(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Reference> GetEnumerator()
      {
        return new ReferenceListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ReferenceListEnumerator(wrapped());
      }
  
    }
  
    public class SpecimenList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Specimen>
    {
      public SpecimenList(IcdaSpecimenList com) : base(com) {}
      internal new HCcdaSpecimenList wrapped() { return (HCcdaSpecimenList) com; }
  
      public Specimen this[int index]
      {
        get { return new Specimen(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Specimen item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Specimen Append()
      {
        return new Specimen(wrapped().Append());
      }
  
      public void Insert(int index, Specimen item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Specimen item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Specimen item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Specimen[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Specimen(wrapped().Item(i));
      }
  
      public bool Remove(Specimen item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class SpecimenListEnumerator : IEnumerator<Specimen>
      {
        private IcdaSpecimenList com;
        int index = -1;
  
        public SpecimenListEnumerator(IcdaSpecimenList com)
        {
          this.com = com;
        }
  
        public Specimen Current { get { return new Specimen(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Specimen(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Specimen> GetEnumerator()
      {
        return new SpecimenListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new SpecimenListEnumerator(wrapped());
      }
  
    }
  
    public class MaintainedEntityList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<MaintainedEntity>
    {
      public MaintainedEntityList(IcdaMaintainedEntityList com) : base(com) {}
      internal new HCcdaMaintainedEntityList wrapped() { return (HCcdaMaintainedEntityList) com; }
  
      public MaintainedEntity this[int index]
      {
        get { return new MaintainedEntity(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(MaintainedEntity item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public MaintainedEntity Append()
      {
        return new MaintainedEntity(wrapped().Append());
      }
  
      public void Insert(int index, MaintainedEntity item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(MaintainedEntity item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(MaintainedEntity item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(MaintainedEntity[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new MaintainedEntity(wrapped().Item(i));
      }
  
      public bool Remove(MaintainedEntity item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class MaintainedEntityListEnumerator : IEnumerator<MaintainedEntity>
      {
        private IcdaMaintainedEntityList com;
        int index = -1;
  
        public MaintainedEntityListEnumerator(IcdaMaintainedEntityList com)
        {
          this.com = com;
        }
  
        public MaintainedEntity Current { get { return new MaintainedEntity(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new MaintainedEntity(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<MaintainedEntity> GetEnumerator()
      {
        return new MaintainedEntityListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new MaintainedEntityListEnumerator(wrapped());
      }
  
    }
  
    public class AuthenticatorList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Authenticator>
    {
      public AuthenticatorList(IcdaAuthenticatorList com) : base(com) {}
      internal new HCcdaAuthenticatorList wrapped() { return (HCcdaAuthenticatorList) com; }
  
      public Authenticator this[int index]
      {
        get { return new Authenticator(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Authenticator item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Authenticator Append()
      {
        return new Authenticator(wrapped().Append());
      }
  
      public void Insert(int index, Authenticator item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Authenticator item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Authenticator item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Authenticator[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Authenticator(wrapped().Item(i));
      }
  
      public bool Remove(Authenticator item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class AuthenticatorListEnumerator : IEnumerator<Authenticator>
      {
        private IcdaAuthenticatorList com;
        int index = -1;
  
        public AuthenticatorListEnumerator(IcdaAuthenticatorList com)
        {
          this.com = com;
        }
  
        public Authenticator Current { get { return new Authenticator(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Authenticator(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Authenticator> GetEnumerator()
      {
        return new AuthenticatorListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new AuthenticatorListEnumerator(wrapped());
      }
  
    }
  
    public class AuthorizationList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Authorization>
    {
      public AuthorizationList(IcdaAuthorizationList com) : base(com) {}
      internal new HCcdaAuthorizationList wrapped() { return (HCcdaAuthorizationList) com; }
  
      public Authorization this[int index]
      {
        get { return new Authorization(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Authorization item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Authorization Append()
      {
        return new Authorization(wrapped().Append());
      }
  
      public void Insert(int index, Authorization item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Authorization item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Authorization item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Authorization[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Authorization(wrapped().Item(i));
      }
  
      public bool Remove(Authorization item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class AuthorizationListEnumerator : IEnumerator<Authorization>
      {
        private IcdaAuthorizationList com;
        int index = -1;
  
        public AuthorizationListEnumerator(IcdaAuthorizationList com)
        {
          this.com = com;
        }
  
        public Authorization Current { get { return new Authorization(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Authorization(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Authorization> GetEnumerator()
      {
        return new AuthorizationListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new AuthorizationListEnumerator(wrapped());
      }
  
    }
  
    public class DocumentationOfList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<DocumentationOf>
    {
      public DocumentationOfList(IcdaDocumentationOfList com) : base(com) {}
      internal new HCcdaDocumentationOfList wrapped() { return (HCcdaDocumentationOfList) com; }
  
      public DocumentationOf this[int index]
      {
        get { return new DocumentationOf(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(DocumentationOf item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public DocumentationOf Append()
      {
        return new DocumentationOf(wrapped().Append());
      }
  
      public void Insert(int index, DocumentationOf item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(DocumentationOf item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(DocumentationOf item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(DocumentationOf[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new DocumentationOf(wrapped().Item(i));
      }
  
      public bool Remove(DocumentationOf item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class DocumentationOfListEnumerator : IEnumerator<DocumentationOf>
      {
        private IcdaDocumentationOfList com;
        int index = -1;
  
        public DocumentationOfListEnumerator(IcdaDocumentationOfList com)
        {
          this.com = com;
        }
  
        public DocumentationOf Current { get { return new DocumentationOf(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new DocumentationOf(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<DocumentationOf> GetEnumerator()
      {
        return new DocumentationOfListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new DocumentationOfListEnumerator(wrapped());
      }
  
    }
  
    public class InformationRecipientList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<InformationRecipient>
    {
      public InformationRecipientList(IcdaInformationRecipientList com) : base(com) {}
      internal new HCcdaInformationRecipientList wrapped() { return (HCcdaInformationRecipientList) com; }
  
      public InformationRecipient this[int index]
      {
        get { return new InformationRecipient(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(InformationRecipient item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public InformationRecipient Append()
      {
        return new InformationRecipient(wrapped().Append());
      }
  
      public void Insert(int index, InformationRecipient item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(InformationRecipient item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(InformationRecipient item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(InformationRecipient[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new InformationRecipient(wrapped().Item(i));
      }
  
      public bool Remove(InformationRecipient item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class InformationRecipientListEnumerator : IEnumerator<InformationRecipient>
      {
        private IcdaInformationRecipientList com;
        int index = -1;
  
        public InformationRecipientListEnumerator(IcdaInformationRecipientList com)
        {
          this.com = com;
        }
  
        public InformationRecipient Current { get { return new InformationRecipient(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new InformationRecipient(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<InformationRecipient> GetEnumerator()
      {
        return new InformationRecipientListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new InformationRecipientListEnumerator(wrapped());
      }
  
    }
  
    public class InFulfillmentOfList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<InFulfillmentOf>
    {
      public InFulfillmentOfList(IcdaInFulfillmentOfList com) : base(com) {}
      internal new HCcdaInFulfillmentOfList wrapped() { return (HCcdaInFulfillmentOfList) com; }
  
      public InFulfillmentOf this[int index]
      {
        get { return new InFulfillmentOf(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(InFulfillmentOf item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public InFulfillmentOf Append()
      {
        return new InFulfillmentOf(wrapped().Append());
      }
  
      public void Insert(int index, InFulfillmentOf item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(InFulfillmentOf item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(InFulfillmentOf item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(InFulfillmentOf[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new InFulfillmentOf(wrapped().Item(i));
      }
  
      public bool Remove(InFulfillmentOf item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class InFulfillmentOfListEnumerator : IEnumerator<InFulfillmentOf>
      {
        private IcdaInFulfillmentOfList com;
        int index = -1;
  
        public InFulfillmentOfListEnumerator(IcdaInFulfillmentOfList com)
        {
          this.com = com;
        }
  
        public InFulfillmentOf Current { get { return new InFulfillmentOf(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new InFulfillmentOf(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<InFulfillmentOf> GetEnumerator()
      {
        return new InFulfillmentOfListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new InFulfillmentOfListEnumerator(wrapped());
      }
  
    }
  
    public class Participant1List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Participant1>
    {
      public Participant1List(IcdaParticipant1List com) : base(com) {}
      internal new HCcdaParticipant1List wrapped() { return (HCcdaParticipant1List) com; }
  
      public Participant1 this[int index]
      {
        get { return new Participant1(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Participant1 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Participant1 Append()
      {
        return new Participant1(wrapped().Append());
      }
  
      public void Insert(int index, Participant1 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Participant1 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Participant1 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Participant1[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Participant1(wrapped().Item(i));
      }
  
      public bool Remove(Participant1 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Participant1ListEnumerator : IEnumerator<Participant1>
      {
        private IcdaParticipant1List com;
        int index = -1;
  
        public Participant1ListEnumerator(IcdaParticipant1List com)
        {
          this.com = com;
        }
  
        public Participant1 Current { get { return new Participant1(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Participant1(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Participant1> GetEnumerator()
      {
        return new Participant1ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Participant1ListEnumerator(wrapped());
      }
  
    }
  
    public class RecordTargetList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<RecordTarget>
    {
      public RecordTargetList(IcdaRecordTargetList com) : base(com) {}
      internal new HCcdaRecordTargetList wrapped() { return (HCcdaRecordTargetList) com; }
  
      public RecordTarget this[int index]
      {
        get { return new RecordTarget(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(RecordTarget item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public RecordTarget Append()
      {
        return new RecordTarget(wrapped().Append());
      }
  
      public void Insert(int index, RecordTarget item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(RecordTarget item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(RecordTarget item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(RecordTarget[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new RecordTarget(wrapped().Item(i));
      }
  
      public bool Remove(RecordTarget item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class RecordTargetListEnumerator : IEnumerator<RecordTarget>
      {
        private IcdaRecordTargetList com;
        int index = -1;
  
        public RecordTargetListEnumerator(IcdaRecordTargetList com)
        {
          this.com = com;
        }
  
        public RecordTarget Current { get { return new RecordTarget(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new RecordTarget(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<RecordTarget> GetEnumerator()
      {
        return new RecordTargetListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new RecordTargetListEnumerator(wrapped());
      }
  
    }
  
    public class RelatedDocumentList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<RelatedDocument>
    {
      public RelatedDocumentList(IcdaRelatedDocumentList com) : base(com) {}
      internal new HCcdaRelatedDocumentList wrapped() { return (HCcdaRelatedDocumentList) com; }
  
      public RelatedDocument this[int index]
      {
        get { return new RelatedDocument(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(RelatedDocument item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public RelatedDocument Append()
      {
        return new RelatedDocument(wrapped().Append());
      }
  
      public void Insert(int index, RelatedDocument item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(RelatedDocument item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(RelatedDocument item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(RelatedDocument[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new RelatedDocument(wrapped().Item(i));
      }
  
      public bool Remove(RelatedDocument item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class RelatedDocumentListEnumerator : IEnumerator<RelatedDocument>
      {
        private IcdaRelatedDocumentList com;
        int index = -1;
  
        public RelatedDocumentListEnumerator(IcdaRelatedDocumentList com)
        {
          this.com = com;
        }
  
        public RelatedDocument Current { get { return new RelatedDocument(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new RelatedDocument(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<RelatedDocument> GetEnumerator()
      {
        return new RelatedDocumentListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new RelatedDocumentListEnumerator(wrapped());
      }
  
    }
  
    public class EncounterParticipantList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<EncounterParticipant>
    {
      public EncounterParticipantList(IcdaEncounterParticipantList com) : base(com) {}
      internal new HCcdaEncounterParticipantList wrapped() { return (HCcdaEncounterParticipantList) com; }
  
      public EncounterParticipant this[int index]
      {
        get { return new EncounterParticipant(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(EncounterParticipant item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public EncounterParticipant Append()
      {
        return new EncounterParticipant(wrapped().Append());
      }
  
      public void Insert(int index, EncounterParticipant item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(EncounterParticipant item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(EncounterParticipant item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(EncounterParticipant[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new EncounterParticipant(wrapped().Item(i));
      }
  
      public bool Remove(EncounterParticipant item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class EncounterParticipantListEnumerator : IEnumerator<EncounterParticipant>
      {
        private IcdaEncounterParticipantList com;
        int index = -1;
  
        public EncounterParticipantListEnumerator(IcdaEncounterParticipantList com)
        {
          this.com = com;
        }
  
        public EncounterParticipant Current { get { return new EncounterParticipant(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new EncounterParticipant(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<EncounterParticipant> GetEnumerator()
      {
        return new EncounterParticipantListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new EncounterParticipantListEnumerator(wrapped());
      }
  
    }
  
    public class ReferenceRangeList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ReferenceRange>
    {
      public ReferenceRangeList(IcdaReferenceRangeList com) : base(com) {}
      internal new HCcdaReferenceRangeList wrapped() { return (HCcdaReferenceRangeList) com; }
  
      public ReferenceRange this[int index]
      {
        get { return new ReferenceRange(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ReferenceRange item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ReferenceRange Append()
      {
        return new ReferenceRange(wrapped().Append());
      }
  
      public void Insert(int index, ReferenceRange item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ReferenceRange item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ReferenceRange item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ReferenceRange[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ReferenceRange(wrapped().Item(i));
      }
  
      public bool Remove(ReferenceRange item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ReferenceRangeListEnumerator : IEnumerator<ReferenceRange>
      {
        private IcdaReferenceRangeList com;
        int index = -1;
  
        public ReferenceRangeListEnumerator(IcdaReferenceRangeList com)
        {
          this.com = com;
        }
  
        public ReferenceRange Current { get { return new ReferenceRange(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ReferenceRange(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ReferenceRange> GetEnumerator()
      {
        return new ReferenceRangeListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ReferenceRangeListEnumerator(wrapped());
      }
  
    }
  
    public class Component4List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Component4>
    {
      public Component4List(IcdaComponent4List com) : base(com) {}
      internal new HCcdaComponent4List wrapped() { return (HCcdaComponent4List) com; }
  
      public Component4 this[int index]
      {
        get { return new Component4(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Component4 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Component4 Append()
      {
        return new Component4(wrapped().Append());
      }
  
      public void Insert(int index, Component4 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Component4 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Component4 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Component4[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Component4(wrapped().Item(i));
      }
  
      public bool Remove(Component4 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Component4ListEnumerator : IEnumerator<Component4>
      {
        private IcdaComponent4List com;
        int index = -1;
  
        public Component4ListEnumerator(IcdaComponent4List com)
        {
          this.com = com;
        }
  
        public Component4 Current { get { return new Component4(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Component4(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Component4> GetEnumerator()
      {
        return new Component4ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Component4ListEnumerator(wrapped());
      }
  
    }
  
    public class GuardianList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Guardian>
    {
      public GuardianList(IcdaGuardianList com) : base(com) {}
      internal new HCcdaGuardianList wrapped() { return (HCcdaGuardianList) com; }
  
      public Guardian this[int index]
      {
        get { return new Guardian(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Guardian item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Guardian Append()
      {
        return new Guardian(wrapped().Append());
      }
  
      public void Insert(int index, Guardian item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Guardian item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Guardian item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Guardian[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Guardian(wrapped().Item(i));
      }
  
      public bool Remove(Guardian item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class GuardianListEnumerator : IEnumerator<Guardian>
      {
        private IcdaGuardianList com;
        int index = -1;
  
        public GuardianListEnumerator(IcdaGuardianList com)
        {
          this.com = com;
        }
  
        public Guardian Current { get { return new Guardian(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Guardian(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Guardian> GetEnumerator()
      {
        return new GuardianListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new GuardianListEnumerator(wrapped());
      }
  
    }
  
    public class LanguageCommunicationList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<LanguageCommunication>
    {
      public LanguageCommunicationList(IcdaLanguageCommunicationList com) : base(com) {}
      internal new HCcdaLanguageCommunicationList wrapped() { return (HCcdaLanguageCommunicationList) com; }
  
      public LanguageCommunication this[int index]
      {
        get { return new LanguageCommunication(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(LanguageCommunication item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public LanguageCommunication Append()
      {
        return new LanguageCommunication(wrapped().Append());
      }
  
      public void Insert(int index, LanguageCommunication item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(LanguageCommunication item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(LanguageCommunication item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(LanguageCommunication[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new LanguageCommunication(wrapped().Item(i));
      }
  
      public bool Remove(LanguageCommunication item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class LanguageCommunicationListEnumerator : IEnumerator<LanguageCommunication>
      {
        private IcdaLanguageCommunicationList com;
        int index = -1;
  
        public LanguageCommunicationListEnumerator(IcdaLanguageCommunicationList com)
        {
          this.com = com;
        }
  
        public LanguageCommunication Current { get { return new LanguageCommunication(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new LanguageCommunication(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<LanguageCommunication> GetEnumerator()
      {
        return new LanguageCommunicationListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new LanguageCommunicationListEnumerator(wrapped());
      }
  
    }
  
    public class Component5List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Component5>
    {
      public Component5List(IcdaComponent5List com) : base(com) {}
      internal new HCcdaComponent5List wrapped() { return (HCcdaComponent5List) com; }
  
      public Component5 this[int index]
      {
        get { return new Component5(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Component5 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Component5 Append()
      {
        return new Component5(wrapped().Append());
      }
  
      public void Insert(int index, Component5 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Component5 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Component5 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Component5[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Component5(wrapped().Item(i));
      }
  
      public bool Remove(Component5 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Component5ListEnumerator : IEnumerator<Component5>
      {
        private IcdaComponent5List com;
        int index = -1;
  
        public Component5ListEnumerator(IcdaComponent5List com)
        {
          this.com = com;
        }
  
        public Component5 Current { get { return new Component5(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Component5(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Component5> GetEnumerator()
      {
        return new Component5ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Component5ListEnumerator(wrapped());
      }
  
    }
  
    public class EntryList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Entry>
    {
      public EntryList(IcdaEntryList com) : base(com) {}
      internal new HCcdaEntryList wrapped() { return (HCcdaEntryList) com; }
  
      public Entry this[int index]
      {
        get { return new Entry(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Entry item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Entry Append()
      {
        return new Entry(wrapped().Append());
      }
  
      public void Insert(int index, Entry item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Entry item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Entry item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Entry[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Entry(wrapped().Item(i));
      }
  
      public bool Remove(Entry item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class EntryListEnumerator : IEnumerator<Entry>
      {
        private IcdaEntryList com;
        int index = -1;
  
        public EntryListEnumerator(IcdaEntryList com)
        {
          this.com = com;
        }
  
        public Entry Current { get { return new Entry(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Entry(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Entry> GetEnumerator()
      {
        return new EntryListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new EntryListEnumerator(wrapped());
      }
  
    }
  
    public class Performer1List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Performer1>
    {
      public Performer1List(IcdaPerformer1List com) : base(com) {}
      internal new HCcdaPerformer1List wrapped() { return (HCcdaPerformer1List) com; }
  
      public Performer1 this[int index]
      {
        get { return new Performer1(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Performer1 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Performer1 Append()
      {
        return new Performer1(wrapped().Append());
      }
  
      public void Insert(int index, Performer1 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Performer1 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Performer1 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Performer1[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Performer1(wrapped().Item(i));
      }
  
      public bool Remove(Performer1 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Performer1ListEnumerator : IEnumerator<Performer1>
      {
        private IcdaPerformer1List com;
        int index = -1;
  
        public Performer1ListEnumerator(IcdaPerformer1List com)
        {
          this.com = com;
        }
  
        public Performer1 Current { get { return new Performer1(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Performer1(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Performer1> GetEnumerator()
      {
        return new Performer1ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Performer1ListEnumerator(wrapped());
      }
  
    }
  
    public class Component3List : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<Component3>
    {
      public Component3List(IcdaComponent3List com) : base(com) {}
      internal new HCcdaComponent3List wrapped() { return (HCcdaComponent3List) com; }
  
      public Component3 this[int index]
      {
        get { return new Component3(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(Component3 item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public Component3 Append()
      {
        return new Component3(wrapped().Append());
      }
  
      public void Insert(int index, Component3 item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(Component3 item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(Component3 item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(Component3[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new Component3(wrapped().Item(i));
      }
  
      public bool Remove(Component3 item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class Component3ListEnumerator : IEnumerator<Component3>
      {
        private IcdaComponent3List com;
        int index = -1;
  
        public Component3ListEnumerator(IcdaComponent3List com)
        {
          this.com = com;
        }
  
        public Component3 Current { get { return new Component3(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new Component3(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<Component3> GetEnumerator()
      {
        return new Component3ListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new Component3ListEnumerator(wrapped());
      }
  
    }
  
    public class RegionOfInterest_valueList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<RegionOfInterest_value>
    {
      public RegionOfInterest_valueList(IcdaRegionOfInterest_valueList com) : base(com) {}
      internal new HCcdaRegionOfInterest_valueList wrapped() { return (HCcdaRegionOfInterest_valueList) com; }
  
      public RegionOfInterest_value this[int index]
      {
        get { return new RegionOfInterest_value(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(RegionOfInterest_value item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public RegionOfInterest_value Append()
      {
        return new RegionOfInterest_value(wrapped().Append());
      }
  
      public void Insert(int index, RegionOfInterest_value item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(RegionOfInterest_value item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(RegionOfInterest_value item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(RegionOfInterest_value[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new RegionOfInterest_value(wrapped().Item(i));
      }
  
      public bool Remove(RegionOfInterest_value item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class RegionOfInterest_valueListEnumerator : IEnumerator<RegionOfInterest_value>
      {
        private IcdaRegionOfInterest_valueList com;
        int index = -1;
  
        public RegionOfInterest_valueListEnumerator(IcdaRegionOfInterest_valueList com)
        {
          this.com = com;
        }
  
        public RegionOfInterest_value Current { get { return new RegionOfInterest_value(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new RegionOfInterest_value(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<RegionOfInterest_value> GetEnumerator()
      {
        return new RegionOfInterest_valueListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new RegionOfInterest_valueListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// Used to build new instances of CDA related classes
    ///</summary>
    public class Factory : HL7Connect.Utils.Base
    {

      internal Factory(ICDAFactory com) : base(com) {} 

      internal new HCCDAFactory wrapped() { return (HCCDAFactory) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Create a type by it's type name
      ///</summary>
      public HL7Connect.Cda.Base CreateByName(string sName)
      {
        return HL7Connect.Cda.WrapperFactory.Base(wrapped().CreateByName(sName));
      }

      ///<summary>
      /// Create a v3 ANY
      ///</summary>
      public HL7Connect.Cda.ANY newANY()
      {
        return HL7Connect.Cda.WrapperFactory.ANY(wrapped().newANY());
      }

      ///<summary>
      /// Create a v3 ANY
      ///</summary>
      public HL7Connect.Cda.ANY newANYValue(Tv3NullFlavor nullFlavor)
      {
        return HL7Connect.Cda.WrapperFactory.ANY(wrapped().newANYValue(nullFlavor));
      }

      ///<summary>
      /// Create a v3 BL
      ///</summary>
      public HL7Connect.Cda.BL newBL()
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().newBL());
      }

      ///<summary>
      /// Create a v3 BL
      ///</summary>
      public HL7Connect.Cda.BL newBLValue(bool aValue)
      {
        return HL7Connect.Cda.WrapperFactory.BL(wrapped().newBLValue(aValue ? (sbyte) 0 : (sbyte) -1));
      }

      ///<summary>
      /// Create a v3 ED
      ///</summary>
      public HL7Connect.Cda.ED newED()
      {
        return HL7Connect.Cda.WrapperFactory.ED(wrapped().newED());
      }

      ///<summary>
      /// Create a v3 ST
      ///</summary>
      public HL7Connect.Cda.ST newST()
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().newST());
      }

      ///<summary>
      /// Create a v3 ST
      ///</summary>
      public HL7Connect.Cda.ST newSTValue(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.ST(wrapped().newSTValue(sValue));
      }

      ///<summary>
      /// Create a v3 SC
      ///</summary>
      public HL7Connect.Cda.SC newSC()
      {
        return HL7Connect.Cda.WrapperFactory.SC(wrapped().newSC());
      }

      ///<summary>
      /// Create a v3 CR
      ///</summary>
      public HL7Connect.Cda.CR newCR()
      {
        return HL7Connect.Cda.WrapperFactory.CR(wrapped().newCR());
      }

      ///<summary>
      /// Create a v3 CD
      ///</summary>
      public HL7Connect.Cda.CD newCD()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().newCD());
      }

      ///<summary>
      /// Create a v3 CD
      ///</summary>
      public HL7Connect.Cda.CD newCDValue(string sCode, string sCodeSystem)
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().newCDValue(sCode, sCodeSystem));
      }

      ///<summary>
      /// Create a v3 CS
      ///</summary>
      public HL7Connect.Cda.CS newCS()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().newCS());
      }

      ///<summary>
      /// Create a v3 CS
      ///</summary>
      public HL7Connect.Cda.CS newCSValue(string sCode)
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().newCSValue(sCode));
      }

      ///<summary>
      /// Create a v3 TEL
      ///</summary>
      public HL7Connect.Cda.TEL newTEL()
      {
        return HL7Connect.Cda.WrapperFactory.TEL(wrapped().newTEL());
      }

      ///<summary>
      /// Create a v3 TEL
      ///</summary>
      public HL7Connect.Cda.TEL newTELValue(string sAddress)
      {
        return HL7Connect.Cda.WrapperFactory.TEL(wrapped().newTELValue(sAddress));
      }

      ///<summary>
      /// Create a v3 II
      ///</summary>
      public HL7Connect.Cda.II newII()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().newII());
      }

      ///<summary>
      /// Create a v3 II
      ///</summary>
      public HL7Connect.Cda.II newIIValue(string sRoot, string sExtension)
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().newIIValue(sRoot, sExtension));
      }

      ///<summary>
      /// Create a v3 XP
      ///</summary>
      public HL7Connect.Cda.XP newXP()
      {
        return HL7Connect.Cda.WrapperFactory.XP(wrapped().newXP());
      }

      ///<summary>
      /// Create a v3 ADXP
      ///</summary>
      public HL7Connect.Cda.ADXP newADXP()
      {
        return HL7Connect.Cda.WrapperFactory.ADXP(wrapped().newADXP());
      }

      ///<summary>
      /// Create a v3 AD
      ///</summary>
      public HL7Connect.Cda.AD newAD()
      {
        return HL7Connect.Cda.WrapperFactory.AD(wrapped().newAD());
      }

      ///<summary>
      /// Create a v3 ENXP
      ///</summary>
      public HL7Connect.Cda.ENXP newENXP()
      {
        return HL7Connect.Cda.WrapperFactory.ENXP(wrapped().newENXP());
      }

      ///<summary>
      /// Create a v3 EN
      ///</summary>
      public HL7Connect.Cda.EN newEN()
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().newEN());
      }

      ///<summary>
      /// Create a v3 EN that contains a single part of unknown type (plain text)
      ///</summary>
      public HL7Connect.Cda.EN newENPlain(string sValue)
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().newENPlain(sValue));
      }

      ///<summary>
      /// Create a v3 EN that contains a simple name with two parts, given and family. (if you want a different order, you'll have to build it by parts)
      ///</summary>
      public HL7Connect.Cda.EN newENSimple(string sGiven, string sFamily)
      {
        return HL7Connect.Cda.WrapperFactory.EN(wrapped().newENSimple(sGiven, sFamily));
      }

      ///<summary>
      /// Create a v3 INT
      ///</summary>
      public HL7Connect.Cda.INT newINT()
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().newINT());
      }

      ///<summary>
      /// Create a v3 INT
      ///</summary>
      public HL7Connect.Cda.INT newINTvalue(int iValue)
      {
        return HL7Connect.Cda.WrapperFactory.INT(wrapped().newINTvalue(iValue));
      }

      ///<summary>
      /// Create a v3 CO
      ///</summary>
      public HL7Connect.Cda.CO newCO()
      {
        return HL7Connect.Cda.WrapperFactory.CO(wrapped().newCO());
      }

      ///<summary>
      /// Create a v3 REAL
      ///</summary>
      public HL7Connect.Cda.REAL newREAL()
      {
        return HL7Connect.Cda.WrapperFactory.REAL(wrapped().newREAL());
      }

      ///<summary>
      /// Create a v3 RTO
      ///</summary>
      public HL7Connect.Cda.RTO newRTO()
      {
        return HL7Connect.Cda.WrapperFactory.RTO(wrapped().newRTO());
      }

      ///<summary>
      /// Create a v3 PQ
      ///</summary>
      public HL7Connect.Cda.PQ newPQ()
      {
        return HL7Connect.Cda.WrapperFactory.PQ(wrapped().newPQ());
      }

      ///<summary>
      /// Create a v3 PQ
      ///</summary>
      public HL7Connect.Cda.PQ newPQValue(HL7Connect.Ucum.QDecimal rValue, string sUnit)
      {
        return HL7Connect.Cda.WrapperFactory.PQ(wrapped().newPQValue(rValue.wrapped(), sUnit));
      }

      ///<summary>
      /// Create a v3 PQR
      ///</summary>
      public HL7Connect.Cda.PQR newPQR()
      {
        return HL7Connect.Cda.WrapperFactory.PQR(wrapped().newPQR());
      }

      ///<summary>
      /// Create a v3 MO
      ///</summary>
      public HL7Connect.Cda.MO newMO()
      {
        return HL7Connect.Cda.WrapperFactory.MO(wrapped().newMO());
      }

      ///<summary>
      /// Create a v3 MO
      ///</summary>
      public HL7Connect.Cda.MO newMOValue(HL7Connect.Ucum.QDecimal rValue, string sCurrency)
      {
        return HL7Connect.Cda.WrapperFactory.MO(wrapped().newMOValue(rValue.wrapped(), sCurrency));
      }

      ///<summary>
      /// Create a v3 TS
      ///</summary>
      public HL7Connect.Cda.TS newTS()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().newTS());
      }

      ///<summary>
      /// Create a v3 TS
      ///</summary>
      public HL7Connect.Cda.TS newTSValue(string sDateTime)
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().newTSValue(sDateTime));
      }

      ///<summary>
      /// Create a v3 QSU
      ///</summary>
      public HL7Connect.Cda.QSU<T> newQSU<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.QSU<T>(wrapped().newQSU(sType));
      }

      ///<summary>
      /// Create a v3 QSI
      ///</summary>
      public HL7Connect.Cda.QSI<T> newQSI<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.QSI<T>(wrapped().newQSI(sType));
      }

      ///<summary>
      /// Create a v3 QSD
      ///</summary>
      public HL7Connect.Cda.QSD<T> newQSD<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.QSD<T>(wrapped().newQSD(sType));
      }

      ///<summary>
      /// Create a v3 QSP
      ///</summary>
      public HL7Connect.Cda.QSP<T> newQSP<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.QSP<T>(wrapped().newQSP(sType));
      }

      ///<summary>
      /// Create a v3 QSS
      ///</summary>
      public HL7Connect.Cda.QSS<T> newQSS<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.QSS<T>(wrapped().newQSS(sType));
      }

      ///<summary>
      /// Create a v3 QSC
      ///</summary>
      public HL7Connect.Cda.QSC<T> newQSC<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.QSC<T>(wrapped().newQSC(sType));
      }

      ///<summary>
      /// Create a v3 IVL
      ///</summary>
      public HL7Connect.Cda.IVL<T> newIVL<T>(string sType) where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.IVL<T>(wrapped().newIVL(sType));
      }

      ///<summary>
      /// Create a v3 PIVL
      ///</summary>
      public HL7Connect.Cda.PIVL<T> newPIVL<T>() where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.PIVL<T>(wrapped().newPIVL());
      }

      ///<summary>
      /// Create a v3 EIVL
      ///</summary>
      public HL7Connect.Cda.EIVL<T> newEIVL<T>() where T : HL7Connect.Cda.QTY
      {
        return HL7Connect.Cda.WrapperFactory.EIVL<T>(wrapped().newEIVL());
      }

      ///<summary>
      /// Create a v3 UVP
      ///</summary>
      public HL7Connect.Cda.UVP newUVP()
      {
        return HL7Connect.Cda.WrapperFactory.UVP(wrapped().newUVP());
      }

      ///<summary>
      /// Create a v3 NPPD
      ///</summary>
      public HL7Connect.Cda.NPPD newNPPD()
      {
        return HL7Connect.Cda.WrapperFactory.NPPD(wrapped().newNPPD());
      }

      ///<summary>
      /// Create a IsnText
      ///</summary>
      public HL7Connect.Cda.SDText newText()
      {
        return HL7Connect.Cda.WrapperFactory.SDText(wrapped().newText());
      }

      ///<summary>
      /// Create a IsnTitle
      ///</summary>
      public HL7Connect.Cda.SDTitle newTitle()
      {
        return HL7Connect.Cda.WrapperFactory.SDTitle(wrapped().newTitle());
      }

      ///<summary>
      /// Create a Narrative CMFootnotes
      ///</summary>
      public HL7Connect.Cda.CMFootnotes newCMFootnotes()
      {
        return HL7Connect.Cda.WrapperFactory.CMFootnotes(wrapped().newCMFootnotes());
      }

      ///<summary>
      /// Create a Narrative CMInline
      ///</summary>
      public HL7Connect.Cda.CMInline newCMInline()
      {
        return HL7Connect.Cda.WrapperFactory.CMInline(wrapped().newCMInline());
      }

      ///<summary>
      /// Create a Narrative CMTitle
      ///</summary>
      public HL7Connect.Cda.CMTitle newCMTitle()
      {
        return HL7Connect.Cda.WrapperFactory.CMTitle(wrapped().newCMTitle());
      }

      ///<summary>
      /// Create a Narrative CMContent
      ///</summary>
      public HL7Connect.Cda.CMContent newCMContent()
      {
        return HL7Connect.Cda.WrapperFactory.CMContent(wrapped().newCMContent());
      }

      ///<summary>
      /// Create a Narrative CMGeneral
      ///</summary>
      public HL7Connect.Cda.CMGeneral newCMGeneral()
      {
        return HL7Connect.Cda.WrapperFactory.CMGeneral(wrapped().newCMGeneral());
      }

      ///<summary>
      /// Create a Narrative RenderMultiMedia
      ///</summary>
      public HL7Connect.Cda.RenderMultiMedia newRenderMultiMedia()
      {
        return HL7Connect.Cda.WrapperFactory.RenderMultiMedia(wrapped().newRenderMultiMedia());
      }

      ///<summary>
      /// Create a Narrative LinkHtml
      ///</summary>
      public HL7Connect.Cda.LinkHtml newLinkHtml()
      {
        return HL7Connect.Cda.WrapperFactory.LinkHtml(wrapped().newLinkHtml());
      }

      ///<summary>
      /// Create a Narrative Footnote
      ///</summary>
      public HL7Connect.Cda.Footnote newFootnote()
      {
        return HL7Connect.Cda.WrapperFactory.Footnote(wrapped().newFootnote());
      }

      ///<summary>
      /// Create a Narrative TitleFootnote
      ///</summary>
      public HL7Connect.Cda.TitleFootnote newTitleFootnote()
      {
        return HL7Connect.Cda.WrapperFactory.TitleFootnote(wrapped().newTitleFootnote());
      }

      ///<summary>
      /// Create a Narrative FootnoteRef
      ///</summary>
      public HL7Connect.Cda.FootnoteRef newFootnoteRef()
      {
        return HL7Connect.Cda.WrapperFactory.FootnoteRef(wrapped().newFootnoteRef());
      }

      ///<summary>
      /// Create a Narrative Caption
      ///</summary>
      public HL7Connect.Cda.Caption newCaption()
      {
        return HL7Connect.Cda.WrapperFactory.Caption(wrapped().newCaption());
      }

      ///<summary>
      /// Create a Narrative Content
      ///</summary>
      public HL7Connect.Cda.Content newContent()
      {
        return HL7Connect.Cda.WrapperFactory.Content(wrapped().newContent());
      }

      ///<summary>
      /// Create a Narrative Captioned
      ///</summary>
      public HL7Connect.Cda.Captioned newCaptioned()
      {
        return HL7Connect.Cda.WrapperFactory.Captioned(wrapped().newCaptioned());
      }

      ///<summary>
      /// Create a Narrative Paragraph
      ///</summary>
      public HL7Connect.Cda.Paragraph newParagraph()
      {
        return HL7Connect.Cda.WrapperFactory.Paragraph(wrapped().newParagraph());
      }

      ///<summary>
      /// Create a Narrative Item
      ///</summary>
      public HL7Connect.Cda.Item newItem()
      {
        return HL7Connect.Cda.WrapperFactory.Item(wrapped().newItem());
      }

      ///<summary>
      /// Create a Narrative List
      ///</summary>
      public HL7Connect.Cda.List newList()
      {
        return HL7Connect.Cda.WrapperFactory.List(wrapped().newList());
      }

      ///<summary>
      /// Create a Narrative TableItem
      ///</summary>
      public HL7Connect.Cda.TableItem newTableItem()
      {
        return HL7Connect.Cda.WrapperFactory.TableItem(wrapped().newTableItem());
      }

      ///<summary>
      /// Create a Narrative ColItem
      ///</summary>
      public HL7Connect.Cda.ColItem newColItem()
      {
        return HL7Connect.Cda.WrapperFactory.ColItem(wrapped().newColItem());
      }

      ///<summary>
      /// Create a Narrative Col
      ///</summary>
      public HL7Connect.Cda.Col newCol()
      {
        return HL7Connect.Cda.WrapperFactory.Col(wrapped().newCol());
      }

      ///<summary>
      /// Create a Narrative ColGroup
      ///</summary>
      public HL7Connect.Cda.ColGroup newColGroup()
      {
        return HL7Connect.Cda.WrapperFactory.ColGroup(wrapped().newColGroup());
      }

      ///<summary>
      /// Create a Narrative TCell
      ///</summary>
      public HL7Connect.Cda.TCell newTCell()
      {
        return HL7Connect.Cda.WrapperFactory.TCell(wrapped().newTCell());
      }

      ///<summary>
      /// Create a Narrative TRowPart
      ///</summary>
      public HL7Connect.Cda.TRowPart newTRowPart()
      {
        return HL7Connect.Cda.WrapperFactory.TRowPart(wrapped().newTRowPart());
      }

      ///<summary>
      /// Create a Narrative TRow
      ///</summary>
      public HL7Connect.Cda.TRow newTRow()
      {
        return HL7Connect.Cda.WrapperFactory.TRow(wrapped().newTRow());
      }

      ///<summary>
      /// Create a Narrative TRowGroup
      ///</summary>
      public HL7Connect.Cda.TRowGroup newTRowGroup()
      {
        return HL7Connect.Cda.WrapperFactory.TRowGroup(wrapped().newTRowGroup());
      }

      ///<summary>
      /// Create a Narrative Table
      ///</summary>
      public HL7Connect.Cda.Table newTable()
      {
        return HL7Connect.Cda.WrapperFactory.Table(wrapped().newTable());
      }

      ///<summary>
      /// Create a CDA Base
      ///</summary>
      public HL7Connect.Cda.CDABase newBase()
      {
        return HL7Connect.Cda.WrapperFactory.CDABase(wrapped().newBase());
      }

      ///<summary>
      /// Create a CDA Act
      ///</summary>
      public HL7Connect.Cda.Act newAct()
      {
        return HL7Connect.Cda.WrapperFactory.Act(wrapped().newAct());
      }

      ///<summary>
      /// Create a CDA AssignedAuthor
      ///</summary>
      public HL7Connect.Cda.AssignedAuthor newAssignedAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedAuthor(wrapped().newAssignedAuthor());
      }

      ///<summary>
      /// Create a CDA AssignedCustodian
      ///</summary>
      public HL7Connect.Cda.AssignedCustodian newAssignedCustodian()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedCustodian(wrapped().newAssignedCustodian());
      }

      ///<summary>
      /// Create a CDA AssignedEntity
      ///</summary>
      public HL7Connect.Cda.AssignedEntity newAssignedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped().newAssignedEntity());
      }

      ///<summary>
      /// Create a CDA AssociatedEntity
      ///</summary>
      public HL7Connect.Cda.AssociatedEntity newAssociatedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.AssociatedEntity(wrapped().newAssociatedEntity());
      }

      ///<summary>
      /// Create a CDA Authenticator
      ///</summary>
      public HL7Connect.Cda.Authenticator newAuthenticator()
      {
        return HL7Connect.Cda.WrapperFactory.Authenticator(wrapped().newAuthenticator());
      }

      ///<summary>
      /// Create a CDA Author
      ///</summary>
      public HL7Connect.Cda.Author newAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.Author(wrapped().newAuthor());
      }

      ///<summary>
      /// Create a CDA AuthoringDevice
      ///</summary>
      public HL7Connect.Cda.AuthoringDevice newAuthoringDevice()
      {
        return HL7Connect.Cda.WrapperFactory.AuthoringDevice(wrapped().newAuthoringDevice());
      }

      ///<summary>
      /// Create a CDA Authorization
      ///</summary>
      public HL7Connect.Cda.Authorization newAuthorization()
      {
        return HL7Connect.Cda.WrapperFactory.Authorization(wrapped().newAuthorization());
      }

      ///<summary>
      /// Create a CDA Birthplace
      ///</summary>
      public HL7Connect.Cda.Birthplace newBirthplace()
      {
        return HL7Connect.Cda.WrapperFactory.Birthplace(wrapped().newBirthplace());
      }

      ///<summary>
      /// Create a CDA ClinicalDocument
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument newClinicalDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().newClinicalDocument());
      }

      ///<summary>
      /// Create a CDA Component1
      ///</summary>
      public HL7Connect.Cda.Component1 newComponent1()
      {
        return HL7Connect.Cda.WrapperFactory.Component1(wrapped().newComponent1());
      }

      ///<summary>
      /// Create a CDA Component2
      ///</summary>
      public HL7Connect.Cda.Component2 newComponent2()
      {
        return HL7Connect.Cda.WrapperFactory.Component2(wrapped().newComponent2());
      }

      ///<summary>
      /// Create a CDA Component3
      ///</summary>
      public HL7Connect.Cda.Component3 newComponent3()
      {
        return HL7Connect.Cda.WrapperFactory.Component3(wrapped().newComponent3());
      }

      ///<summary>
      /// Create a CDA Component4
      ///</summary>
      public HL7Connect.Cda.Component4 newComponent4()
      {
        return HL7Connect.Cda.WrapperFactory.Component4(wrapped().newComponent4());
      }

      ///<summary>
      /// Create a CDA Component5
      ///</summary>
      public HL7Connect.Cda.Component5 newComponent5()
      {
        return HL7Connect.Cda.WrapperFactory.Component5(wrapped().newComponent5());
      }

      ///<summary>
      /// Create a CDA Consent
      ///</summary>
      public HL7Connect.Cda.Consent newConsent()
      {
        return HL7Connect.Cda.WrapperFactory.Consent(wrapped().newConsent());
      }

      ///<summary>
      /// Create a CDA Consumable
      ///</summary>
      public HL7Connect.Cda.Consumable newConsumable()
      {
        return HL7Connect.Cda.WrapperFactory.Consumable(wrapped().newConsumable());
      }

      ///<summary>
      /// Create a CDA Criterion
      ///</summary>
      public HL7Connect.Cda.Criterion newCriterion()
      {
        return HL7Connect.Cda.WrapperFactory.Criterion(wrapped().newCriterion());
      }

      ///<summary>
      /// Create a CDA Custodian
      ///</summary>
      public HL7Connect.Cda.Custodian newCustodian()
      {
        return HL7Connect.Cda.WrapperFactory.Custodian(wrapped().newCustodian());
      }

      ///<summary>
      /// Create a CDA CustodianOrganization
      ///</summary>
      public HL7Connect.Cda.CustodianOrganization newCustodianOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.CustodianOrganization(wrapped().newCustodianOrganization());
      }

      ///<summary>
      /// Create a CDA DataEnterer
      ///</summary>
      public HL7Connect.Cda.DataEnterer newDataEnterer()
      {
        return HL7Connect.Cda.WrapperFactory.DataEnterer(wrapped().newDataEnterer());
      }

      ///<summary>
      /// Create a CDA Device
      ///</summary>
      public HL7Connect.Cda.Device newDevice()
      {
        return HL7Connect.Cda.WrapperFactory.Device(wrapped().newDevice());
      }

      ///<summary>
      /// Create a CDA DocumentationOf
      ///</summary>
      public HL7Connect.Cda.DocumentationOf newDocumentationOf()
      {
        return HL7Connect.Cda.WrapperFactory.DocumentationOf(wrapped().newDocumentationOf());
      }

      ///<summary>
      /// Create a CDA EncompassingEncounter
      ///</summary>
      public HL7Connect.Cda.EncompassingEncounter newEncompassingEncounter()
      {
        return HL7Connect.Cda.WrapperFactory.EncompassingEncounter(wrapped().newEncompassingEncounter());
      }

      ///<summary>
      /// Create a CDA Encounter
      ///</summary>
      public HL7Connect.Cda.Encounter newEncounter()
      {
        return HL7Connect.Cda.WrapperFactory.Encounter(wrapped().newEncounter());
      }

      ///<summary>
      /// Create a CDA EncounterParticipant
      ///</summary>
      public HL7Connect.Cda.EncounterParticipant newEncounterParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.EncounterParticipant(wrapped().newEncounterParticipant());
      }

      ///<summary>
      /// Create a CDA Entity
      ///</summary>
      public HL7Connect.Cda.Entity newEntity()
      {
        return HL7Connect.Cda.WrapperFactory.Entity(wrapped().newEntity());
      }

      ///<summary>
      /// Create a CDA Entry
      ///</summary>
      public HL7Connect.Cda.Entry newEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().newEntry());
      }

      ///<summary>
      /// Create a CDA EntryRelationship
      ///</summary>
      public HL7Connect.Cda.EntryRelationship newEntryRelationship()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationship(wrapped().newEntryRelationship());
      }

      ///<summary>
      /// Create a CDA ExternalAct
      ///</summary>
      public HL7Connect.Cda.ExternalAct newExternalAct()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalAct(wrapped().newExternalAct());
      }

      ///<summary>
      /// Create a CDA ExternalDocument
      ///</summary>
      public HL7Connect.Cda.ExternalDocument newExternalDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalDocument(wrapped().newExternalDocument());
      }

      ///<summary>
      /// Create a CDA ExternalObservation
      ///</summary>
      public HL7Connect.Cda.ExternalObservation newExternalObservation()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalObservation(wrapped().newExternalObservation());
      }

      ///<summary>
      /// Create a CDA ExternalProcedure
      ///</summary>
      public HL7Connect.Cda.ExternalProcedure newExternalProcedure()
      {
        return HL7Connect.Cda.WrapperFactory.ExternalProcedure(wrapped().newExternalProcedure());
      }

      ///<summary>
      /// Create a CDA Guardian
      ///</summary>
      public HL7Connect.Cda.Guardian newGuardian()
      {
        return HL7Connect.Cda.WrapperFactory.Guardian(wrapped().newGuardian());
      }

      ///<summary>
      /// Create a CDA HealthCareFacility
      ///</summary>
      public HL7Connect.Cda.HealthCareFacility newHealthCareFacility()
      {
        return HL7Connect.Cda.WrapperFactory.HealthCareFacility(wrapped().newHealthCareFacility());
      }

      ///<summary>
      /// Create a CDA Informant12
      ///</summary>
      public HL7Connect.Cda.Informant12 newInformant12()
      {
        return HL7Connect.Cda.WrapperFactory.Informant12(wrapped().newInformant12());
      }

      ///<summary>
      /// Create a CDA InformationRecipient
      ///</summary>
      public HL7Connect.Cda.InformationRecipient newInformationRecipient()
      {
        return HL7Connect.Cda.WrapperFactory.InformationRecipient(wrapped().newInformationRecipient());
      }

      ///<summary>
      /// Create a CDA InFulfillmentOf
      ///</summary>
      public HL7Connect.Cda.InFulfillmentOf newInFulfillmentOf()
      {
        return HL7Connect.Cda.WrapperFactory.InFulfillmentOf(wrapped().newInFulfillmentOf());
      }

      ///<summary>
      /// Create a CDA IntendedRecipient
      ///</summary>
      public HL7Connect.Cda.IntendedRecipient newIntendedRecipient()
      {
        return HL7Connect.Cda.WrapperFactory.IntendedRecipient(wrapped().newIntendedRecipient());
      }

      ///<summary>
      /// Create a CDA LabeledDrug
      ///</summary>
      public HL7Connect.Cda.LabeledDrug newLabeledDrug()
      {
        return HL7Connect.Cda.WrapperFactory.LabeledDrug(wrapped().newLabeledDrug());
      }

      ///<summary>
      /// Create a CDA LanguageCommunication
      ///</summary>
      public HL7Connect.Cda.LanguageCommunication newLanguageCommunication()
      {
        return HL7Connect.Cda.WrapperFactory.LanguageCommunication(wrapped().newLanguageCommunication());
      }

      ///<summary>
      /// Create a CDA LegalAuthenticator
      ///</summary>
      public HL7Connect.Cda.LegalAuthenticator newLegalAuthenticator()
      {
        return HL7Connect.Cda.WrapperFactory.LegalAuthenticator(wrapped().newLegalAuthenticator());
      }

      ///<summary>
      /// Create a CDA Location
      ///</summary>
      public HL7Connect.Cda.Location newLocation()
      {
        return HL7Connect.Cda.WrapperFactory.Location(wrapped().newLocation());
      }

      ///<summary>
      /// Create a CDA MaintainedEntity
      ///</summary>
      public HL7Connect.Cda.MaintainedEntity newMaintainedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.MaintainedEntity(wrapped().newMaintainedEntity());
      }

      ///<summary>
      /// Create a CDA ManufacturedProduct
      ///</summary>
      public HL7Connect.Cda.ManufacturedProduct newManufacturedProduct()
      {
        return HL7Connect.Cda.WrapperFactory.ManufacturedProduct(wrapped().newManufacturedProduct());
      }

      ///<summary>
      /// Create a CDA Material
      ///</summary>
      public HL7Connect.Cda.Material newMaterial()
      {
        return HL7Connect.Cda.WrapperFactory.Material(wrapped().newMaterial());
      }

      ///<summary>
      /// Create a CDA NonXMLBody
      ///</summary>
      public HL7Connect.Cda.NonXMLBody newNonXMLBody()
      {
        return HL7Connect.Cda.WrapperFactory.NonXMLBody(wrapped().newNonXMLBody());
      }

      ///<summary>
      /// Create a CDA Observation
      ///</summary>
      public HL7Connect.Cda.Observation newObservation()
      {
        return HL7Connect.Cda.WrapperFactory.Observation(wrapped().newObservation());
      }

      ///<summary>
      /// Create a CDA ObservationMedia
      ///</summary>
      public HL7Connect.Cda.ObservationMedia newObservationMedia()
      {
        return HL7Connect.Cda.WrapperFactory.ObservationMedia(wrapped().newObservationMedia());
      }

      ///<summary>
      /// Create a CDA ObservationRange
      ///</summary>
      public HL7Connect.Cda.ObservationRange newObservationRange()
      {
        return HL7Connect.Cda.WrapperFactory.ObservationRange(wrapped().newObservationRange());
      }

      ///<summary>
      /// Create a CDA Order
      ///</summary>
      public HL7Connect.Cda.Order newOrder()
      {
        return HL7Connect.Cda.WrapperFactory.Order(wrapped().newOrder());
      }

      ///<summary>
      /// Create a CDA Organization
      ///</summary>
      public HL7Connect.Cda.Organization newOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().newOrganization());
      }

      ///<summary>
      /// Create a CDA OrganizationPartOf
      ///</summary>
      public HL7Connect.Cda.OrganizationPartOf newOrganizationPartOf()
      {
        return HL7Connect.Cda.WrapperFactory.OrganizationPartOf(wrapped().newOrganizationPartOf());
      }

      ///<summary>
      /// Create a CDA Organizer
      ///</summary>
      public HL7Connect.Cda.Organizer newOrganizer()
      {
        return HL7Connect.Cda.WrapperFactory.Organizer(wrapped().newOrganizer());
      }

      ///<summary>
      /// Create a CDA ParentDocument
      ///</summary>
      public HL7Connect.Cda.ParentDocument newParentDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ParentDocument(wrapped().newParentDocument());
      }

      ///<summary>
      /// Create a CDA Participant1
      ///</summary>
      public HL7Connect.Cda.Participant1 newParticipant1()
      {
        return HL7Connect.Cda.WrapperFactory.Participant1(wrapped().newParticipant1());
      }

      ///<summary>
      /// Create a CDA Participant2
      ///</summary>
      public HL7Connect.Cda.Participant2 newParticipant2()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2(wrapped().newParticipant2());
      }

      ///<summary>
      /// Create a CDA ParticipantRole
      ///</summary>
      public HL7Connect.Cda.ParticipantRole newParticipantRole()
      {
        return HL7Connect.Cda.WrapperFactory.ParticipantRole(wrapped().newParticipantRole());
      }

      ///<summary>
      /// Create a CDA Patient
      ///</summary>
      public HL7Connect.Cda.Patient newPatient()
      {
        return HL7Connect.Cda.WrapperFactory.Patient(wrapped().newPatient());
      }

      ///<summary>
      /// Create a CDA PatientRole
      ///</summary>
      public HL7Connect.Cda.PatientRole newPatientRole()
      {
        return HL7Connect.Cda.WrapperFactory.PatientRole(wrapped().newPatientRole());
      }

      ///<summary>
      /// Create a CDA Performer1
      ///</summary>
      public HL7Connect.Cda.Performer1 newPerformer1()
      {
        return HL7Connect.Cda.WrapperFactory.Performer1(wrapped().newPerformer1());
      }

      ///<summary>
      /// Create a CDA Performer2
      ///</summary>
      public HL7Connect.Cda.Performer2 newPerformer2()
      {
        return HL7Connect.Cda.WrapperFactory.Performer2(wrapped().newPerformer2());
      }

      ///<summary>
      /// Create a CDA Person
      ///</summary>
      public HL7Connect.Cda.Person newPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().newPerson());
      }

      ///<summary>
      /// Create a CDA Place
      ///</summary>
      public HL7Connect.Cda.Place newPlace()
      {
        return HL7Connect.Cda.WrapperFactory.Place(wrapped().newPlace());
      }

      ///<summary>
      /// Create a CDA PlayingEntity
      ///</summary>
      public HL7Connect.Cda.PlayingEntity newPlayingEntity()
      {
        return HL7Connect.Cda.WrapperFactory.PlayingEntity(wrapped().newPlayingEntity());
      }

      ///<summary>
      /// Create a CDA Precondition
      ///</summary>
      public HL7Connect.Cda.Precondition newPrecondition()
      {
        return HL7Connect.Cda.WrapperFactory.Precondition(wrapped().newPrecondition());
      }

      ///<summary>
      /// Create a CDA Procedure
      ///</summary>
      public HL7Connect.Cda.Procedure newProcedure()
      {
        return HL7Connect.Cda.WrapperFactory.Procedure(wrapped().newProcedure());
      }

      ///<summary>
      /// Create a CDA Product
      ///</summary>
      public HL7Connect.Cda.Product newProduct()
      {
        return HL7Connect.Cda.WrapperFactory.Product(wrapped().newProduct());
      }

      ///<summary>
      /// Create a CDA RecordTarget
      ///</summary>
      public HL7Connect.Cda.RecordTarget newRecordTarget()
      {
        return HL7Connect.Cda.WrapperFactory.RecordTarget(wrapped().newRecordTarget());
      }

      ///<summary>
      /// Create a CDA Reference
      ///</summary>
      public HL7Connect.Cda.Reference newReference()
      {
        return HL7Connect.Cda.WrapperFactory.Reference(wrapped().newReference());
      }

      ///<summary>
      /// Create a CDA ReferenceRange
      ///</summary>
      public HL7Connect.Cda.ReferenceRange newReferenceRange()
      {
        return HL7Connect.Cda.WrapperFactory.ReferenceRange(wrapped().newReferenceRange());
      }

      ///<summary>
      /// Create a CDA RegionOfInterest_value
      ///</summary>
      public HL7Connect.Cda.RegionOfInterest_value newRegionOfInterest_value()
      {
        return HL7Connect.Cda.WrapperFactory.RegionOfInterest_value(wrapped().newRegionOfInterest_value());
      }

      ///<summary>
      /// Create a CDA RegionOfInterest
      ///</summary>
      public HL7Connect.Cda.RegionOfInterest newRegionOfInterest()
      {
        return HL7Connect.Cda.WrapperFactory.RegionOfInterest(wrapped().newRegionOfInterest());
      }

      ///<summary>
      /// Create a CDA RelatedDocument
      ///</summary>
      public HL7Connect.Cda.RelatedDocument newRelatedDocument()
      {
        return HL7Connect.Cda.WrapperFactory.RelatedDocument(wrapped().newRelatedDocument());
      }

      ///<summary>
      /// Create a CDA RelatedEntity
      ///</summary>
      public HL7Connect.Cda.RelatedEntity newRelatedEntity()
      {
        return HL7Connect.Cda.WrapperFactory.RelatedEntity(wrapped().newRelatedEntity());
      }

      ///<summary>
      /// Create a CDA RelatedSubject
      ///</summary>
      public HL7Connect.Cda.RelatedSubject newRelatedSubject()
      {
        return HL7Connect.Cda.WrapperFactory.RelatedSubject(wrapped().newRelatedSubject());
      }

      ///<summary>
      /// Create a CDA ResponsibleParty
      ///</summary>
      public HL7Connect.Cda.ResponsibleParty newResponsibleParty()
      {
        return HL7Connect.Cda.WrapperFactory.ResponsibleParty(wrapped().newResponsibleParty());
      }

      ///<summary>
      /// Create a CDA Section
      ///</summary>
      public HL7Connect.Cda.Section newSection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().newSection());
      }

      ///<summary>
      /// Create a CDA ServiceEvent
      ///</summary>
      public HL7Connect.Cda.ServiceEvent newServiceEvent()
      {
        return HL7Connect.Cda.WrapperFactory.ServiceEvent(wrapped().newServiceEvent());
      }

      ///<summary>
      /// Create a CDA Specimen
      ///</summary>
      public HL7Connect.Cda.Specimen newSpecimen()
      {
        return HL7Connect.Cda.WrapperFactory.Specimen(wrapped().newSpecimen());
      }

      ///<summary>
      /// Create a CDA SpecimenRole
      ///</summary>
      public HL7Connect.Cda.SpecimenRole newSpecimenRole()
      {
        return HL7Connect.Cda.WrapperFactory.SpecimenRole(wrapped().newSpecimenRole());
      }

      ///<summary>
      /// Create a CDA StructuredBody
      ///</summary>
      public HL7Connect.Cda.StructuredBody newStructuredBody()
      {
        return HL7Connect.Cda.WrapperFactory.StructuredBody(wrapped().newStructuredBody());
      }

      ///<summary>
      /// Create a CDA Subject
      ///</summary>
      public HL7Connect.Cda.Subject newSubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().newSubject());
      }

      ///<summary>
      /// Create a CDA SubjectPerson
      ///</summary>
      public HL7Connect.Cda.SubjectPerson newSubjectPerson()
      {
        return HL7Connect.Cda.WrapperFactory.SubjectPerson(wrapped().newSubjectPerson());
      }

      ///<summary>
      /// Create a CDA SubstanceAdministration
      ///</summary>
      public HL7Connect.Cda.SubstanceAdministration newSubstanceAdministration()
      {
        return HL7Connect.Cda.WrapperFactory.SubstanceAdministration(wrapped().newSubstanceAdministration());
      }

      ///<summary>
      /// Create a CDA Supply
      ///</summary>
      public HL7Connect.Cda.Supply newSupply()
      {
        return HL7Connect.Cda.WrapperFactory.Supply(wrapped().newSupply());
      }

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromString(string value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromString(value));
      }

      ///<summary>
      /// Create a Decimal from an integer. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromInteger(long value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromInteger(value));
      }

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromReal(double value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromReal(value));
      }

      ///<summary>
      /// Create a Decimal from a string representation. You can provide any valid number, either in decimal or scientific form. There is no limit to the value or number of significant figures
      ///</summary>
      public HL7Connect.Ucum.QDecimal CreateDecimalFromCOMDecimal(decimal value)
      {
        return HL7Connect.Ucum.WrapperFactory.QDecimal(wrapped().CreateDecimalFromCOMDecimal(value));
      }

    }

    internal class WrapperFactory
    {
      private static Factory fWorkingFactory;
      internal static Factory WorkingFactory
      {
        get
        {
          if (fWorkingFactory == null)
            throw new Exception("You must set HL7Connect.Cda.WrapperFactory.WorkingFactory before using direct constructors of Cda classes");
          return fWorkingFactory;
        }
        set
        {
          fWorkingFactory = value;
        }
      }
      internal static HL7Connect.Cda.Base Base(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3DataValue)
          return /*4*/HL7Connect.Cda.WrapperFactory.DataValue(wrapped);
        else if (wrapped is HCsnCMFootnotes)
          return /*4*/HL7Connect.Cda.WrapperFactory.CMFootnotes(wrapped);
        else if (wrapped is HCsnTRowPart)
          return /*4*/HL7Connect.Cda.WrapperFactory.TRowPart(wrapped);
        else if (wrapped is HCcdaBase)
          return /*4*/HL7Connect.Cda.WrapperFactory.CDABase(wrapped);
        else
          return new HL7Connect.Cda.Base((Iv3Base) wrapped);
      }

      internal static HL7Connect.Cda.BaseList BaseList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.BaseList((Iv3BaseList) wrapped);
      }

      internal static HL7Connect.Cda.DataValue DataValue(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3HXIT)
          return /*4*/HL7Connect.Cda.WrapperFactory.HXIT(wrapped);
        else if (wrapped is HCv3XP)
          return /*4*/HL7Connect.Cda.WrapperFactory.XP(wrapped);
        else
          return new HL7Connect.Cda.DataValue((Iv3DataValue) wrapped);
      }

      internal static HL7Connect.Cda.HXIT HXIT(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3ANY)
          return /*4*/HL7Connect.Cda.WrapperFactory.ANY(wrapped);
        else
          return new HL7Connect.Cda.HXIT((Iv3HXIT) wrapped);
      }

      internal static HL7Connect.Cda.ANY ANY(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3BL)
          return /*4*/HL7Connect.Cda.WrapperFactory.BL(wrapped);
        else if (wrapped is HCv3ED)
          return /*4*/HL7Connect.Cda.WrapperFactory.ED(wrapped);
        else if (wrapped is HCv3ST)
          return /*4*/HL7Connect.Cda.WrapperFactory.ST(wrapped);
        else if (wrapped is HCv3CR)
          return /*4*/HL7Connect.Cda.WrapperFactory.CR(wrapped);
        else if (wrapped is HCv3CD)
          return /*4*/HL7Connect.Cda.WrapperFactory.CD(wrapped);
        else if (wrapped is HCv3CS)
          return /*4*/HL7Connect.Cda.WrapperFactory.CS(wrapped);
        else if (wrapped is HCv3TEL)
          return /*4*/HL7Connect.Cda.WrapperFactory.TEL(wrapped);
        else if (wrapped is HCv3II)
          return /*4*/HL7Connect.Cda.WrapperFactory.II(wrapped);
        else if (wrapped is HCv3AD)
          return /*4*/HL7Connect.Cda.WrapperFactory.AD(wrapped);
        else if (wrapped is HCv3EN)
          return /*4*/HL7Connect.Cda.WrapperFactory.EN(wrapped);
        else if (wrapped is HCv3QTY)
          return /*4*/HL7Connect.Cda.WrapperFactory.QTY(wrapped);
        else if (wrapped is HCv3QSET)
          return /*1*/HL7Connect.Cda.WrapperFactory.QSET<HL7Connect.Cda.QTY>(wrapped);
        else if (wrapped is HCv3UVP)
          return /*4*/HL7Connect.Cda.WrapperFactory.UVP(wrapped);
        else if (wrapped is HCv3NPPD)
          return /*4*/HL7Connect.Cda.WrapperFactory.NPPD(wrapped);
        else if (wrapped is HCsnText)
          return /*4*/HL7Connect.Cda.WrapperFactory.SDText(wrapped);
        else if (wrapped is HCsnTitle)
          return /*4*/HL7Connect.Cda.WrapperFactory.SDTitle(wrapped);
        else
          return new HL7Connect.Cda.ANY((Iv3ANY) wrapped);
      }

      internal static HL7Connect.Cda.BL BL(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.BL((Iv3BL) wrapped);
      }

      internal static HL7Connect.Cda.ED ED(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ED((Iv3ED) wrapped);
      }

      internal static HL7Connect.Cda.ST ST(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3SC)
          return /*4*/HL7Connect.Cda.WrapperFactory.SC(wrapped);
        else
          return new HL7Connect.Cda.ST((Iv3ST) wrapped);
      }

      internal static HL7Connect.Cda.SC SC(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SC((Iv3SC) wrapped);
      }

      internal static HL7Connect.Cda.CR CR(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CR((Iv3CR) wrapped);
      }

      internal static HL7Connect.Cda.CD CD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3PQR)
          return /*4*/HL7Connect.Cda.WrapperFactory.PQR(wrapped);
        else
          return new HL7Connect.Cda.CD((Iv3CD) wrapped);
      }

      internal static HL7Connect.Cda.CS CS(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CS((Iv3CS) wrapped);
      }

      internal static HL7Connect.Cda.TEL TEL(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TEL((Iv3TEL) wrapped);
      }

      internal static HL7Connect.Cda.II II(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.II((Iv3II) wrapped);
      }

      internal static HL7Connect.Cda.XP XP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3ADXP)
          return /*4*/HL7Connect.Cda.WrapperFactory.ADXP(wrapped);
        else if (wrapped is HCv3ENXP)
          return /*4*/HL7Connect.Cda.WrapperFactory.ENXP(wrapped);
        else
          return new HL7Connect.Cda.XP((Iv3XP) wrapped);
      }

      internal static HL7Connect.Cda.ADXP ADXP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ADXP((Iv3ADXP) wrapped);
      }

      internal static HL7Connect.Cda.AD AD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AD((Iv3AD) wrapped);
      }

      internal static HL7Connect.Cda.ENXP ENXP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ENXP((Iv3ENXP) wrapped);
      }

      internal static HL7Connect.Cda.EN EN(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EN((Iv3EN) wrapped);
      }

      internal static HL7Connect.Cda.QTY QTY(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3INT)
          return /*4*/HL7Connect.Cda.WrapperFactory.INT(wrapped);
        else if (wrapped is HCv3CO)
          return /*4*/HL7Connect.Cda.WrapperFactory.CO(wrapped);
        else if (wrapped is HCv3REAL)
          return /*4*/HL7Connect.Cda.WrapperFactory.REAL(wrapped);
        else if (wrapped is HCv3RTO)
          return /*4*/HL7Connect.Cda.WrapperFactory.RTO(wrapped);
        else if (wrapped is HCv3PQ)
          return /*4*/HL7Connect.Cda.WrapperFactory.PQ(wrapped);
        else if (wrapped is HCv3MO)
          return /*4*/HL7Connect.Cda.WrapperFactory.MO(wrapped);
        else if (wrapped is HCv3TS)
          return /*4*/HL7Connect.Cda.WrapperFactory.TS(wrapped);
        else
          return new HL7Connect.Cda.QTY((Iv3QTY) wrapped);
      }

      internal static HL7Connect.Cda.INT INT(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCcdaRegionOfInterest_value)
          return /*4*/HL7Connect.Cda.WrapperFactory.RegionOfInterest_value(wrapped);
        else
          return new HL7Connect.Cda.INT((Iv3INT) wrapped);
      }

      internal static HL7Connect.Cda.CO CO(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CO((Iv3CO) wrapped);
      }

      internal static HL7Connect.Cda.REAL REAL(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.REAL((Iv3REAL) wrapped);
      }

      internal static HL7Connect.Cda.RTO RTO(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RTO((Iv3RTO) wrapped);
      }

      internal static HL7Connect.Cda.PQ PQ(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.PQ((Iv3PQ) wrapped);
      }

      internal static HL7Connect.Cda.PQR PQR(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.PQR((Iv3PQR) wrapped);
      }

      internal static HL7Connect.Cda.MO MO(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.MO((Iv3MO) wrapped);
      }

      internal static HL7Connect.Cda.TS TS(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TS((Iv3TS) wrapped);
      }

      internal static HL7Connect.Cda.QSET<T> QSET<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCv3QSU)
          return /*4*/HL7Connect.Cda.WrapperFactory.QSU<T>(wrapped);
        else if (wrapped is HCv3QSI)
          return /*4*/HL7Connect.Cda.WrapperFactory.QSI<T>(wrapped);
        else if (wrapped is HCv3QSD)
          return /*4*/HL7Connect.Cda.WrapperFactory.QSD<T>(wrapped);
        else if (wrapped is HCv3QSP)
          return /*4*/HL7Connect.Cda.WrapperFactory.QSP<T>(wrapped);
        else if (wrapped is HCv3QSS)
          return /*4*/HL7Connect.Cda.WrapperFactory.QSS<T>(wrapped);
        else if (wrapped is HCv3QSC)
          return /*4*/HL7Connect.Cda.WrapperFactory.QSC<T>(wrapped);
        else if (wrapped is HCv3IVL)
          return /*4*/HL7Connect.Cda.WrapperFactory.IVL<T>(wrapped);
        else if (wrapped is HCv3PIVL)
          return /*4*/HL7Connect.Cda.WrapperFactory.PIVL<T>(wrapped);
        else if (wrapped is HCv3EIVL)
          return /*4*/HL7Connect.Cda.WrapperFactory.EIVL<T>(wrapped);
        else
          return new HL7Connect.Cda.QSET<T>((Iv3QSET) wrapped);
      }

      internal static HL7Connect.Cda.QSU<T> QSU<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.QSU<T>((Iv3QSU) wrapped);
      }

      internal static HL7Connect.Cda.QSI<T> QSI<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.QSI<T>((Iv3QSI) wrapped);
      }

      internal static HL7Connect.Cda.QSD<T> QSD<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.QSD<T>((Iv3QSD) wrapped);
      }

      internal static HL7Connect.Cda.QSP<T> QSP<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.QSP<T>((Iv3QSP) wrapped);
      }

      internal static HL7Connect.Cda.QSS<T> QSS<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.QSS<T>((Iv3QSS) wrapped);
      }

      internal static HL7Connect.Cda.QSC<T> QSC<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.QSC<T>((Iv3QSC) wrapped);
      }

      internal static HL7Connect.Cda.IVL<T> IVL<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.IVL<T>((Iv3IVL) wrapped);
      }

      internal static HL7Connect.Cda.PIVL<T> PIVL<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.PIVL<T>((Iv3PIVL) wrapped);
      }

      internal static HL7Connect.Cda.EIVL<T> EIVL<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EIVL<T>((Iv3EIVL) wrapped);
      }

      internal static HL7Connect.Cda.UVP UVP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.UVP((Iv3UVP) wrapped);
      }

      internal static HL7Connect.Cda.NPPD NPPD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.NPPD((Iv3NPPD) wrapped);
      }

      internal static HL7Connect.Cda.SetED SetED(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetED((Iv3SetED) wrapped);
      }

      internal static HL7Connect.Cda.SetST SetST(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetST((Iv3SetST) wrapped);
      }

      internal static HL7Connect.Cda.SetCD SetCD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetCD((Iv3SetCD) wrapped);
      }

      internal static HL7Connect.Cda.ListADXP ListADXP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListADXP((Iv3ListADXP) wrapped);
      }

      internal static HL7Connect.Cda.ListENXP ListENXP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListENXP((Iv3ListENXP) wrapped);
      }

      internal static HL7Connect.Cda.SetPQR SetPQR(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetPQR((Iv3SetPQR) wrapped);
      }

      internal static HL7Connect.Cda.SetQSET<T> SetQSET<T>(object wrapped) where T : HL7Connect.Cda.QTY
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetQSET<T>((Iv3SetQSET) wrapped);
      }

      internal static HL7Connect.Cda.SetQTY SetQTY(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetQTY((Iv3SetQTY) wrapped);
      }

      internal static HL7Connect.Cda.SetUVP SetUVP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SetUVP((Iv3SetUVP) wrapped);
      }

      internal static HL7Connect.Cda.ListCS ListCS(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListCS((Iv3ListCS) wrapped);
      }

      internal static HL7Connect.Cda.ListII ListII(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListII((Iv3ListII) wrapped);
      }

      internal static HL7Connect.Cda.ListAD ListAD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListAD((Iv3ListAD) wrapped);
      }

      internal static HL7Connect.Cda.ListTEL ListTEL(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListTEL((Iv3ListTEL) wrapped);
      }

      internal static HL7Connect.Cda.ListANY ListANY(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListANY((Iv3ListANY) wrapped);
      }

      internal static HL7Connect.Cda.ListCD ListCD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListCD((Iv3ListCD) wrapped);
      }

      internal static HL7Connect.Cda.ListEN ListEN(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListEN((Iv3ListEN) wrapped);
      }

      internal static HL7Connect.Cda.ListCR ListCR(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListCR((Iv3ListCR) wrapped);
      }

      internal static HL7Connect.Cda.ListPQ ListPQ(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ListPQ((Iv3ListPQ) wrapped);
      }

      internal static HL7Connect.Cda.SNBase SNBase(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnRenderMultiMedia)
          return /*4*/HL7Connect.Cda.WrapperFactory.RenderMultiMedia(wrapped);
        else if (wrapped is HCsnLinkHtml)
          return /*4*/HL7Connect.Cda.WrapperFactory.LinkHtml(wrapped);
        else if (wrapped is HCsnFootnote)
          return /*4*/HL7Connect.Cda.WrapperFactory.Footnote(wrapped);
        else if (wrapped is HCsnTitleFootnote)
          return /*4*/HL7Connect.Cda.WrapperFactory.TitleFootnote(wrapped);
        else if (wrapped is HCsnFootnoteRef)
          return /*4*/HL7Connect.Cda.WrapperFactory.FootnoteRef(wrapped);
        else if (wrapped is HCsnCaption)
          return /*4*/HL7Connect.Cda.WrapperFactory.Caption(wrapped);
        else if (wrapped is HCsnContent)
          return /*4*/HL7Connect.Cda.WrapperFactory.Content(wrapped);
        else if (wrapped is HCsnCaptioned)
          return /*4*/HL7Connect.Cda.WrapperFactory.Captioned(wrapped);
        else if (wrapped is HCsnTableItem)
          return /*4*/HL7Connect.Cda.WrapperFactory.TableItem(wrapped);
        else
          return new HL7Connect.Cda.SNBase((IsnBase) wrapped);
      }

      internal static HL7Connect.Cda.SDText SDText(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SDText((IsnText) wrapped);
      }

      internal static HL7Connect.Cda.SDTitle SDTitle(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SDTitle((IsnTitle) wrapped);
      }

      internal static HL7Connect.Cda.CMFootnotes CMFootnotes(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnCMInline)
          return /*4*/HL7Connect.Cda.WrapperFactory.CMInline(wrapped);
        else
          return new HL7Connect.Cda.CMFootnotes((IsnCMFootnotes) wrapped);
      }

      internal static HL7Connect.Cda.CMInline CMInline(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnCMContent)
          return /*4*/HL7Connect.Cda.WrapperFactory.CMContent(wrapped);
        else
          return new HL7Connect.Cda.CMInline((IsnCMInline) wrapped);
      }

      internal static HL7Connect.Cda.CMTitle CMTitle(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMTitle((IsnCMTitle) wrapped);
      }

      internal static HL7Connect.Cda.CMContent CMContent(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnCMGeneral)
          return /*4*/HL7Connect.Cda.WrapperFactory.CMGeneral(wrapped);
        else
          return new HL7Connect.Cda.CMContent((IsnCMContent) wrapped);
      }

      internal static HL7Connect.Cda.CMGeneral CMGeneral(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMGeneral((IsnCMGeneral) wrapped);
      }

      internal static HL7Connect.Cda.RenderMultiMedia RenderMultiMedia(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RenderMultiMedia((IsnRenderMultiMedia) wrapped);
      }

      internal static HL7Connect.Cda.LinkHtml LinkHtml(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.LinkHtml((IsnLinkHtml) wrapped);
      }

      internal static HL7Connect.Cda.Footnote Footnote(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Footnote((IsnFootnote) wrapped);
      }

      internal static HL7Connect.Cda.TitleFootnote TitleFootnote(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TitleFootnote((IsnTitleFootnote) wrapped);
      }

      internal static HL7Connect.Cda.FootnoteRef FootnoteRef(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.FootnoteRef((IsnFootnoteRef) wrapped);
      }

      internal static HL7Connect.Cda.Caption Caption(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Caption((IsnCaption) wrapped);
      }

      internal static HL7Connect.Cda.Content Content(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Content((IsnContent) wrapped);
      }

      internal static HL7Connect.Cda.Captioned Captioned(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnParagraph)
          return /*4*/HL7Connect.Cda.WrapperFactory.Paragraph(wrapped);
        else if (wrapped is HCsnItem)
          return /*4*/HL7Connect.Cda.WrapperFactory.Item(wrapped);
        else if (wrapped is HCsnList)
          return /*4*/HL7Connect.Cda.WrapperFactory.List(wrapped);
        else if (wrapped is HCsnTable)
          return /*4*/HL7Connect.Cda.WrapperFactory.Table(wrapped);
        else
          return new HL7Connect.Cda.Captioned((IsnCaptioned) wrapped);
      }

      internal static HL7Connect.Cda.Paragraph Paragraph(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Paragraph((IsnParagraph) wrapped);
      }

      internal static HL7Connect.Cda.Item Item(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Item((IsnItem) wrapped);
      }

      internal static HL7Connect.Cda.List List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.List((IsnList) wrapped);
      }

      internal static HL7Connect.Cda.TableItem TableItem(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnColItem)
          return /*4*/HL7Connect.Cda.WrapperFactory.ColItem(wrapped);
        else if (wrapped is HCsnTCell)
          return /*4*/HL7Connect.Cda.WrapperFactory.TCell(wrapped);
        else if (wrapped is HCsnTRow)
          return /*4*/HL7Connect.Cda.WrapperFactory.TRow(wrapped);
        else if (wrapped is HCsnTRowGroup)
          return /*4*/HL7Connect.Cda.WrapperFactory.TRowGroup(wrapped);
        else
          return new HL7Connect.Cda.TableItem((IsnTableItem) wrapped);
      }

      internal static HL7Connect.Cda.ColItem ColItem(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCsnCol)
          return /*4*/HL7Connect.Cda.WrapperFactory.Col(wrapped);
        else if (wrapped is HCsnColGroup)
          return /*4*/HL7Connect.Cda.WrapperFactory.ColGroup(wrapped);
        else
          return new HL7Connect.Cda.ColItem((IsnColItem) wrapped);
      }

      internal static HL7Connect.Cda.Col Col(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Col((IsnCol) wrapped);
      }

      internal static HL7Connect.Cda.ColGroup ColGroup(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ColGroup((IsnColGroup) wrapped);
      }

      internal static HL7Connect.Cda.TCell TCell(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TCell((IsnTCell) wrapped);
      }

      internal static HL7Connect.Cda.TRowPart TRowPart(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TRowPart((IsnTRowPart) wrapped);
      }

      internal static HL7Connect.Cda.TRow TRow(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TRow((IsnTRow) wrapped);
      }

      internal static HL7Connect.Cda.TRowGroup TRowGroup(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TRowGroup((IsnTRowGroup) wrapped);
      }

      internal static HL7Connect.Cda.Table Table(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Table((IsnTable) wrapped);
      }

      internal static HL7Connect.Cda.CMGeneralList CMGeneralList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMGeneralList((IsnCMGeneralList) wrapped);
      }

      internal static HL7Connect.Cda.CMTitleList CMTitleList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMTitleList((IsnCMTitleList) wrapped);
      }

      internal static HL7Connect.Cda.CMFootnotesList CMFootnotesList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMFootnotesList((IsnCMFootnotesList) wrapped);
      }

      internal static HL7Connect.Cda.CMInlineList CMInlineList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMInlineList((IsnCMInlineList) wrapped);
      }

      internal static HL7Connect.Cda.CMContentList CMContentList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CMContentList((IsnCMContentList) wrapped);
      }

      internal static HL7Connect.Cda.ItemList ItemList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ItemList((IsnItemList) wrapped);
      }

      internal static HL7Connect.Cda.ColList ColList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ColList((IsnColList) wrapped);
      }

      internal static HL7Connect.Cda.TRowPartList TRowPartList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TRowPartList((IsnTRowPartList) wrapped);
      }

      internal static HL7Connect.Cda.TRowList TRowList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TRowList((IsnTRowList) wrapped);
      }

      internal static HL7Connect.Cda.ColGroupList ColGroupList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ColGroupList((IsnColGroupList) wrapped);
      }

      internal static HL7Connect.Cda.TRowGroupList TRowGroupList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.TRowGroupList((IsnTRowGroupList) wrapped);
      }

      internal static HL7Connect.Cda.CDABase CDABase(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCcdaClinicalStatement)
          return /*4*/HL7Connect.Cda.WrapperFactory.ClinicalStatement(wrapped);
        else if (wrapped is HCcdaAssignedAuthor)
          return /*4*/HL7Connect.Cda.WrapperFactory.AssignedAuthor(wrapped);
        else if (wrapped is HCcdaAssignedCustodian)
          return /*4*/HL7Connect.Cda.WrapperFactory.AssignedCustodian(wrapped);
        else if (wrapped is HCcdaInformantChoice)
          return /*4*/HL7Connect.Cda.WrapperFactory.InformantChoice(wrapped);
        else if (wrapped is HCcdaAssociatedEntity)
          return /*4*/HL7Connect.Cda.WrapperFactory.AssociatedEntity(wrapped);
        else if (wrapped is HCcdaAuthenticator)
          return /*4*/HL7Connect.Cda.WrapperFactory.Authenticator(wrapped);
        else if (wrapped is HCcdaAuthor)
          return /*4*/HL7Connect.Cda.WrapperFactory.Author(wrapped);
        else if (wrapped is HCcdaAuthorChoice)
          return /*4*/HL7Connect.Cda.WrapperFactory.AuthorChoice(wrapped);
        else if (wrapped is HCcdaAuthorization)
          return /*4*/HL7Connect.Cda.WrapperFactory.Authorization(wrapped);
        else if (wrapped is HCcdaBirthplace)
          return /*4*/HL7Connect.Cda.WrapperFactory.Birthplace(wrapped);
        else if (wrapped is HCcdaClinicalDocument)
          return /*4*/HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped);
        else if (wrapped is HCcdaComponent1)
          return /*4*/HL7Connect.Cda.WrapperFactory.Component1(wrapped);
        else if (wrapped is HCcdaComponent2)
          return /*4*/HL7Connect.Cda.WrapperFactory.Component2(wrapped);
        else if (wrapped is HCcdaComponent3)
          return /*4*/HL7Connect.Cda.WrapperFactory.Component3(wrapped);
        else if (wrapped is HCcdaComponent4)
          return /*4*/HL7Connect.Cda.WrapperFactory.Component4(wrapped);
        else if (wrapped is HCcdaComponent5)
          return /*4*/HL7Connect.Cda.WrapperFactory.Component5(wrapped);
        else if (wrapped is HCcdaConsent)
          return /*4*/HL7Connect.Cda.WrapperFactory.Consent(wrapped);
        else if (wrapped is HCcdaConsumable)
          return /*4*/HL7Connect.Cda.WrapperFactory.Consumable(wrapped);
        else if (wrapped is HCcdaCriterion)
          return /*4*/HL7Connect.Cda.WrapperFactory.Criterion(wrapped);
        else if (wrapped is HCcdaCustodian)
          return /*4*/HL7Connect.Cda.WrapperFactory.Custodian(wrapped);
        else if (wrapped is HCcdaCustodianOrganization)
          return /*4*/HL7Connect.Cda.WrapperFactory.CustodianOrganization(wrapped);
        else if (wrapped is HCcdaDataEnterer)
          return /*4*/HL7Connect.Cda.WrapperFactory.DataEnterer(wrapped);
        else if (wrapped is HCcdaDevice)
          return /*4*/HL7Connect.Cda.WrapperFactory.Device(wrapped);
        else if (wrapped is HCcdaDocumentationOf)
          return /*4*/HL7Connect.Cda.WrapperFactory.DocumentationOf(wrapped);
        else if (wrapped is HCcdaEncompassingEncounter)
          return /*4*/HL7Connect.Cda.WrapperFactory.EncompassingEncounter(wrapped);
        else if (wrapped is HCcdaEncounterParticipant)
          return /*4*/HL7Connect.Cda.WrapperFactory.EncounterParticipant(wrapped);
        else if (wrapped is HCcdaEntity)
          return /*4*/HL7Connect.Cda.WrapperFactory.Entity(wrapped);
        else if (wrapped is HCcdaEntry)
          return /*4*/HL7Connect.Cda.WrapperFactory.Entry(wrapped);
        else if (wrapped is HCcdaEntryRelationship)
          return /*4*/HL7Connect.Cda.WrapperFactory.EntryRelationship(wrapped);
        else if (wrapped is HCcdaExternalActChoice)
          return /*4*/HL7Connect.Cda.WrapperFactory.ExternalActChoice(wrapped);
        else if (wrapped is HCcdaGuardian)
          return /*4*/HL7Connect.Cda.WrapperFactory.Guardian(wrapped);
        else if (wrapped is HCcdaHealthCareFacility)
          return /*4*/HL7Connect.Cda.WrapperFactory.HealthCareFacility(wrapped);
        else if (wrapped is HCcdaInformant12)
          return /*4*/HL7Connect.Cda.WrapperFactory.Informant12(wrapped);
        else if (wrapped is HCcdaInformationRecipient)
          return /*4*/HL7Connect.Cda.WrapperFactory.InformationRecipient(wrapped);
        else if (wrapped is HCcdaInFulfillmentOf)
          return /*4*/HL7Connect.Cda.WrapperFactory.InFulfillmentOf(wrapped);
        else if (wrapped is HCcdaIntendedRecipient)
          return /*4*/HL7Connect.Cda.WrapperFactory.IntendedRecipient(wrapped);
        else if (wrapped is HCcdaLabeledDrug)
          return /*4*/HL7Connect.Cda.WrapperFactory.LabeledDrug(wrapped);
        else if (wrapped is HCcdaLanguageCommunication)
          return /*4*/HL7Connect.Cda.WrapperFactory.LanguageCommunication(wrapped);
        else if (wrapped is HCcdaLegalAuthenticator)
          return /*4*/HL7Connect.Cda.WrapperFactory.LegalAuthenticator(wrapped);
        else if (wrapped is HCcdaLocation)
          return /*4*/HL7Connect.Cda.WrapperFactory.Location(wrapped);
        else if (wrapped is HCcdaMaintainedEntity)
          return /*4*/HL7Connect.Cda.WrapperFactory.MaintainedEntity(wrapped);
        else if (wrapped is HCcdaManufacturedProduct)
          return /*4*/HL7Connect.Cda.WrapperFactory.ManufacturedProduct(wrapped);
        else if (wrapped is HCcdaMaterial)
          return /*4*/HL7Connect.Cda.WrapperFactory.Material(wrapped);
        else if (wrapped is HCcdaNonXMLBody)
          return /*4*/HL7Connect.Cda.WrapperFactory.NonXMLBody(wrapped);
        else if (wrapped is HCcdaObservationRange)
          return /*4*/HL7Connect.Cda.WrapperFactory.ObservationRange(wrapped);
        else if (wrapped is HCcdaOrder)
          return /*4*/HL7Connect.Cda.WrapperFactory.Order(wrapped);
        else if (wrapped is HCcdaOrganization)
          return /*4*/HL7Connect.Cda.WrapperFactory.Organization(wrapped);
        else if (wrapped is HCcdaOrganizationPartOf)
          return /*4*/HL7Connect.Cda.WrapperFactory.OrganizationPartOf(wrapped);
        else if (wrapped is HCcdaParentDocument)
          return /*4*/HL7Connect.Cda.WrapperFactory.ParentDocument(wrapped);
        else if (wrapped is HCcdaParticipant1)
          return /*4*/HL7Connect.Cda.WrapperFactory.Participant1(wrapped);
        else if (wrapped is HCcdaParticipant2)
          return /*4*/HL7Connect.Cda.WrapperFactory.Participant2(wrapped);
        else if (wrapped is HCcdaParticipantRole)
          return /*4*/HL7Connect.Cda.WrapperFactory.ParticipantRole(wrapped);
        else if (wrapped is HCcdaPatient)
          return /*4*/HL7Connect.Cda.WrapperFactory.Patient(wrapped);
        else if (wrapped is HCcdaPatientRole)
          return /*4*/HL7Connect.Cda.WrapperFactory.PatientRole(wrapped);
        else if (wrapped is HCcdaPerformer1)
          return /*4*/HL7Connect.Cda.WrapperFactory.Performer1(wrapped);
        else if (wrapped is HCcdaPerformer2)
          return /*4*/HL7Connect.Cda.WrapperFactory.Performer2(wrapped);
        else if (wrapped is HCcdaPlace)
          return /*4*/HL7Connect.Cda.WrapperFactory.Place(wrapped);
        else if (wrapped is HCcdaPlayingEntity)
          return /*4*/HL7Connect.Cda.WrapperFactory.PlayingEntity(wrapped);
        else if (wrapped is HCcdaPrecondition)
          return /*4*/HL7Connect.Cda.WrapperFactory.Precondition(wrapped);
        else if (wrapped is HCcdaProduct)
          return /*4*/HL7Connect.Cda.WrapperFactory.Product(wrapped);
        else if (wrapped is HCcdaRecordTarget)
          return /*4*/HL7Connect.Cda.WrapperFactory.RecordTarget(wrapped);
        else if (wrapped is HCcdaReference)
          return /*4*/HL7Connect.Cda.WrapperFactory.Reference(wrapped);
        else if (wrapped is HCcdaReferenceRange)
          return /*4*/HL7Connect.Cda.WrapperFactory.ReferenceRange(wrapped);
        else if (wrapped is HCcdaRelatedDocument)
          return /*4*/HL7Connect.Cda.WrapperFactory.RelatedDocument(wrapped);
        else if (wrapped is HCcdaRelatedSubject)
          return /*4*/HL7Connect.Cda.WrapperFactory.RelatedSubject(wrapped);
        else if (wrapped is HCcdaResponsibleParty)
          return /*4*/HL7Connect.Cda.WrapperFactory.ResponsibleParty(wrapped);
        else if (wrapped is HCcdaSection)
          return /*4*/HL7Connect.Cda.WrapperFactory.Section(wrapped);
        else if (wrapped is HCcdaServiceEvent)
          return /*4*/HL7Connect.Cda.WrapperFactory.ServiceEvent(wrapped);
        else if (wrapped is HCcdaSpecimen)
          return /*4*/HL7Connect.Cda.WrapperFactory.Specimen(wrapped);
        else if (wrapped is HCcdaSpecimenRole)
          return /*4*/HL7Connect.Cda.WrapperFactory.SpecimenRole(wrapped);
        else if (wrapped is HCcdaStructuredBody)
          return /*4*/HL7Connect.Cda.WrapperFactory.StructuredBody(wrapped);
        else if (wrapped is HCcdaSubject)
          return /*4*/HL7Connect.Cda.WrapperFactory.Subject(wrapped);
        else if (wrapped is HCcdaSubjectPerson)
          return /*4*/HL7Connect.Cda.WrapperFactory.SubjectPerson(wrapped);
        else
          return new HL7Connect.Cda.CDABase((IcdaBase) wrapped);
      }

      internal static HL7Connect.Cda.ClinicalStatement ClinicalStatement(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCcdaAct)
          return /*4*/HL7Connect.Cda.WrapperFactory.Act(wrapped);
        else if (wrapped is HCcdaEncounter)
          return /*4*/HL7Connect.Cda.WrapperFactory.Encounter(wrapped);
        else if (wrapped is HCcdaObservation)
          return /*4*/HL7Connect.Cda.WrapperFactory.Observation(wrapped);
        else if (wrapped is HCcdaObservationMedia)
          return /*4*/HL7Connect.Cda.WrapperFactory.ObservationMedia(wrapped);
        else if (wrapped is HCcdaOrganizer)
          return /*4*/HL7Connect.Cda.WrapperFactory.Organizer(wrapped);
        else if (wrapped is HCcdaProcedure)
          return /*4*/HL7Connect.Cda.WrapperFactory.Procedure(wrapped);
        else if (wrapped is HCcdaRegionOfInterest)
          return /*4*/HL7Connect.Cda.WrapperFactory.RegionOfInterest(wrapped);
        else if (wrapped is HCcdaSubstanceAdministration)
          return /*4*/HL7Connect.Cda.WrapperFactory.SubstanceAdministration(wrapped);
        else if (wrapped is HCcdaSupply)
          return /*4*/HL7Connect.Cda.WrapperFactory.Supply(wrapped);
        else
          return new HL7Connect.Cda.ClinicalStatement((IcdaClinicalStatement) wrapped);
      }

      internal static HL7Connect.Cda.Act Act(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Act((IcdaAct) wrapped);
      }

      internal static HL7Connect.Cda.AssignedAuthor AssignedAuthor(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AssignedAuthor((IcdaAssignedAuthor) wrapped);
      }

      internal static HL7Connect.Cda.AssignedCustodian AssignedCustodian(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AssignedCustodian((IcdaAssignedCustodian) wrapped);
      }

      internal static HL7Connect.Cda.InformantChoice InformantChoice(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCcdaAssignedEntity)
          return /*4*/HL7Connect.Cda.WrapperFactory.AssignedEntity(wrapped);
        else if (wrapped is HCcdaRelatedEntity)
          return /*4*/HL7Connect.Cda.WrapperFactory.RelatedEntity(wrapped);
        else
          return new HL7Connect.Cda.InformantChoice((IcdaInformantChoice) wrapped);
      }

      internal static HL7Connect.Cda.AssignedEntity AssignedEntity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AssignedEntity((IcdaAssignedEntity) wrapped);
      }

      internal static HL7Connect.Cda.AssociatedEntity AssociatedEntity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AssociatedEntity((IcdaAssociatedEntity) wrapped);
      }

      internal static HL7Connect.Cda.Authenticator Authenticator(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Authenticator((IcdaAuthenticator) wrapped);
      }

      internal static HL7Connect.Cda.Author Author(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Author((IcdaAuthor) wrapped);
      }

      internal static HL7Connect.Cda.AuthorChoice AuthorChoice(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCcdaAuthoringDevice)
          return /*4*/HL7Connect.Cda.WrapperFactory.AuthoringDevice(wrapped);
        else if (wrapped is HCcdaPerson)
          return /*4*/HL7Connect.Cda.WrapperFactory.Person(wrapped);
        else
          return new HL7Connect.Cda.AuthorChoice((IcdaAuthorChoice) wrapped);
      }

      internal static HL7Connect.Cda.AuthoringDevice AuthoringDevice(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AuthoringDevice((IcdaAuthoringDevice) wrapped);
      }

      internal static HL7Connect.Cda.Authorization Authorization(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Authorization((IcdaAuthorization) wrapped);
      }

      internal static HL7Connect.Cda.Birthplace Birthplace(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Birthplace((IcdaBirthplace) wrapped);
      }

      internal static HL7Connect.Cda.ClinicalDocument ClinicalDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ClinicalDocument((IcdaClinicalDocument) wrapped);
      }

      internal static HL7Connect.Cda.Component1 Component1(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component1((IcdaComponent1) wrapped);
      }

      internal static HL7Connect.Cda.Component2 Component2(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component2((IcdaComponent2) wrapped);
      }

      internal static HL7Connect.Cda.Component3 Component3(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component3((IcdaComponent3) wrapped);
      }

      internal static HL7Connect.Cda.Component4 Component4(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component4((IcdaComponent4) wrapped);
      }

      internal static HL7Connect.Cda.Component5 Component5(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component5((IcdaComponent5) wrapped);
      }

      internal static HL7Connect.Cda.Consent Consent(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Consent((IcdaConsent) wrapped);
      }

      internal static HL7Connect.Cda.Consumable Consumable(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Consumable((IcdaConsumable) wrapped);
      }

      internal static HL7Connect.Cda.Criterion Criterion(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Criterion((IcdaCriterion) wrapped);
      }

      internal static HL7Connect.Cda.Custodian Custodian(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Custodian((IcdaCustodian) wrapped);
      }

      internal static HL7Connect.Cda.CustodianOrganization CustodianOrganization(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.CustodianOrganization((IcdaCustodianOrganization) wrapped);
      }

      internal static HL7Connect.Cda.DataEnterer DataEnterer(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.DataEnterer((IcdaDataEnterer) wrapped);
      }

      internal static HL7Connect.Cda.Device Device(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Device((IcdaDevice) wrapped);
      }

      internal static HL7Connect.Cda.DocumentationOf DocumentationOf(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.DocumentationOf((IcdaDocumentationOf) wrapped);
      }

      internal static HL7Connect.Cda.EncompassingEncounter EncompassingEncounter(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EncompassingEncounter((IcdaEncompassingEncounter) wrapped);
      }

      internal static HL7Connect.Cda.Encounter Encounter(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Encounter((IcdaEncounter) wrapped);
      }

      internal static HL7Connect.Cda.EncounterParticipant EncounterParticipant(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EncounterParticipant((IcdaEncounterParticipant) wrapped);
      }

      internal static HL7Connect.Cda.Entity Entity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Entity((IcdaEntity) wrapped);
      }

      internal static HL7Connect.Cda.Entry Entry(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Entry((IcdaEntry) wrapped);
      }

      internal static HL7Connect.Cda.EntryRelationship EntryRelationship(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EntryRelationship((IcdaEntryRelationship) wrapped);
      }

      internal static HL7Connect.Cda.ExternalActChoice ExternalActChoice(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCcdaExternalAct)
          return /*4*/HL7Connect.Cda.WrapperFactory.ExternalAct(wrapped);
        else if (wrapped is HCcdaExternalDocument)
          return /*4*/HL7Connect.Cda.WrapperFactory.ExternalDocument(wrapped);
        else if (wrapped is HCcdaExternalObservation)
          return /*4*/HL7Connect.Cda.WrapperFactory.ExternalObservation(wrapped);
        else if (wrapped is HCcdaExternalProcedure)
          return /*4*/HL7Connect.Cda.WrapperFactory.ExternalProcedure(wrapped);
        else
          return new HL7Connect.Cda.ExternalActChoice((IcdaExternalActChoice) wrapped);
      }

      internal static HL7Connect.Cda.ExternalAct ExternalAct(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ExternalAct((IcdaExternalAct) wrapped);
      }

      internal static HL7Connect.Cda.ExternalDocument ExternalDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ExternalDocument((IcdaExternalDocument) wrapped);
      }

      internal static HL7Connect.Cda.ExternalObservation ExternalObservation(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ExternalObservation((IcdaExternalObservation) wrapped);
      }

      internal static HL7Connect.Cda.ExternalProcedure ExternalProcedure(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ExternalProcedure((IcdaExternalProcedure) wrapped);
      }

      internal static HL7Connect.Cda.Guardian Guardian(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Guardian((IcdaGuardian) wrapped);
      }

      internal static HL7Connect.Cda.HealthCareFacility HealthCareFacility(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.HealthCareFacility((IcdaHealthCareFacility) wrapped);
      }

      internal static HL7Connect.Cda.Informant12 Informant12(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Informant12((IcdaInformant12) wrapped);
      }

      internal static HL7Connect.Cda.InformationRecipient InformationRecipient(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.InformationRecipient((IcdaInformationRecipient) wrapped);
      }

      internal static HL7Connect.Cda.InFulfillmentOf InFulfillmentOf(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.InFulfillmentOf((IcdaInFulfillmentOf) wrapped);
      }

      internal static HL7Connect.Cda.IntendedRecipient IntendedRecipient(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.IntendedRecipient((IcdaIntendedRecipient) wrapped);
      }

      internal static HL7Connect.Cda.LabeledDrug LabeledDrug(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.LabeledDrug((IcdaLabeledDrug) wrapped);
      }

      internal static HL7Connect.Cda.LanguageCommunication LanguageCommunication(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.LanguageCommunication((IcdaLanguageCommunication) wrapped);
      }

      internal static HL7Connect.Cda.LegalAuthenticator LegalAuthenticator(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.LegalAuthenticator((IcdaLegalAuthenticator) wrapped);
      }

      internal static HL7Connect.Cda.Location Location(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Location((IcdaLocation) wrapped);
      }

      internal static HL7Connect.Cda.MaintainedEntity MaintainedEntity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.MaintainedEntity((IcdaMaintainedEntity) wrapped);
      }

      internal static HL7Connect.Cda.ManufacturedProduct ManufacturedProduct(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ManufacturedProduct((IcdaManufacturedProduct) wrapped);
      }

      internal static HL7Connect.Cda.Material Material(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Material((IcdaMaterial) wrapped);
      }

      internal static HL7Connect.Cda.NonXMLBody NonXMLBody(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.NonXMLBody((IcdaNonXMLBody) wrapped);
      }

      internal static HL7Connect.Cda.Observation Observation(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Observation((IcdaObservation) wrapped);
      }

      internal static HL7Connect.Cda.ObservationMedia ObservationMedia(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ObservationMedia((IcdaObservationMedia) wrapped);
      }

      internal static HL7Connect.Cda.ObservationRange ObservationRange(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ObservationRange((IcdaObservationRange) wrapped);
      }

      internal static HL7Connect.Cda.Order Order(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Order((IcdaOrder) wrapped);
      }

      internal static HL7Connect.Cda.Organization Organization(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Organization((IcdaOrganization) wrapped);
      }

      internal static HL7Connect.Cda.OrganizationPartOf OrganizationPartOf(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.OrganizationPartOf((IcdaOrganizationPartOf) wrapped);
      }

      internal static HL7Connect.Cda.Organizer Organizer(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Organizer((IcdaOrganizer) wrapped);
      }

      internal static HL7Connect.Cda.ParentDocument ParentDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ParentDocument((IcdaParentDocument) wrapped);
      }

      internal static HL7Connect.Cda.Participant1 Participant1(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Participant1((IcdaParticipant1) wrapped);
      }

      internal static HL7Connect.Cda.Participant2 Participant2(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Participant2((IcdaParticipant2) wrapped);
      }

      internal static HL7Connect.Cda.ParticipantRole ParticipantRole(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ParticipantRole((IcdaParticipantRole) wrapped);
      }

      internal static HL7Connect.Cda.Patient Patient(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Patient((IcdaPatient) wrapped);
      }

      internal static HL7Connect.Cda.PatientRole PatientRole(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.PatientRole((IcdaPatientRole) wrapped);
      }

      internal static HL7Connect.Cda.Performer1 Performer1(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Performer1((IcdaPerformer1) wrapped);
      }

      internal static HL7Connect.Cda.Performer2 Performer2(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Performer2((IcdaPerformer2) wrapped);
      }

      internal static HL7Connect.Cda.Person Person(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Person((IcdaPerson) wrapped);
      }

      internal static HL7Connect.Cda.Place Place(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Place((IcdaPlace) wrapped);
      }

      internal static HL7Connect.Cda.PlayingEntity PlayingEntity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.PlayingEntity((IcdaPlayingEntity) wrapped);
      }

      internal static HL7Connect.Cda.Precondition Precondition(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Precondition((IcdaPrecondition) wrapped);
      }

      internal static HL7Connect.Cda.Procedure Procedure(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Procedure((IcdaProcedure) wrapped);
      }

      internal static HL7Connect.Cda.Product Product(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Product((IcdaProduct) wrapped);
      }

      internal static HL7Connect.Cda.RecordTarget RecordTarget(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RecordTarget((IcdaRecordTarget) wrapped);
      }

      internal static HL7Connect.Cda.Reference Reference(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Reference((IcdaReference) wrapped);
      }

      internal static HL7Connect.Cda.ReferenceRange ReferenceRange(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ReferenceRange((IcdaReferenceRange) wrapped);
      }

      internal static HL7Connect.Cda.RegionOfInterest_value RegionOfInterest_value(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RegionOfInterest_value((IcdaRegionOfInterest_value) wrapped);
      }

      internal static HL7Connect.Cda.RegionOfInterest RegionOfInterest(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RegionOfInterest((IcdaRegionOfInterest) wrapped);
      }

      internal static HL7Connect.Cda.RelatedDocument RelatedDocument(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RelatedDocument((IcdaRelatedDocument) wrapped);
      }

      internal static HL7Connect.Cda.RelatedEntity RelatedEntity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RelatedEntity((IcdaRelatedEntity) wrapped);
      }

      internal static HL7Connect.Cda.RelatedSubject RelatedSubject(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RelatedSubject((IcdaRelatedSubject) wrapped);
      }

      internal static HL7Connect.Cda.ResponsibleParty ResponsibleParty(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ResponsibleParty((IcdaResponsibleParty) wrapped);
      }

      internal static HL7Connect.Cda.Section Section(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Section((IcdaSection) wrapped);
      }

      internal static HL7Connect.Cda.ServiceEvent ServiceEvent(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ServiceEvent((IcdaServiceEvent) wrapped);
      }

      internal static HL7Connect.Cda.Specimen Specimen(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Specimen((IcdaSpecimen) wrapped);
      }

      internal static HL7Connect.Cda.SpecimenRole SpecimenRole(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SpecimenRole((IcdaSpecimenRole) wrapped);
      }

      internal static HL7Connect.Cda.StructuredBody StructuredBody(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.StructuredBody((IcdaStructuredBody) wrapped);
      }

      internal static HL7Connect.Cda.Subject Subject(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Subject((IcdaSubject) wrapped);
      }

      internal static HL7Connect.Cda.SubjectPerson SubjectPerson(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SubjectPerson((IcdaSubjectPerson) wrapped);
      }

      internal static HL7Connect.Cda.SubstanceAdministration SubstanceAdministration(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SubstanceAdministration((IcdaSubstanceAdministration) wrapped);
      }

      internal static HL7Connect.Cda.Supply Supply(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Supply((IcdaSupply) wrapped);
      }

      internal static HL7Connect.Cda.AuthorList AuthorList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AuthorList((IcdaAuthorList) wrapped);
      }

      internal static HL7Connect.Cda.EntryRelationshipList EntryRelationshipList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EntryRelationshipList((IcdaEntryRelationshipList) wrapped);
      }

      internal static HL7Connect.Cda.Informant12List Informant12List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Informant12List((IcdaInformant12List) wrapped);
      }

      internal static HL7Connect.Cda.Participant2List Participant2List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Participant2List((IcdaParticipant2List) wrapped);
      }

      internal static HL7Connect.Cda.Performer2List Performer2List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Performer2List((IcdaPerformer2List) wrapped);
      }

      internal static HL7Connect.Cda.PreconditionList PreconditionList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.PreconditionList((IcdaPreconditionList) wrapped);
      }

      internal static HL7Connect.Cda.ReferenceList ReferenceList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ReferenceList((IcdaReferenceList) wrapped);
      }

      internal static HL7Connect.Cda.SpecimenList SpecimenList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.SpecimenList((IcdaSpecimenList) wrapped);
      }

      internal static HL7Connect.Cda.MaintainedEntityList MaintainedEntityList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.MaintainedEntityList((IcdaMaintainedEntityList) wrapped);
      }

      internal static HL7Connect.Cda.AuthenticatorList AuthenticatorList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AuthenticatorList((IcdaAuthenticatorList) wrapped);
      }

      internal static HL7Connect.Cda.AuthorizationList AuthorizationList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.AuthorizationList((IcdaAuthorizationList) wrapped);
      }

      internal static HL7Connect.Cda.DocumentationOfList DocumentationOfList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.DocumentationOfList((IcdaDocumentationOfList) wrapped);
      }

      internal static HL7Connect.Cda.InformationRecipientList InformationRecipientList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.InformationRecipientList((IcdaInformationRecipientList) wrapped);
      }

      internal static HL7Connect.Cda.InFulfillmentOfList InFulfillmentOfList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.InFulfillmentOfList((IcdaInFulfillmentOfList) wrapped);
      }

      internal static HL7Connect.Cda.Participant1List Participant1List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Participant1List((IcdaParticipant1List) wrapped);
      }

      internal static HL7Connect.Cda.RecordTargetList RecordTargetList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RecordTargetList((IcdaRecordTargetList) wrapped);
      }

      internal static HL7Connect.Cda.RelatedDocumentList RelatedDocumentList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RelatedDocumentList((IcdaRelatedDocumentList) wrapped);
      }

      internal static HL7Connect.Cda.EncounterParticipantList EncounterParticipantList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EncounterParticipantList((IcdaEncounterParticipantList) wrapped);
      }

      internal static HL7Connect.Cda.ReferenceRangeList ReferenceRangeList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.ReferenceRangeList((IcdaReferenceRangeList) wrapped);
      }

      internal static HL7Connect.Cda.Component4List Component4List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component4List((IcdaComponent4List) wrapped);
      }

      internal static HL7Connect.Cda.GuardianList GuardianList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.GuardianList((IcdaGuardianList) wrapped);
      }

      internal static HL7Connect.Cda.LanguageCommunicationList LanguageCommunicationList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.LanguageCommunicationList((IcdaLanguageCommunicationList) wrapped);
      }

      internal static HL7Connect.Cda.Component5List Component5List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component5List((IcdaComponent5List) wrapped);
      }

      internal static HL7Connect.Cda.EntryList EntryList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.EntryList((IcdaEntryList) wrapped);
      }

      internal static HL7Connect.Cda.Performer1List Performer1List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Performer1List((IcdaPerformer1List) wrapped);
      }

      internal static HL7Connect.Cda.Component3List Component3List(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Component3List((IcdaComponent3List) wrapped);
      }

      internal static HL7Connect.Cda.RegionOfInterest_valueList RegionOfInterest_valueList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.RegionOfInterest_valueList((IcdaRegionOfInterest_valueList) wrapped);
      }

      internal static HL7Connect.Cda.Factory Factory(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Cda.Factory((ICDAFactory) wrapped);
      }

    }
  }
  namespace Ccd
  {
    ///<summary>
    /// Builds a content part
    ///</summary>
    public class ContentBuilder : HL7Connect.Utils.Base
    {

      internal ContentBuilder(ICCDContentBuilder com) : base(com) {} 

      internal new HCCCDContentBuilder wrapped() { return (HCCCDContentBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add Text
      ///</summary>
      public void Text(string sText)
      {
        wrapped().Text(sText);
      }

      ///<summary>
      /// add sub or superscript text
      ///</summary>
      public void TextXScript(string sText, bool bSuper)
      {
        wrapped().TextXScript(sText, bSuper ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// add a link. sRef is the where the link points to. sTitle is the popup. sName is the anchor name, and sText is the content.
      ///</summary>
      public void LinkText(string sRef, string sTitle, string sName, string sText)
      {
        wrapped().LinkText(sRef, sTitle, sName, sText);
      }

      ///<summary>
      /// Add a line break
      ///</summary>
      public void Break()
      {
        wrapped().Break();
      }

      ///<summary>
      /// Underlying CDA Narrative
      ///</summary>
      private HL7Connect.Cda.Content propGetCDAContent()
      {
        return HL7Connect.Cda.WrapperFactory.Content(wrapped().CDAContent);
      }
      ///<summary>
      /// Underlying CDA Narrative
      ///</summary>
      public HL7Connect.Cda.Content CDAContent { get { return propGetCDAContent(); } }

    }

    ///<summary>
    /// Builds a paragraph
    ///</summary>
    public class ParagraphBuilder : HL7Connect.Utils.Base
    {

      internal ParagraphBuilder(ICCDParagraphBuilder com) : base(com) {} 

      internal new HCCCDParagraphBuilder wrapped() { return (HCCCDParagraphBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add Text
      ///</summary>
      public void Text(string sText)
      {
        wrapped().Text(sText);
      }

      ///<summary>
      /// add sub or superscript text
      ///</summary>
      public void TextXScript(string sText, bool bSuper)
      {
        wrapped().TextXScript(sText, bSuper ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// add a link. sRef is the where the link points to. sTitle is the popup. sName is the anchor name, and sText is the content.
      ///</summary>
      public void LinkText(string sRef, string sTitle, string sName, string sText)
      {
        wrapped().LinkText(sRef, sTitle, sName, sText);
      }

      ///<summary>
      /// Add a line break
      ///</summary>
      public void Break()
      {
        wrapped().Break();
      }

      ///<summary>
      /// Add a content block with an id
      ///</summary>
      public HL7Connect.Ccd.ContentBuilder Content(string sId)
      {
        return HL7Connect.Ccd.WrapperFactory.ContentBuilder(wrapped().content(sId));
      }

      ///<summary>
      /// Underlying CDA Paragraph
      ///</summary>
      private HL7Connect.Cda.Paragraph propGetCDAParagraph()
      {
        return HL7Connect.Cda.WrapperFactory.Paragraph(wrapped().CDAParagraph);
      }
      ///<summary>
      /// Underlying CDA Paragraph
      ///</summary>
      public HL7Connect.Cda.Paragraph CDAParagraph { get { return propGetCDAParagraph(); } }

    }

    ///<summary>
    /// Builds a List
    ///</summary>
    public class ListBuilder : HL7Connect.Utils.Base
    {

      internal ListBuilder(ICCDListBuilder com) : base(com) {} 

      internal new HCCCDListBuilder wrapped() { return (HCCCDListBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add an item to the list
      ///</summary>
      public HL7Connect.Ccd.ParagraphBuilder AddItem()
      {
        return HL7Connect.Ccd.WrapperFactory.ParagraphBuilder(wrapped().AddItem());
      }

      ///<summary>
      /// Underlying CDA List
      ///</summary>
      private HL7Connect.Cda.List propGetCDAList()
      {
        return HL7Connect.Cda.WrapperFactory.List(wrapped().CDAList);
      }
      ///<summary>
      /// Underlying CDA List
      ///</summary>
      public HL7Connect.Cda.List CDAList { get { return propGetCDAList(); } }

    }

    ///<summary>
    /// Builds a Row in a Table
    ///</summary>
    public class TableRowBuilder : HL7Connect.Utils.Base
    {

      internal TableRowBuilder(ICCDTableRowBuilder com) : base(com) {} 

      internal new HCCCDTableRowBuilder wrapped() { return (HCCCDTableRowBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a column (a &lt;td&gt; cell) to the first row of the table. If you want more than simple text content, us
      ///</summary>
      public HL7Connect.Cda.TCell Column(string sContent)
      {
        return HL7Connect.Cda.WrapperFactory.TCell(wrapped().Column(sContent));
      }

      ///<summary>
      /// Underlying CDA Row
      ///</summary>
      private HL7Connect.Cda.TRow propGetCDARow()
      {
        return HL7Connect.Cda.WrapperFactory.TRow(wrapped().CDARow);
      }
      ///<summary>
      /// Underlying CDA Row
      ///</summary>
      public HL7Connect.Cda.TRow CDARow { get { return propGetCDARow(); } }

    }

    ///<summary>
    /// Builds a Table
    ///</summary>
    public class TableBuilder : HL7Connect.Utils.Base
    {

      internal TableBuilder(ICCDTableBuilder com) : base(com) {} 

      internal new HCCCDTableBuilder wrapped() { return (HCCCDTableBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a column (a &lt;th&gt; cell) to the first row of the tabl
      ///</summary>
      public HL7Connect.Cda.TCell Column(string sHeading)
      {
        return HL7Connect.Cda.WrapperFactory.TCell(wrapped().Column(sHeading));
      }

      ///<summary>
      /// Add a row to the table. If you want want groups, you will have to build the table using the underlying CDATable
      ///</summary>
      public HL7Connect.Ccd.TableRowBuilder Row()
      {
        return HL7Connect.Ccd.WrapperFactory.TableRowBuilder(wrapped().row());
      }

      ///<summary>
      /// Underlying CDA Table
      ///</summary>
      private HL7Connect.Cda.Table propGetCDATable()
      {
        return HL7Connect.Cda.WrapperFactory.Table(wrapped().CDATable);
      }
      ///<summary>
      /// Underlying CDA Table
      ///</summary>
      public HL7Connect.Cda.Table CDATable { get { return propGetCDATable(); } }

    }

    ///<summary>
    /// Builds a Narrative Block
    ///</summary>
    public class NarrativeBuilder : HL7Connect.Utils.Base
    {

      internal NarrativeBuilder(ICCDNarrativeBuilder com) : base(com) {} 

      internal new HCCCDNarrativeBuilder wrapped() { return (HCCCDNarrativeBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add Text
      ///</summary>
      public void Text(string sText)
      {
        wrapped().Text(sText);
      }

      ///<summary>
      /// add sub or superscript text
      ///</summary>
      public void TextXScript(string sText, bool bSuper)
      {
        wrapped().TextXScript(sText, bSuper ? (sbyte) 0 : (sbyte) -1);
      }

      ///<summary>
      /// add a link. sRef is the where the link points to. sTitle is the popup. sName is the anchor name, and sText is the content.
      ///</summary>
      public void LinkText(string sRef, string sTitle, string sName, string sText)
      {
        wrapped().LinkText(sRef, sTitle, sName, sText);
      }

      ///<summary>
      /// Add a line break
      ///</summary>
      public void Break()
      {
        wrapped().Break();
      }

      ///<summary>
      /// Add a content block with an id
      ///</summary>
      public HL7Connect.Ccd.ContentBuilder Content(string sId)
      {
        return HL7Connect.Ccd.WrapperFactory.ContentBuilder(wrapped().content(sId));
      }

      ///<summary>
      /// Add a paragraph
      ///</summary>
      public HL7Connect.Ccd.ParagraphBuilder Paragraph()
      {
        return HL7Connect.Ccd.WrapperFactory.ParagraphBuilder(wrapped().paragraph());
      }

      ///<summary>
      /// Add a List
      ///</summary>
      public HL7Connect.Ccd.ListBuilder List(bool bOrdered)
      {
        return HL7Connect.Ccd.WrapperFactory.ListBuilder(wrapped().list(bOrdered ? (sbyte) 0 : (sbyte) -1));
      }

      ///<summary>
      /// Add a Table
      ///</summary>
      public HL7Connect.Ccd.TableBuilder Table()
      {
        return HL7Connect.Ccd.WrapperFactory.TableBuilder(wrapped().Table());
      }

      ///<summary>
      /// Underlying CDA Narrative
      ///</summary>
      private HL7Connect.Cda.SDText propGetCDANarrative()
      {
        return HL7Connect.Cda.WrapperFactory.SDText(wrapped().CDANarrative);
      }
      ///<summary>
      /// Underlying CDA Narrative
      ///</summary>
      public HL7Connect.Cda.SDText CDANarrative { get { return propGetCDANarrative(); } }

    }

    ///<summary>
    /// a Service
    ///</summary>
    public class ServiceEvent : HL7Connect.Utils.Base
    {

      internal ServiceEvent(ICCDServiceEvent com) : base(com) {} 

      internal new HCCCDServiceEvent wrapped() { return (HCCCDServiceEvent) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Event structure (may be null if not building)
      ///</summary>
      private HL7Connect.Cda.ServiceEvent propGetCDAEvent()
      {
        return HL7Connect.Cda.WrapperFactory.ServiceEvent(wrapped().CDAEvent);
      }
      ///<summary>
      /// Underlying CDA Event structure (may be null if not building)
      ///</summary>
      public HL7Connect.Cda.ServiceEvent CDAEvent { get { return propGetCDAEvent(); } }

      ///<summary>
      /// List of ids that apply to the event (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// List of ids that apply to the event (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// The code that describes the service type (may be null)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      ///<summary>
      /// The code that describes the service type (may be null)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } }

      ///<summary>
      /// When the service started (may be null if not building)
      ///</summary>
      private HL7Connect.Cda.TS propGetLow()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().low);
      }
      ///<summary>
      /// When the service started (may be null if not building)
      ///</summary>
      public HL7Connect.Cda.TS Low { get { return propGetLow(); } }

      ///<summary>
      /// When the service ended (may be null if not building)
      ///</summary>
      private HL7Connect.Cda.TS propGetHigh()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().high);
      }
      ///<summary>
      /// When the service ended (may be null if not building)
      ///</summary>
      public HL7Connect.Cda.TS High { get { return propGetHigh(); } }

    }

    ///<summary>
    /// a Patient
    ///</summary>
    public class Patient : HL7Connect.Utils.Base
    {

      internal Patient(ICCDPatient com) : base(com) {} 

      internal new HCCCDPatient wrapped() { return (HCCCDPatient) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Patient structure (may be null if reading and document is not conformant)
      ///</summary>
      private HL7Connect.Cda.PatientRole propGetCDAPatient()
      {
        return HL7Connect.Cda.WrapperFactory.PatientRole(wrapped().CDAPatient);
      }
      ///<summary>
      /// Underlying CDA Patient structure (may be null if reading and document is not conformant)
      ///</summary>
      public HL7Connect.Cda.PatientRole CDAPatient { get { return propGetCDAPatient(); } }

      ///<summary>
      /// List of ids that apply to the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// List of ids that apply to the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// List of addresses for the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddrList()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().AddrList);
      }
      ///<summary>
      /// List of addresses for the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListAD AddrList { get { return propGetAddrList(); } }

      ///<summary>
      /// List of names for the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListEN propGetNameList()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().NameList);
      }
      ///<summary>
      /// List of names for the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListEN NameList { get { return propGetNameList(); } }

      ///<summary>
      /// List of phone numbers and emails for the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecomList()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().TelecomList);
      }
      ///<summary>
      /// List of phone numbers and emails for the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListTEL TelecomList { get { return propGetTelecomList(); } }

      ///<summary>
      /// Gender for the patient. Possible values : GenderNull, GenderMale, GenderFemale, GenderUndifferentiated 
      /// 
      /// -- Valid Genders in a CCD document GenderNullGenderMaleGenderFemaleGenderUndifferentiated
      ///</summary>
      private TCCDGender propGetGender()
      {
        return wrapped().Gender;
      }
      private void propSetGender(TCCDGender value)
      {
        wrapped().Gender = value;
      }
      ///<summary>
      /// Gender for the patient. Possible values : GenderNull, GenderMale, GenderFemale, GenderUndifferentiated 
      /// 
      /// -- Valid Genders in a CCD document GenderNullGenderMaleGenderFemaleGenderUndifferentiated
      ///</summary>
      public TCCDGender Gender { get { return propGetGender(); } set { propSetGender(value); } }

      ///<summary>
      /// birth date for the patient. (may be null)
      ///</summary>
      private HL7Connect.Cda.TS propGetBirthTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().birthTime);
      }
      private void propSetBirthTime(HL7Connect.Cda.TS value)
      {
        wrapped().birthTime = value.wrapped();
      }
      ///<summary>
      /// birth date for the patient. (may be null)
      ///</summary>
      public HL7Connect.Cda.TS BirthTime { get { return propGetBirthTime(); } set { propSetBirthTime(value); } }

      ///<summary>
      /// Marital Status of the patient. (will not be null) 
      /// 
      /// -- Valid Marital Status codes in a CCD document MaritalStatusNullMaritalStatusAnnulledMaritalStatusDivorcedMaritalStatusInterlocutoryMaritalStatusLegallySeparatedMaritalStatusMarriedMaritalStatusPolygamousMaritalStatusNeverMarriedMaritalStatusDomesticPartnerMaritalStatusWidowed
      ///</summary>
      private TCCDMaritalStatus propGetMaritalStatus()
      {
        return wrapped().MaritalStatus;
      }
      private void propSetMaritalStatus(TCCDMaritalStatus value)
      {
        wrapped().MaritalStatus = value;
      }
      ///<summary>
      /// Marital Status of the patient. (will not be null) 
      /// 
      /// -- Valid Marital Status codes in a CCD document MaritalStatusNullMaritalStatusAnnulledMaritalStatusDivorcedMaritalStatusInterlocutoryMaritalStatusLegallySeparatedMaritalStatusMarriedMaritalStatusPolygamousMaritalStatusNeverMarriedMaritalStatusDomesticPartnerMaritalStatusWidowed
      ///</summary>
      public TCCDMaritalStatus MaritalStatus { get { return propGetMaritalStatus(); } set { propSetMaritalStatus(value); } }

    }

    ///<summary>
    /// a Device
    ///</summary>
    public class Device : HL7Connect.Utils.Base
    {

      ///<summary>
      /// Create a CCD Device
      ///</summary>
      public Device() : base(Ccd.WrapperFactory.WorkingFactory.wrapped().newDevice()) {} 

      internal Device(ICCDDevice com) : base(com) {} 

      internal new HCCCDDevice wrapped() { return (HCCCDDevice) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Device structure (may be null if reading and document is not conformant)
      ///</summary>
      private HL7Connect.Cda.AuthoringDevice propGetCDADevice()
      {
        return HL7Connect.Cda.WrapperFactory.AuthoringDevice(wrapped().CDADevice);
      }
      ///<summary>
      /// Underlying CDA Device structure (may be null if reading and document is not conformant)
      ///</summary>
      public HL7Connect.Cda.AuthoringDevice CDADevice { get { return propGetCDADevice(); } }

      ///<summary>
      /// Code - type of the device (may be null)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// Code - type of the device (may be null)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// name of the software (may be null)
      ///</summary>
      private HL7Connect.Cda.SC propGetSoftwareName()
      {
        return HL7Connect.Cda.WrapperFactory.SC(wrapped().softwareName);
      }
      private void propSetSoftwareName(HL7Connect.Cda.SC value)
      {
        wrapped().softwareName = value.wrapped();
      }
      ///<summary>
      /// name of the software (may be null)
      ///</summary>
      public HL7Connect.Cda.SC SoftwareName { get { return propGetSoftwareName(); } set { propSetSoftwareName(value); } }

    }

    ///<summary>
    /// a Person
    ///</summary>
    public class Person : HL7Connect.Utils.Base
    {

      ///<summary>
      /// Create a CCD Person
      ///</summary>
      public Person() : base(Ccd.WrapperFactory.WorkingFactory.wrapped().newPerson()) {} 

      internal Person(ICCDPerson com) : base(com) {} 

      internal new HCCCDPerson wrapped() { return (HCCCDPerson) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Person structure (may be null if reading and document is not conformant)
      ///</summary>
      private HL7Connect.Cda.Person propGetCDAPerson()
      {
        return HL7Connect.Cda.WrapperFactory.Person(wrapped().CDAPerson);
      }
      ///<summary>
      /// Underlying CDA Person structure (may be null if reading and document is not conformant)
      ///</summary>
      public HL7Connect.Cda.Person CDAPerson { get { return propGetCDAPerson(); } }

      ///<summary>
      /// List of names for the patient (may be null)
      ///</summary>
      private HL7Connect.Cda.ListEN propGetNameList()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().NameList);
      }
      ///<summary>
      /// List of names for the patient (may be null)
      ///</summary>
      public HL7Connect.Cda.ListEN NameList { get { return propGetNameList(); } }

    }

    ///<summary>
    /// an organization
    ///</summary>
    public class Organization : HL7Connect.Utils.Base
    {

      ///<summary>
      /// Create a CCD Organization
      ///</summary>
      public Organization() : base(Ccd.WrapperFactory.WorkingFactory.wrapped().newOrganization()) {} 

      internal Organization(ICCDOrganization com) : base(com) {} 

      internal new HCCCDOrganization wrapped() { return (HCCCDOrganization) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Organization structure (may be null if reading and document is not conformant)
      ///</summary>
      private HL7Connect.Cda.Organization propGetCDAOrganization()
      {
        return HL7Connect.Cda.WrapperFactory.Organization(wrapped().CDAOrganization);
      }
      ///<summary>
      /// Underlying CDA Organization structure (may be null if reading and document is not conformant)
      ///</summary>
      public HL7Connect.Cda.Organization CDAOrganization { get { return propGetCDAOrganization(); } }

      ///<summary>
      /// List of ids that apply to the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// List of ids that apply to the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// List of addresses for the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListAD propGetAddrList()
      {
        return HL7Connect.Cda.WrapperFactory.ListAD(wrapped().AddrList);
      }
      ///<summary>
      /// List of addresses for the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListAD AddrList { get { return propGetAddrList(); } }

      ///<summary>
      /// List of names for the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListEN propGetNameList()
      {
        return HL7Connect.Cda.WrapperFactory.ListEN(wrapped().NameList);
      }
      ///<summary>
      /// List of names for the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListEN NameList { get { return propGetNameList(); } }

      ///<summary>
      /// List of phone numbers and emails for the patient (will not be null)
      ///</summary>
      private HL7Connect.Cda.ListTEL propGetTelecomList()
      {
        return HL7Connect.Cda.WrapperFactory.ListTEL(wrapped().TelecomList);
      }
      ///<summary>
      /// List of phone numbers and emails for the patient (will not be null)
      ///</summary>
      public HL7Connect.Cda.ListTEL TelecomList { get { return propGetTelecomList(); } }

    }

    ///<summary>
    /// a source
    ///</summary>
    public class From : HL7Connect.Utils.Base
    {

      internal From(ICCDFrom com) : base(com) {} 

      internal new HCCCDFrom wrapped() { return (HCCCDFrom) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Author structure (may be null if reading and document is not conformant)
      ///</summary>
      private HL7Connect.Cda.Author propGetCDAAuthor()
      {
        return HL7Connect.Cda.WrapperFactory.Author(wrapped().CDAAuthor);
      }
      ///<summary>
      /// Underlying CDA Author structure (may be null if reading and document is not conformant)
      ///</summary>
      public HL7Connect.Cda.Author CDAAuthor { get { return propGetCDAAuthor(); } }

      ///<summary>
      /// The time of the authoring (may be the same as the document authoring time) (may be null if reading and document is not conforming)
      ///</summary>
      private HL7Connect.Cda.TS propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.TS value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// The time of the authoring (may be the same as the document authoring time) (may be null if reading and document is not conforming)
      ///</summary>
      public HL7Connect.Cda.TS Time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// The identity of the author. (May not be null) (author has an associated representedOrganization with no person or device, this must have a nullFlavor of NA)
      ///</summary>
      private HL7Connect.Cda.ListII propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().ID);
      }
      ///<summary>
      /// The identity of the author. (May not be null) (author has an associated representedOrganization with no person or device, this must have a nullFlavor of NA)
      ///</summary>
      public HL7Connect.Cda.ListII Id { get { return propGetId(); } }

      ///<summary>
      /// The device that authored this document May be null. Either (Person xor Device) and/or Organization must be defined
      ///</summary>
      private HL7Connect.Ccd.Device propGetDevice()
      {
        return HL7Connect.Ccd.WrapperFactory.Device(wrapped().Device);
      }
      private void propSetDevice(HL7Connect.Ccd.Device value)
      {
        wrapped().Device = value.wrapped();
      }
      ///<summary>
      /// The device that authored this document May be null. Either (Person xor Device) and/or Organization must be defined
      ///</summary>
      public HL7Connect.Ccd.Device Device { get { return propGetDevice(); } set { propSetDevice(value); } }

      ///<summary>
      /// The person who wrote the document. May be null. Either (Person xor Device) and/or Organization must be defined
      ///</summary>
      private HL7Connect.Ccd.Person propGetPerson()
      {
        return HL7Connect.Ccd.WrapperFactory.Person(wrapped().Person);
      }
      private void propSetPerson(HL7Connect.Ccd.Person value)
      {
        wrapped().Person = value.wrapped();
      }
      ///<summary>
      /// The person who wrote the document. May be null. Either (Person xor Device) and/or Organization must be defined
      ///</summary>
      public HL7Connect.Ccd.Person Person { get { return propGetPerson(); } set { propSetPerson(value); } }

      ///<summary>
      /// The organisation responsible for writing the document. May be null. Either (Person xor Device) and/or Organization must be defined
      ///</summary>
      private HL7Connect.Ccd.Organization propGetOrganization()
      {
        return HL7Connect.Ccd.WrapperFactory.Organization(wrapped().Organization);
      }
      private void propSetOrganization(HL7Connect.Ccd.Organization value)
      {
        wrapped().Organization = value.wrapped();
      }
      ///<summary>
      /// The organisation responsible for writing the document. May be null. Either (Person xor Device) and/or Organization must be defined
      ///</summary>
      public HL7Connect.Ccd.Organization Organization { get { return propGetOrganization(); } set { propSetOrganization(value); } }

    }

    public class FromList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<From>
    {
      public FromList(ICCDFromList com) : base(com) {}
      internal new HCCCDFromList wrapped() { return (HCCCDFromList) com; }
  
      public From this[int index]
      {
        get { return new From(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(From item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public From Append()
      {
        return new From(wrapped().Append());
      }
  
      public void Insert(int index, From item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(From item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(From item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(From[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new From(wrapped().Item(i));
      }
  
      public bool Remove(From item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class FromListEnumerator : IEnumerator<From>
      {
        private ICCDFromList com;
        int index = -1;
  
        public FromListEnumerator(ICCDFromList com)
        {
          this.com = com;
        }
  
        public From Current { get { return new From(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new From(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<From> GetEnumerator()
      {
        return new FromListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new FromListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a statement of purpose
    ///</summary>
    public class PurposeStatement : HL7Connect.Utils.Base
    {

      internal PurposeStatement(ICCDPurposeStatement com) : base(com) {} 

      internal new HCCCDPurposeStatement wrapped() { return (HCCCDPurposeStatement) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.Entry propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.Entry CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// what kind of purpose statement this is. A conformant document will not be pkNull. Defaults to pkAct when building. Choices = pkNull, pkObservation, pkProcedure, pkSubstanceAdministration, pkEncounter, pkSupply, pkAct 
      /// 
      /// -- Valid kinds of Purpose statement in a CCD document pkNullpkObservationpkProcedurepkSubstanceAdministrationpkEncounterpkSupplypkAct
      ///</summary>
      private TCCDPurposeKind propGetKind()
      {
        return wrapped().Kind;
      }
      private void propSetKind(TCCDPurposeKind value)
      {
        wrapped().Kind = value;
      }
      ///<summary>
      /// what kind of purpose statement this is. A conformant document will not be pkNull. Defaults to pkAct when building. Choices = pkNull, pkObservation, pkProcedure, pkSubstanceAdministration, pkEncounter, pkSupply, pkAct 
      /// 
      /// -- Valid kinds of Purpose statement in a CCD document pkNullpkObservationpkProcedurepkSubstanceAdministrationpkEncounterpkSupplypkAct
      ///</summary>
      public TCCDPurposeKind Kind { get { return propGetKind(); } set { propSetKind(value); } }

      ///<summary>
      /// The classCode for this purpose statement (defaults to an appropriate kind for the act - is rewritten by changing the kind) (cannot set classCode for pkSubstanceAdministration and pkSupply)
      ///</summary>
      private string propGetClassCode()
      {
        return wrapped().classCode;
      }
      private void propSetClassCode(string value)
      {
        wrapped().classCode = value;
      }
      ///<summary>
      /// The classCode for this purpose statement (defaults to an appropriate kind for the act - is rewritten by changing the kind) (cannot set classCode for pkSubstanceAdministration and pkSupply)
      ///</summary>
      public string ClassCode { get { return propGetClassCode(); } set { propSetClassCode(value); } }

      ///<summary>
      /// The moodCode for the act (defaults to EVN, no reason to change it)
      ///</summary>
      private string propGetMoodCode()
      {
        return wrapped().moodCode;
      }
      private void propSetMoodCode(string value)
      {
        wrapped().moodCode = value;
      }
      ///<summary>
      /// The moodCode for the act (defaults to EVN, no reason to change it)
      ///</summary>
      public string MoodCode { get { return propGetMoodCode(); } set { propSetMoodCode(value); } }

      ///<summary>
      /// identifiers for the purpose statement (null if Kind = pkNull)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the purpose statement (null if Kind = pkNull)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// The code for the type of purpose statement (not the kind - an additional clinical code)  (null if Kind = pkNull)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// The code for the type of purpose statement (not the kind - an additional clinical code)  (null if Kind = pkNull)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// The status code for the act. defaults to "complete"  (null if Kind = pkNull)
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// The status code for the act. defaults to "complete"  (null if Kind = pkNull)
      ///</summary>
      public HL7Connect.Cda.CS StatusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// The time for the act. Simple interval unless kind is Supply or SubstanceAdministration. (null if Kind = pkNull)
      ///</summary>
      private HL7Connect.Cda.QSET<HL7Connect.Cda.TS> propGetEffectiveTime()
      {
        return HL7Connect.Cda.WrapperFactory.QSET<HL7Connect.Cda.TS>(wrapped().effectiveTime);
      }
      private void propSetEffectiveTime(HL7Connect.Cda.QSET<HL7Connect.Cda.TS> value)
      {
        wrapped().effectiveTime = value.wrapped();
      }
      ///<summary>
      /// The time for the act. Simple interval unless kind is Supply or SubstanceAdministration. (null if Kind = pkNull)
      ///</summary>
      public HL7Connect.Cda.QSET<HL7Connect.Cda.TS> EffectiveTime { get { return propGetEffectiveTime(); } set { propSetEffectiveTime(value); } }

    }

    public class PurposeStatementList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<PurposeStatement>
    {
      public PurposeStatementList(ICCDPurposeStatementList com) : base(com) {}
      internal new HCCCDPurposeStatementList wrapped() { return (HCCCDPurposeStatementList) com; }
  
      public PurposeStatement this[int index]
      {
        get { return new PurposeStatement(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(PurposeStatement item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public PurposeStatement Append()
      {
        return new PurposeStatement(wrapped().Append());
      }
  
      public void Insert(int index, PurposeStatement item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(PurposeStatement item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(PurposeStatement item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(PurposeStatement[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new PurposeStatement(wrapped().Item(i));
      }
  
      public bool Remove(PurposeStatement item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class PurposeStatementListEnumerator : IEnumerator<PurposeStatement>
      {
        private ICCDPurposeStatementList com;
        int index = -1;
  
        public PurposeStatementListEnumerator(ICCDPurposeStatementList com)
        {
          this.com = com;
        }
  
        public PurposeStatement Current { get { return new PurposeStatement(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new PurposeStatement(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<PurposeStatement> GetEnumerator()
      {
        return new PurposeStatementListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new PurposeStatementListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a purpose
    ///</summary>
    public class Purpose : HL7Connect.Utils.Base
    {

      internal Purpose(ICCDPurpose com) : base(com) {} 

      internal new HCCCDPurpose wrapped() { return (HCCCDPurpose) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      private HL7Connect.Cda.Section propGetCDASection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().CDASection);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      public HL7Connect.Cda.Section CDASection { get { return propGetCDASection(); } }

      ///<summary>
      /// The purpose section is expected to have some narrative describing the purpose. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      private HL7Connect.Ccd.NarrativeBuilder propGetNarrative()
      {
        return HL7Connect.Ccd.WrapperFactory.NarrativeBuilder(wrapped().Narrative);
      }
      ///<summary>
      /// The purpose section is expected to have some narrative describing the purpose. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      public HL7Connect.Ccd.NarrativeBuilder Narrative { get { return propGetNarrative(); } }

      ///<summary>
      /// Details of the purpose
      ///</summary>
      private HL7Connect.Ccd.PurposeStatementList propGetPurposeStatementList()
      {
        return HL7Connect.Ccd.WrapperFactory.PurposeStatementList(wrapped().PurposeStatementList);
      }
      ///<summary>
      /// Details of the purpose
      ///</summary>
      public HL7Connect.Ccd.PurposeStatementList PurposeStatementList { get { return propGetPurposeStatementList(); } }

    }

    ///<summary>
    /// a statement of CoverageDetail
    ///</summary>
    public class AuthorizationActivity : HL7Connect.Utils.Base
    {

      internal AuthorizationActivity(ICCDAuthorizationActivity com) : base(com) {} 

      internal new HCCCDAuthorizationActivity wrapped() { return (HCCCDAuthorizationActivity) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Act (may not be null)
      ///</summary>
      private HL7Connect.Cda.Act propGetCDAAct()
      {
        return HL7Connect.Cda.WrapperFactory.Act(wrapped().CDAAct);
      }
      ///<summary>
      /// Underlying CDA Act (may not be null)
      ///</summary>
      public HL7Connect.Cda.Act CDAAct { get { return propGetCDAAct(); } }

      ///<summary>
      /// identifiers for the Authorization
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the Authorization
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

    }

    public class AuthorizationActivityList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<AuthorizationActivity>
    {
      public AuthorizationActivityList(ICCDAuthorizationActivityList com) : base(com) {}
      internal new HCCCDAuthorizationActivityList wrapped() { return (HCCCDAuthorizationActivityList) com; }
  
      public AuthorizationActivity this[int index]
      {
        get { return new AuthorizationActivity(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(AuthorizationActivity item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public AuthorizationActivity Append()
      {
        return new AuthorizationActivity(wrapped().Append());
      }
  
      public void Insert(int index, AuthorizationActivity item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(AuthorizationActivity item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(AuthorizationActivity item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(AuthorizationActivity[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new AuthorizationActivity(wrapped().Item(i));
      }
  
      public bool Remove(AuthorizationActivity item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class AuthorizationActivityListEnumerator : IEnumerator<AuthorizationActivity>
      {
        private ICCDAuthorizationActivityList com;
        int index = -1;
  
        public AuthorizationActivityListEnumerator(ICCDAuthorizationActivityList com)
        {
          this.com = com;
        }
  
        public AuthorizationActivity Current { get { return new AuthorizationActivity(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new AuthorizationActivity(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<AuthorizationActivity> GetEnumerator()
      {
        return new AuthorizationActivityListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new AuthorizationActivityListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// A policy activity represents the policy or program providing the coverage. The person for whom payment is being provided (i.e. the patient) is the covered party. The subscriber of the policy or program is represented as a participant that is the holder the coverage. The payer is represented as the performer of the policy activity.
    ///</summary>
    public class PolicyActivity : HL7Connect.Utils.Base
    {

      internal PolicyActivity(ICCDPolicyActivity com) : base(com) {} 

      internal new HCCCDPolicyActivity wrapped() { return (HCCCDPolicyActivity) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Act (may not be null)
      ///</summary>
      private HL7Connect.Cda.Act propGetCDAAct()
      {
        return HL7Connect.Cda.WrapperFactory.Act(wrapped().CDAAct);
      }
      ///<summary>
      /// Underlying CDA Act (may not be null)
      ///</summary>
      public HL7Connect.Cda.Act CDAAct { get { return propGetCDAAct(); } }

      ///<summary>
      /// identifiers for the Policy
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the Policy
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// The code for the type of CoverageDetail statement (not the kind - an additional clinical code) 
      /// 
      /// (null if Kind = pkNull, may be null if Kind = cdkAuthorization) Value set for the code is (AUTOPOL COL UNINSMOT EHCPOL HSAPOL PUBLICPOL DENTPRG DISEASEPRG CANPRG ENDRENAL HIVAIDS MANDPOL MENTPRG SAFNET SUBPRG SUBSIDIZ  SUBSIDMC SUBSUPP WCBPOL)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// The code for the type of CoverageDetail statement (not the kind - an additional clinical code) 
      /// 
      /// (null if Kind = pkNull, may be null if Kind = cdkAuthorization) Value set for the code is (AUTOPOL COL UNINSMOT EHCPOL HSAPOL PUBLICPOL DENTPRG DISEASEPRG CANPRG ENDRENAL HIVAIDS MANDPOL MENTPRG SAFNET SUBPRG SUBSIDIZ  SUBSIDMC SUBSUPP WCBPOL)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// represent the payer identification number. For pharamacy benefit programs this can be valued using the RxBIN and RxPCN numbers assigned by ANSI and NCPDP respectively. When a nationally recognized payer identification number is available, it would  
      /// 
      /// may be null when reading a document (if non-conformant)
      ///</summary>
      private HL7Connect.Cda.ListII propGetPayerIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().PayerIdList);
      }
      ///<summary>
      /// represent the payer identification number. For pharamacy benefit programs this can be valued using the RxBIN and RxPCN numbers assigned by ANSI and NCPDP respectively. When a nationally recognized payer identification number is available, it would  
      /// 
      /// may be null when reading a document (if non-conformant)
      ///</summary>
      public HL7Connect.Cda.ListII PayerIdList { get { return propGetPayerIdList(); } }

      ///<summary>
      /// the covered party
      ///</summary>
      private HL7Connect.Cda.ListII propGetCoveredPartyIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().CoveredPartyIdList);
      }
      ///<summary>
      /// the covered party
      ///</summary>
      public HL7Connect.Cda.ListII CoveredPartyIdList { get { return propGetCoveredPartyIdList(); } }

      ///<summary>
      /// the role the covered party plays (choices: FAMDEP HANDIC INJ SELF SPON STUD FSTUD PSTUD CRIMEVIC INJWKR COCBEN DIFFABL WARD COCBEN RETIREE INDIG MIL ACTMIL RETMIL VET WARD)
      ///</summary>
      private HL7Connect.Cda.CD propGetCoveredPartyRole()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().CoveredPartyRole);
      }
      private void propSetCoveredPartyRole(HL7Connect.Cda.CD value)
      {
        wrapped().CoveredPartyRole = value.wrapped();
      }
      ///<summary>
      /// the role the covered party plays (choices: FAMDEP HANDIC INJ SELF SPON STUD FSTUD PSTUD CRIMEVIC INJWKR COCBEN DIFFABL WARD COCBEN RETIREE INDIG MIL ACTMIL RETMIL VET WARD)
      ///</summary>
      public HL7Connect.Cda.CD CoveredPartyRole { get { return propGetCoveredPartyRole(); } set { propSetCoveredPartyRole(value); } }

      ///<summary>
      /// the time period over which the patient is covered
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetCoverageInterval()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().CoverageInterval);
      }
      private void propSetCoverageInterval(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().CoverageInterval = value.wrapped();
      }
      ///<summary>
      /// the time period over which the patient is covered
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> CoverageInterval { get { return propGetCoverageInterval(); } set { propSetCoverageInterval(value); } }

      ///<summary>
      /// -1 is default (not present in the instance) 
      /// 
      /// (Integer cannot be null in some implementations)
      ///</summary>
      private int propGetPriority()
      {
        return wrapped().Priority;
      }
      private void propSetPriority(int value)
      {
        wrapped().Priority = value;
      }
      ///<summary>
      /// -1 is default (not present in the instance) 
      /// 
      /// (Integer cannot be null in some implementations)
      ///</summary>
      public int Priority { get { return propGetPriority(); } set { propSetPriority(value); } }

      ///<summary>
      /// An authorization activity represents authorizations or pre-authorizations currently active for the patient for the particular payer. Authorizations are represented using an act subordinate to the policy or program that provided it. The policy or program is referred to by the authorization. Authorized treatments can be grouped into an Organizer class, where common properties, such as the reason for the authorization, can be expressed. Subordinate acts represent what was authorized.
      ///</summary>
      private HL7Connect.Ccd.AuthorizationActivityList propGetAuthorizationActivityList()
      {
        return HL7Connect.Ccd.WrapperFactory.AuthorizationActivityList(wrapped().AuthorizationActivityList);
      }
      ///<summary>
      /// An authorization activity represents authorizations or pre-authorizations currently active for the patient for the particular payer. Authorizations are represented using an act subordinate to the policy or program that provided it. The policy or program is referred to by the authorization. Authorized treatments can be grouped into an Organizer class, where common properties, such as the reason for the authorization, can be expressed. Subordinate acts represent what was authorized.
      ///</summary>
      public HL7Connect.Ccd.AuthorizationActivityList AuthorizationActivityList { get { return propGetAuthorizationActivityList(); } }

    }

    public class PolicyActivityList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<PolicyActivity>
    {
      public PolicyActivityList(ICCDPolicyActivityList com) : base(com) {}
      internal new HCCCDPolicyActivityList wrapped() { return (HCCCDPolicyActivityList) com; }
  
      public PolicyActivity this[int index]
      {
        get { return new PolicyActivity(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(PolicyActivity item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public PolicyActivity Append()
      {
        return new PolicyActivity(wrapped().Append());
      }
  
      public void Insert(int index, PolicyActivity item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(PolicyActivity item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(PolicyActivity item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(PolicyActivity[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new PolicyActivity(wrapped().Item(i));
      }
  
      public bool Remove(PolicyActivity item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class PolicyActivityListEnumerator : IEnumerator<PolicyActivity>
      {
        private ICCDPolicyActivityList com;
        int index = -1;
  
        public PolicyActivityListEnumerator(ICCDPolicyActivityList com)
        {
          this.com = com;
        }
  
        public PolicyActivity Current { get { return new PolicyActivity(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new PolicyActivity(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<PolicyActivity> GetEnumerator()
      {
        return new PolicyActivityListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new PolicyActivityListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// Insurance and authorization acts are represented as Acts within the section. These acts are grouped together under a single coverage activity, which serves to order the payment sources. A coverage activity contains one or more policy activities, each of which contains zero or more authorization activities.
    ///</summary>
    public class CoverageActivity : HL7Connect.Utils.Base
    {

      internal CoverageActivity(ICCDCoverageActivity com) : base(com) {} 

      internal new HCCCDCoverageActivity wrapped() { return (HCCCDCoverageActivity) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.Entry propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.Entry CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// identifiers for the Coverage Activity (null if Kind = pkNull)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the Coverage Activity (null if Kind = pkNull)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// A policy activity represents the policy or program providing the coverage. The person for whom payment is being provided (i.e. the patient) is the covered party. The subscriber of the policy or program is represented as a participant that is the holder the coverage. The payer is represented as the performer of the policy activity.
      ///</summary>
      private HL7Connect.Ccd.PolicyActivityList propGetPolicyActivityList()
      {
        return HL7Connect.Ccd.WrapperFactory.PolicyActivityList(wrapped().PolicyActivityList);
      }
      ///<summary>
      /// A policy activity represents the policy or program providing the coverage. The person for whom payment is being provided (i.e. the patient) is the covered party. The subscriber of the policy or program is represented as a participant that is the holder the coverage. The payer is represented as the performer of the policy activity.
      ///</summary>
      public HL7Connect.Ccd.PolicyActivityList PolicyActivityList { get { return propGetPolicyActivityList(); } }

    }

    public class CoverageActivityList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<CoverageActivity>
    {
      public CoverageActivityList(ICCDCoverageActivityList com) : base(com) {}
      internal new HCCCDCoverageActivityList wrapped() { return (HCCCDCoverageActivityList) com; }
  
      public CoverageActivity this[int index]
      {
        get { return new CoverageActivity(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(CoverageActivity item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public CoverageActivity Append()
      {
        return new CoverageActivity(wrapped().Append());
      }
  
      public void Insert(int index, CoverageActivity item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(CoverageActivity item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(CoverageActivity item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(CoverageActivity[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new CoverageActivity(wrapped().Item(i));
      }
  
      public bool Remove(CoverageActivity item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class CoverageActivityListEnumerator : IEnumerator<CoverageActivity>
      {
        private ICCDCoverageActivityList com;
        int index = -1;
  
        public CoverageActivityListEnumerator(ICCDCoverageActivityList com)
        {
          this.com = com;
        }
  
        public CoverageActivity Current { get { return new CoverageActivity(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new CoverageActivity(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<CoverageActivity> GetEnumerator()
      {
        return new CoverageActivityListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new CoverageActivityListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a Payers
    ///</summary>
    public class Payers : HL7Connect.Utils.Base
    {

      internal Payers(ICCDPayers com) : base(com) {} 

      internal new HCCCDPayers wrapped() { return (HCCCDPayers) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      private HL7Connect.Cda.Section propGetCDASection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().CDASection);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      public HL7Connect.Cda.Section CDASection { get { return propGetCDASection(); } }

      ///<summary>
      /// The Payers section is expected to have some narrative describing the Payers. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      private HL7Connect.Ccd.NarrativeBuilder propGetNarrative()
      {
        return HL7Connect.Ccd.WrapperFactory.NarrativeBuilder(wrapped().Narrative);
      }
      ///<summary>
      /// The Payers section is expected to have some narrative describing the Payers. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      public HL7Connect.Ccd.NarrativeBuilder Narrative { get { return propGetNarrative(); } }

      ///<summary>
      /// information concerning the coverage for the patient
      ///</summary>
      private HL7Connect.Ccd.CoverageActivityList propGetCoverageActivityList()
      {
        return HL7Connect.Ccd.WrapperFactory.CoverageActivityList(wrapped().CoverageActivityList);
      }
      ///<summary>
      /// information concerning the coverage for the patient
      ///</summary>
      public HL7Connect.Ccd.CoverageActivityList CoverageActivityList { get { return propGetCoverageActivityList(); } }

    }

    ///<summary>
    /// a statement of CoverageDetail
    ///</summary>
    public class EncounterLocation : HL7Connect.Utils.Base
    {

      internal EncounterLocation(ICCDEncounterLocation com) : base(com) {} 

      internal new HCCCDEncounterLocation wrapped() { return (HCCCDEncounterLocation) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Participant (may not be null)
      ///</summary>
      private HL7Connect.Cda.Participant2 propGetCDAParticipant()
      {
        return HL7Connect.Cda.WrapperFactory.Participant2(wrapped().CDAParticipant);
      }
      ///<summary>
      /// Underlying CDA Participant (may not be null)
      ///</summary>
      public HL7Connect.Cda.Participant2 CDAParticipant { get { return propGetCDAParticipant(); } }

      ///<summary>
      /// The type of the location (may be null)
      ///</summary>
      private HL7Connect.Cda.CD propGetLocationType()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().LocationType);
      }
      private void propSetLocationType(HL7Connect.Cda.CD value)
      {
        wrapped().LocationType = value.wrapped();
      }
      ///<summary>
      /// The type of the location (may be null)
      ///</summary>
      public HL7Connect.Cda.CD LocationType { get { return propGetLocationType(); } set { propSetLocationType(value); } }

      ///<summary>
      /// The details of the location (may be null)
      ///</summary>
      private HL7Connect.Cda.PlayingEntity propGetEntity()
      {
        return HL7Connect.Cda.WrapperFactory.PlayingEntity(wrapped().entity);
      }
      ///<summary>
      /// The details of the location (may be null)
      ///</summary>
      public HL7Connect.Cda.PlayingEntity Entity { get { return propGetEntity(); } }

    }

    public class EncounterLocationList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<EncounterLocation>
    {
      public EncounterLocationList(ICCDEncounterLocationList com) : base(com) {}
      internal new HCCCDEncounterLocationList wrapped() { return (HCCCDEncounterLocationList) com; }
  
      public EncounterLocation this[int index]
      {
        get { return new EncounterLocation(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(EncounterLocation item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public EncounterLocation Append()
      {
        return new EncounterLocation(wrapped().Append());
      }
  
      public void Insert(int index, EncounterLocation item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(EncounterLocation item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(EncounterLocation item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(EncounterLocation[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new EncounterLocation(wrapped().Item(i));
      }
  
      public bool Remove(EncounterLocation item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class EncounterLocationListEnumerator : IEnumerator<EncounterLocation>
      {
        private ICCDEncounterLocationList com;
        int index = -1;
  
        public EncounterLocationListEnumerator(ICCDEncounterLocationList com)
        {
          this.com = com;
        }
  
        public EncounterLocation Current { get { return new EncounterLocation(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new EncounterLocation(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<EncounterLocation> GetEnumerator()
      {
        return new EncounterLocationListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new EncounterLocationListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a statement of Coverage
    ///</summary>
    public class EncounterActivity : HL7Connect.Utils.Base
    {

      internal EncounterActivity(ICCDEncounterActivity com) : base(com) {} 

      internal new HCCCDEncounterActivity wrapped() { return (HCCCDEncounterActivity) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.Entry propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.Entry CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// Code for the encounter
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// Code for the encounter
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// identifiers for the encounter. There should be at least one.
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the encounter. There should be at least one.
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// indcates date, time, or duration of the encounter
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// indcates date, time, or duration of the encounter
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> Time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// An act that details the indication for the encounter
      ///</summary>
      private HL7Connect.Cda.EntryRelationship propGetIndication()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationship(wrapped().Indication);
      }
      ///<summary>
      /// An act that details the indication for the encounter
      ///</summary>
      public HL7Connect.Cda.EntryRelationship Indication { get { return propGetIndication(); } }

      ///<summary>
      /// A list of all the locations for the encounter
      ///</summary>
      private HL7Connect.Ccd.EncounterLocationList propGetLocationList()
      {
        return HL7Connect.Ccd.WrapperFactory.EncounterLocationList(wrapped().LocationList);
      }
      ///<summary>
      /// A list of all the locations for the encounter
      ///</summary>
      public HL7Connect.Ccd.EncounterLocationList LocationList { get { return propGetLocationList(); } }

    }

    public class EncounterActivityList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<EncounterActivity>
    {
      public EncounterActivityList(ICCDEncounterActivityList com) : base(com) {}
      internal new HCCCDEncounterActivityList wrapped() { return (HCCCDEncounterActivityList) com; }
  
      public EncounterActivity this[int index]
      {
        get { return new EncounterActivity(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(EncounterActivity item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public EncounterActivity Append()
      {
        return new EncounterActivity(wrapped().Append());
      }
  
      public void Insert(int index, EncounterActivity item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(EncounterActivity item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(EncounterActivity item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(EncounterActivity[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new EncounterActivity(wrapped().Item(i));
      }
  
      public bool Remove(EncounterActivity item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class EncounterActivityListEnumerator : IEnumerator<EncounterActivity>
      {
        private ICCDEncounterActivityList com;
        int index = -1;
  
        public EncounterActivityListEnumerator(ICCDEncounterActivityList com)
        {
          this.com = com;
        }
  
        public EncounterActivity Current { get { return new EncounterActivity(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new EncounterActivity(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<EncounterActivity> GetEnumerator()
      {
        return new EncounterActivityListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new EncounterActivityListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a Encounters
    ///</summary>
    public class Encounters : HL7Connect.Utils.Base
    {

      internal Encounters(ICCDEncounters com) : base(com) {} 

      internal new HCCCDEncounters wrapped() { return (HCCCDEncounters) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      private HL7Connect.Cda.Section propGetCDASection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().CDASection);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      public HL7Connect.Cda.Section CDASection { get { return propGetCDASection(); } }

      ///<summary>
      /// The Encounters section is expected to have some narrative describing the Encounters. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      private HL7Connect.Ccd.NarrativeBuilder propGetNarrative()
      {
        return HL7Connect.Ccd.WrapperFactory.NarrativeBuilder(wrapped().Narrative);
      }
      ///<summary>
      /// The Encounters section is expected to have some narrative describing the Encounters. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      public HL7Connect.Ccd.NarrativeBuilder Narrative { get { return propGetNarrative(); } }

      ///<summary>
      /// a list of the actual encounters
      ///</summary>
      private HL7Connect.Ccd.EncounterActivityList propGetEncounterActivityList()
      {
        return HL7Connect.Ccd.WrapperFactory.EncounterActivityList(wrapped().EncounterActivityList);
      }
      ///<summary>
      /// a list of the actual encounters
      ///</summary>
      public HL7Connect.Ccd.EncounterActivityList EncounterActivityList { get { return propGetEncounterActivityList(); } }

    }

    ///<summary>
    /// actual result
    ///</summary>
    public class ResultObservation : HL7Connect.Utils.Base
    {

      internal ResultObservation(ICCDResultObservation com) : base(com) {} 

      internal new HCCCDResultObservation wrapped() { return (HCCCDResultObservation) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Component (may not be null)
      ///</summary>
      private HL7Connect.Cda.Component4 propGetCDAComponent()
      {
        return HL7Connect.Cda.WrapperFactory.Component4(wrapped().CDAComponent);
      }
      ///<summary>
      /// Underlying CDA Component (may not be null)
      ///</summary>
      public HL7Connect.Cda.Component4 CDAComponent { get { return propGetCDAComponent(); } }

      ///<summary>
      /// identifiers for this observation (must be at least one)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for this observation (must be at least one)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// Code that identifies the observation (mandatory)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// Code that identifies the observation (mandatory)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// Biologically relevant time - the time the specimen was obtained from the patient
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// Biologically relevant time - the time the specimen was obtained from the patient
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> Time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// Status Code for the result (mandatory)
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// Status Code for the result (mandatory)
      ///</summary>
      public HL7Connect.Cda.CS StatusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// Code that identifies the method, if not implicit in the code.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetMethodCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().methodCode);
      }
      ///<summary>
      /// Code that identifies the method, if not implicit in the code.
      ///</summary>
      public HL7Connect.Cda.ListCD MethodCode { get { return propGetMethodCode(); } }

      ///<summary>
      /// Code that identifies the method, if not implicit in the code.
      ///</summary>
      private HL7Connect.Cda.ListCD propGetInterpretationCode()
      {
        return HL7Connect.Cda.WrapperFactory.ListCD(wrapped().interpretationCode);
      }
      ///<summary>
      /// Code that identifies the method, if not implicit in the code.
      ///</summary>
      public HL7Connect.Cda.ListCD InterpretationCode { get { return propGetInterpretationCode(); } }

      ///<summary>
      /// observation value. a data type (any one)
      ///</summary>
      private HL7Connect.Cda.ListANY propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ListANY(wrapped().Value);
      }
      ///<summary>
      /// observation value. a data type (any one)
      ///</summary>
      public HL7Connect.Cda.ListANY Value { get { return propGetValue(); } }

      ///<summary>
      /// reference range as a IVL(PQ) - if it is one. Else null. You can set this when building
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> propGetReferenceRangeIVL()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.PQ>(wrapped().ReferenceRangeIVL);
      }
      private void propSetReferenceRangeIVL(HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> value)
      {
        wrapped().ReferenceRangeIVL = value.wrapped();
      }
      ///<summary>
      /// reference range as a IVL(PQ) - if it is one. Else null. You can set this when building
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.PQ> ReferenceRangeIVL { get { return propGetReferenceRangeIVL(); } set { propSetReferenceRangeIVL(value); } }

      ///<summary>
      /// reference range as text. You can set this when building
      ///</summary>
      private string propGetReferenceRangeText()
      {
        return wrapped().ReferenceRangeText;
      }
      private void propSetReferenceRangeText(string value)
      {
        wrapped().ReferenceRangeText = value;
      }
      ///<summary>
      /// reference range as text. You can set this when building
      ///</summary>
      public string ReferenceRangeText { get { return propGetReferenceRangeText(); } set { propSetReferenceRangeText(value); } }

    }

    public class ResultObservationList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ResultObservation>
    {
      public ResultObservationList(ICCDResultObservationList com) : base(com) {}
      internal new HCCCDResultObservationList wrapped() { return (HCCCDResultObservationList) com; }
  
      public ResultObservation this[int index]
      {
        get { return new ResultObservation(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ResultObservation item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ResultObservation Append()
      {
        return new ResultObservation(wrapped().Append());
      }
  
      public void Insert(int index, ResultObservation item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ResultObservation item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ResultObservation item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ResultObservation[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ResultObservation(wrapped().Item(i));
      }
  
      public bool Remove(ResultObservation item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ResultObservationListEnumerator : IEnumerator<ResultObservation>
      {
        private ICCDResultObservationList com;
        int index = -1;
  
        public ResultObservationListEnumerator(ICCDResultObservationList com)
        {
          this.com = com;
        }
  
        public ResultObservation Current { get { return new ResultObservation(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ResultObservation(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ResultObservation> GetEnumerator()
      {
        return new ResultObservationListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ResultObservationListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a statement of Coverage
    ///</summary>
    public class ResultOrganizer : HL7Connect.Utils.Base
    {

      internal ResultOrganizer(ICCDResultOrganizer com) : base(com) {} 

      internal new HCCCDResultOrganizer wrapped() { return (HCCCDResultOrganizer) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.Entry propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.Entry CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// Code for the result type (mandatory)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// Code for the result type (mandatory)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// identifiers for the result. There should be at least one.
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the result. There should be at least one.
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// Status Code for the encounter (mandatory)
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// Status Code for the encounter (mandatory)
      ///</summary>
      public HL7Connect.Cda.CS StatusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// Actual results grouped by the organizer
      ///</summary>
      private HL7Connect.Ccd.ResultObservationList propGetResultObservationList()
      {
        return HL7Connect.Ccd.WrapperFactory.ResultObservationList(wrapped().ResultObservationList);
      }
      ///<summary>
      /// Actual results grouped by the organizer
      ///</summary>
      public HL7Connect.Ccd.ResultObservationList ResultObservationList { get { return propGetResultObservationList(); } }

    }

    public class ResultOrganizerList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ResultOrganizer>
    {
      public ResultOrganizerList(ICCDResultOrganizerList com) : base(com) {}
      internal new HCCCDResultOrganizerList wrapped() { return (HCCCDResultOrganizerList) com; }
  
      public ResultOrganizer this[int index]
      {
        get { return new ResultOrganizer(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ResultOrganizer item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ResultOrganizer Append()
      {
        return new ResultOrganizer(wrapped().Append());
      }
  
      public void Insert(int index, ResultOrganizer item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ResultOrganizer item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ResultOrganizer item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ResultOrganizer[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ResultOrganizer(wrapped().Item(i));
      }
  
      public bool Remove(ResultOrganizer item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ResultOrganizerListEnumerator : IEnumerator<ResultOrganizer>
      {
        private ICCDResultOrganizerList com;
        int index = -1;
  
        public ResultOrganizerListEnumerator(ICCDResultOrganizerList com)
        {
          this.com = com;
        }
  
        public ResultOrganizer Current { get { return new ResultOrganizer(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ResultOrganizer(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ResultOrganizer> GetEnumerator()
      {
        return new ResultOrganizerListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ResultOrganizerListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a Results
    ///</summary>
    public class Results : HL7Connect.Utils.Base
    {

      internal Results(ICCDResults com) : base(com) {} 

      internal new HCCCDResults wrapped() { return (HCCCDResults) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      private HL7Connect.Cda.Section propGetCDASection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().CDASection);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      public HL7Connect.Cda.Section CDASection { get { return propGetCDASection(); } }

      ///<summary>
      /// The Results section is expected to have some narrative describing the Results. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      private HL7Connect.Ccd.NarrativeBuilder propGetNarrative()
      {
        return HL7Connect.Ccd.WrapperFactory.NarrativeBuilder(wrapped().Narrative);
      }
      ///<summary>
      /// The Results section is expected to have some narrative describing the Results. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      public HL7Connect.Ccd.NarrativeBuilder Narrative { get { return propGetNarrative(); } }

      ///<summary>
      /// A list of the groups of results
      ///</summary>
      private HL7Connect.Ccd.ResultOrganizerList propGetResultOrganizerList()
      {
        return HL7Connect.Ccd.WrapperFactory.ResultOrganizerList(wrapped().ResultOrganizerList);
      }
      ///<summary>
      /// A list of the groups of results
      ///</summary>
      public HL7Connect.Ccd.ResultOrganizerList ResultOrganizerList { get { return propGetResultOrganizerList(); } }

    }

    ///<summary>
    /// actual result
    ///</summary>
    public class ProblemObservation : HL7Connect.Utils.Base
    {

      internal ProblemObservation(ICCDProblemObservation com) : base(com) {} 

      internal new HCCCDProblemObservation wrapped() { return (HCCCDProblemObservation) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Component (may not be null)
      ///</summary>
      private HL7Connect.Cda.Component4 propGetCDAComponent()
      {
        return HL7Connect.Cda.WrapperFactory.Component4(wrapped().CDAComponent);
      }
      ///<summary>
      /// Underlying CDA Component (may not be null)
      ///</summary>
      public HL7Connect.Cda.Component4 CDAComponent { get { return propGetCDAComponent(); } }

      ///<summary>
      /// Code that identifies the observation (mandatory)
      ///</summary>
      private HL7Connect.Cda.CD propGetCode()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().Code);
      }
      private void propSetCode(HL7Connect.Cda.CD value)
      {
        wrapped().Code = value.wrapped();
      }
      ///<summary>
      /// Code that identifies the observation (mandatory)
      ///</summary>
      public HL7Connect.Cda.CD Code { get { return propGetCode(); } set { propSetCode(value); } }

      ///<summary>
      /// Biologically timing of condition
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// Biologically timing of condition
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> Time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// observation value. a data type (any one)
      ///</summary>
      private HL7Connect.Cda.ListANY propGetValue()
      {
        return HL7Connect.Cda.WrapperFactory.ListANY(wrapped().Value);
      }
      ///<summary>
      /// observation value. a data type (any one)
      ///</summary>
      public HL7Connect.Cda.ListANY Value { get { return propGetValue(); } }

    }

    public class ProblemObservationList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ProblemObservation>
    {
      public ProblemObservationList(ICCDProblemObservationList com) : base(com) {}
      internal new HCCCDProblemObservationList wrapped() { return (HCCCDProblemObservationList) com; }
  
      public ProblemObservation this[int index]
      {
        get { return new ProblemObservation(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ProblemObservation item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ProblemObservation Append()
      {
        return new ProblemObservation(wrapped().Append());
      }
  
      public void Insert(int index, ProblemObservation item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ProblemObservation item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ProblemObservation item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ProblemObservation[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ProblemObservation(wrapped().Item(i));
      }
  
      public bool Remove(ProblemObservation item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ProblemObservationListEnumerator : IEnumerator<ProblemObservation>
      {
        private ICCDProblemObservationList com;
        int index = -1;
  
        public ProblemObservationListEnumerator(ICCDProblemObservationList com)
        {
          this.com = com;
        }
  
        public ProblemObservation Current { get { return new ProblemObservation(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ProblemObservation(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ProblemObservation> GetEnumerator()
      {
        return new ProblemObservationListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ProblemObservationListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a statement of a problem
    ///</summary>
    public class ProblemAct : HL7Connect.Utils.Base
    {

      internal ProblemAct(ICCDProblemAct com) : base(com) {} 

      internal new HCCCDProblemAct wrapped() { return (HCCCDProblemAct) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.Entry propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.Entry CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// identifiers for the result. There should be at least one.
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// identifiers for the result. There should be at least one.
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// The interval of time for which the problem is a concern (optional)
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// The interval of time for which the problem is a concern (optional)
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> Time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// Status Code for the encounter (optional)
      ///</summary>
      private HL7Connect.Cda.CS propGetStatusCode()
      {
        return HL7Connect.Cda.WrapperFactory.CS(wrapped().statusCode);
      }
      private void propSetStatusCode(HL7Connect.Cda.CS value)
      {
        wrapped().statusCode = value.wrapped();
      }
      ///<summary>
      /// Status Code for the encounter (optional)
      ///</summary>
      public HL7Connect.Cda.CS StatusCode { get { return propGetStatusCode(); } set { propSetStatusCode(value); } }

      ///<summary>
      /// Actual results grouped by the organizer. SHALL be at least one
      ///</summary>
      private HL7Connect.Ccd.ProblemObservationList propGetProblemObservationList()
      {
        return HL7Connect.Ccd.WrapperFactory.ProblemObservationList(wrapped().ProblemObservationList);
      }
      ///<summary>
      /// Actual results grouped by the organizer. SHALL be at least one
      ///</summary>
      public HL7Connect.Ccd.ProblemObservationList ProblemObservationList { get { return propGetProblemObservationList(); } }

    }

    public class ProblemActList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<ProblemAct>
    {
      public ProblemActList(ICCDProblemActList com) : base(com) {}
      internal new HCCCDProblemActList wrapped() { return (HCCCDProblemActList) com; }
  
      public ProblemAct this[int index]
      {
        get { return new ProblemAct(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(ProblemAct item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public ProblemAct Append()
      {
        return new ProblemAct(wrapped().Append());
      }
  
      public void Insert(int index, ProblemAct item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(ProblemAct item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(ProblemAct item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(ProblemAct[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new ProblemAct(wrapped().Item(i));
      }
  
      public bool Remove(ProblemAct item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class ProblemActListEnumerator : IEnumerator<ProblemAct>
      {
        private ICCDProblemActList com;
        int index = -1;
  
        public ProblemActListEnumerator(ICCDProblemActList com)
        {
          this.com = com;
        }
  
        public ProblemAct Current { get { return new ProblemAct(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new ProblemAct(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<ProblemAct> GetEnumerator()
      {
        return new ProblemActListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new ProblemActListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a Problems
    ///</summary>
    public class Problems : HL7Connect.Utils.Base
    {

      internal Problems(ICCDProblems com) : base(com) {} 

      internal new HCCCDProblems wrapped() { return (HCCCDProblems) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      private HL7Connect.Cda.Section propGetCDASection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().CDASection);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      public HL7Connect.Cda.Section CDASection { get { return propGetCDASection(); } }

      ///<summary>
      /// The Problems section is expected to have some narrative describing the Problems. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      private HL7Connect.Ccd.NarrativeBuilder propGetNarrative()
      {
        return HL7Connect.Ccd.WrapperFactory.NarrativeBuilder(wrapped().Narrative);
      }
      ///<summary>
      /// The Problems section is expected to have some narrative describing the Problems. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      public HL7Connect.Ccd.NarrativeBuilder Narrative { get { return propGetNarrative(); } }

      ///<summary>
      ///</summary>
      private HL7Connect.Ccd.ProblemActList propGetProblemActList()
      {
        return HL7Connect.Ccd.WrapperFactory.ProblemActList(wrapped().ProblemActList);
      }
      ///<summary>
      ///</summary>
      public HL7Connect.Ccd.ProblemActList ProblemActList { get { return propGetProblemActList(); } }

    }

    ///<summary>
    /// Describes the Relative that a family history entry is about 
    /// 
    /// The Age of the patient may be inferred from these details, but the age of the patient associated with any particular observation may also be reported directly (i.e Uncle Joe was born 1955, passed away when 53 years old, but had a heart attack in his 40s)
    ///</summary>
    public class FamilyHistoryRelative : HL7Connect.Utils.Base
    {

      internal FamilyHistoryRelative(ICCDFamilyHistoryRelative com) : base(com) {} 

      internal new HCCCDFamilyHistoryRelative wrapped() { return (HCCCDFamilyHistoryRelative) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA RelatedSubject (may not be null)
      ///</summary>
      private HL7Connect.Cda.Subject propGetCDASubject()
      {
        return HL7Connect.Cda.WrapperFactory.Subject(wrapped().CDASubject);
      }
      ///<summary>
      /// Underlying CDA RelatedSubject (may not be null)
      ///</summary>
      public HL7Connect.Cda.Subject CDASubject { get { return propGetCDASubject(); } }

      ///<summary>
      /// how this relative is related to the subject of the document
      ///</summary>
      private HL7Connect.Cda.CD propGetRelationshipType()
      {
        return HL7Connect.Cda.WrapperFactory.CD(wrapped().RelationshipType);
      }
      private void propSetRelationshipType(HL7Connect.Cda.CD value)
      {
        wrapped().RelationshipType = value.wrapped();
      }
      ///<summary>
      /// how this relative is related to the subject of the document
      ///</summary>
      public HL7Connect.Cda.CD RelationshipType { get { return propGetRelationshipType(); } set { propSetRelationshipType(value); } }

      ///<summary>
      /// Gender for the relative. Possible values : GenderNull, GenderMale, GenderFemale, GenderUndifferentiated 
      /// 
      /// -- Valid Genders in a CCD document GenderNullGenderMaleGenderFemaleGenderUndifferentiated
      ///</summary>
      private TCCDGender propGetGender()
      {
        return wrapped().Gender;
      }
      private void propSetGender(TCCDGender value)
      {
        wrapped().Gender = value;
      }
      ///<summary>
      /// Gender for the relative. Possible values : GenderNull, GenderMale, GenderFemale, GenderUndifferentiated 
      /// 
      /// -- Valid Genders in a CCD document GenderNullGenderMaleGenderFemaleGenderUndifferentiated
      ///</summary>
      public TCCDGender Gender { get { return propGetGender(); } set { propSetGender(value); } }

      ///<summary>
      /// birth date for the patient. (may be null)
      ///</summary>
      private HL7Connect.Cda.TS propGetBirthTime()
      {
        return HL7Connect.Cda.WrapperFactory.TS(wrapped().birthTime);
      }
      private void propSetBirthTime(HL7Connect.Cda.TS value)
      {
        wrapped().birthTime = value.wrapped();
      }
      ///<summary>
      /// birth date for the patient. (may be null)
      ///</summary>
      public HL7Connect.Cda.TS BirthTime { get { return propGetBirthTime(); } set { propSetBirthTime(value); } }

    }

    ///<summary>
    /// An observation of a problem in family history 
    /// 
    /// May be cause of death or not. May have a problem observation Other observations are available through CDAEntry
    ///</summary>
    public class FamilyHistoryObservation : HL7Connect.Utils.Base
    {

      internal FamilyHistoryObservation(ICCDFamilyHistoryObservation com) : base(com) {} 

      internal new HCCCDFamilyHistoryObservation wrapped() { return (HCCCDFamilyHistoryObservation) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.EntryRelationship propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.EntryRelationship(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.EntryRelationship CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// Whether this is a cause of notification
      ///</summary>
      private bool propGetIsCauseOfDeath()
      {
        return wrapped().IsCauseOfDeath != 0;
      }
      private void propSetIsCauseOfDeath(bool value)
      {
        wrapped().IsCauseOfDeath = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// Whether this is a cause of notification
      ///</summary>
      public bool IsCauseOfDeath { get { return propGetIsCauseOfDeath(); } set { propSetIsCauseOfDeath(value); } }

      ///<summary>
      /// List of ids that for the observation (at least one)
      ///</summary>
      private HL7Connect.Cda.ListII propGetIdList()
      {
        return HL7Connect.Cda.WrapperFactory.ListII(wrapped().IdList);
      }
      ///<summary>
      /// List of ids that for the observation (at least one)
      ///</summary>
      public HL7Connect.Cda.ListII IdList { get { return propGetIdList(); } }

      ///<summary>
      /// Time of the observation - the time the thing being observed/reported actually happened (may be unknown)
      ///</summary>
      private HL7Connect.Cda.IVL<HL7Connect.Cda.TS> propGetTime()
      {
        return HL7Connect.Cda.WrapperFactory.IVL<HL7Connect.Cda.TS>(wrapped().time);
      }
      private void propSetTime(HL7Connect.Cda.IVL<HL7Connect.Cda.TS> value)
      {
        wrapped().time = value.wrapped();
      }
      ///<summary>
      /// Time of the observation - the time the thing being observed/reported actually happened (may be unknown)
      ///</summary>
      public HL7Connect.Cda.IVL<HL7Connect.Cda.TS> Time { get { return propGetTime(); } set { propSetTime(value); } }

      ///<summary>
      /// The age of the relative at the time of the observation (if known) Uncertainty can be indicated by using Age.Uncertainty
      ///</summary>
      private HL7Connect.Cda.PQ propGetAge()
      {
        return HL7Connect.Cda.WrapperFactory.PQ(wrapped().Age);
      }
      private void propSetAge(HL7Connect.Cda.PQ value)
      {
        wrapped().Age = value.wrapped();
      }
      ///<summary>
      /// The age of the relative at the time of the observation (if known) Uncertainty can be indicated by using Age.Uncertainty
      ///</summary>
      public HL7Connect.Cda.PQ Age { get { return propGetAge(); } set { propSetAge(value); } }

      ///<summary>
      /// The problem this is about (may be null)
      ///</summary>
      private HL7Connect.Ccd.ProblemAct propGetProblem()
      {
        return HL7Connect.Ccd.WrapperFactory.ProblemAct(wrapped().Problem);
      }
      private void propSetProblem(HL7Connect.Ccd.ProblemAct value)
      {
        wrapped().Problem = value.wrapped();
      }
      ///<summary>
      /// The problem this is about (may be null)
      ///</summary>
      public HL7Connect.Ccd.ProblemAct Problem { get { return propGetProblem(); } set { propSetProblem(value); } }

    }

    public class FamilyHistoryObservationList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<FamilyHistoryObservation>
    {
      public FamilyHistoryObservationList(ICCDFamilyHistoryObservationList com) : base(com) {}
      internal new HCCCDFamilyHistoryObservationList wrapped() { return (HCCCDFamilyHistoryObservationList) com; }
  
      public FamilyHistoryObservation this[int index]
      {
        get { return new FamilyHistoryObservation(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(FamilyHistoryObservation item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public FamilyHistoryObservation Append()
      {
        return new FamilyHistoryObservation(wrapped().Append());
      }
  
      public void Insert(int index, FamilyHistoryObservation item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(FamilyHistoryObservation item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(FamilyHistoryObservation item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(FamilyHistoryObservation[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new FamilyHistoryObservation(wrapped().Item(i));
      }
  
      public bool Remove(FamilyHistoryObservation item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class FamilyHistoryObservationListEnumerator : IEnumerator<FamilyHistoryObservation>
      {
        private ICCDFamilyHistoryObservationList com;
        int index = -1;
  
        public FamilyHistoryObservationListEnumerator(ICCDFamilyHistoryObservationList com)
        {
          this.com = com;
        }
  
        public FamilyHistoryObservation Current { get { return new FamilyHistoryObservation(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new FamilyHistoryObservation(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<FamilyHistoryObservation> GetEnumerator()
      {
        return new FamilyHistoryObservationListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new FamilyHistoryObservationListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// Family History Observations about a single Relative.
    ///</summary>
    public class FamilyHistoryEntry : HL7Connect.Utils.Base
    {

      internal FamilyHistoryEntry(ICCDFamilyHistoryEntry com) : base(com) {} 

      internal new HCCCDFamilyHistoryEntry wrapped() { return (HCCCDFamilyHistoryEntry) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      private HL7Connect.Cda.Entry propGetCDAEntry()
      {
        return HL7Connect.Cda.WrapperFactory.Entry(wrapped().CDAEntry);
      }
      ///<summary>
      /// Underlying CDA Entry (may not be null)
      ///</summary>
      public HL7Connect.Cda.Entry CDAEntry { get { return propGetCDAEntry(); } }

      ///<summary>
      /// The details of who this is about
      ///</summary>
      private HL7Connect.Ccd.FamilyHistoryRelative propGetRelative()
      {
        return HL7Connect.Ccd.WrapperFactory.FamilyHistoryRelative(wrapped().Relative);
      }
      ///<summary>
      /// The details of who this is about
      ///</summary>
      public HL7Connect.Ccd.FamilyHistoryRelative Relative { get { return propGetRelative(); } }

      ///<summary>
      /// In a CCD document, a family history entry on an indvidual can be represented as either an organiser with a subject and a series of obseravations, or as an observation with a subject. Which it is represented by this property. Note that this must be true if there is more than one observation
      ///</summary>
      private bool propGetIsExplicit()
      {
        return wrapped().IsExplicit != 0;
      }
      private void propSetIsExplicit(bool value)
      {
        wrapped().IsExplicit = value ? (sbyte) -1 : (sbyte) 0;
      }
      ///<summary>
      /// In a CCD document, a family history entry on an indvidual can be represented as either an organiser with a subject and a series of obseravations, or as an observation with a subject. Which it is represented by this property. Note that this must be true if there is more than one observation
      ///</summary>
      public bool IsExplicit { get { return propGetIsExplicit(); } set { propSetIsExplicit(value); } }

      ///<summary>
      /// One of more observations about the relative
      ///</summary>
      private HL7Connect.Ccd.FamilyHistoryObservationList propGetObservationList()
      {
        return HL7Connect.Ccd.WrapperFactory.FamilyHistoryObservationList(wrapped().ObservationList);
      }
      ///<summary>
      /// One of more observations about the relative
      ///</summary>
      public HL7Connect.Ccd.FamilyHistoryObservationList ObservationList { get { return propGetObservationList(); } }

    }

    public class FamilyHistoryEntryList : HL7Connect.Utils.Base, HL7Connect.Utils.IHL7ConnectList<FamilyHistoryEntry>
    {
      public FamilyHistoryEntryList(ICCDFamilyHistoryEntryList com) : base(com) {}
      internal new HCCCDFamilyHistoryEntryList wrapped() { return (HCCCDFamilyHistoryEntryList) com; }
  
      public FamilyHistoryEntry this[int index]
      {
        get { return new FamilyHistoryEntry(wrapped().Item(index)); }
        set { wrapped().SetItemByIndex(index, value.wrapped()); }
      }
  
      public int IndexOf(FamilyHistoryEntry item)
      {
        return wrapped().IndexOf(item.wrapped());
      }
  
      public FamilyHistoryEntry Append()
      {
        return new FamilyHistoryEntry(wrapped().Append());
      }
  
      public void Insert(int index, FamilyHistoryEntry item)
      {
        wrapped().InsertItem(index, item.wrapped());
      }
  
      public void RemoveAt(int index)
      {
        wrapped().Remove(index);
      }
  
      public int Count { get { return wrapped().Count(); } }
  
      public bool IsReadOnly { get { return false; } }
  
      public void Add(FamilyHistoryEntry item)
      {
        wrapped().AddItem(item.wrapped());
      }
  
      public void Clear()
      {
        wrapped().ClearItems();
      }
  
      public bool Contains(FamilyHistoryEntry item)
      {
        return wrapped().IndexOf(item.wrapped()) > -1;
      }
  
      public void CopyTo(FamilyHistoryEntry[] array, int arrayIndex)
      {
        var l = wrapped().Count();
        if (array.Length < arrayIndex + l)
          throw new ArgumentException("Array must be "+(arrayIndex + l).ToString()+" in length");
        for (int i = 0; i < l; i++)
          array[i + arrayIndex] = new FamilyHistoryEntry(wrapped().Item(i));
      }
  
      public bool Remove(FamilyHistoryEntry item)
      {
        var i = wrapped().IndexOf(item.wrapped());
        if (i > -1)
          wrapped().Remove(i);
        return i > -1;
      }
  
      public class FamilyHistoryEntryListEnumerator : IEnumerator<FamilyHistoryEntry>
      {
        private ICCDFamilyHistoryEntryList com;
        int index = -1;
  
        public FamilyHistoryEntryListEnumerator(ICCDFamilyHistoryEntryList com)
        {
          this.com = com;
        }
  
        public FamilyHistoryEntry Current { get { return new FamilyHistoryEntry(com.Item(index)); } }
  
        public void Dispose() {}
  
  
        public bool MoveNext()
        {
          index++;
          return index < com.Count();
        }
  
        public void Reset()
        {
          index = -1;
        }
  
        object System.Collections.IEnumerator.Current
        {
          get { { return new FamilyHistoryEntry(com.Item(index)); } }
        }
  
      }
  
      public IEnumerator<FamilyHistoryEntry> GetEnumerator()
      {
        return new FamilyHistoryEntryListEnumerator(wrapped());
      }
  
      System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
      {
        return new FamilyHistoryEntryListEnumerator(wrapped());
      }
  
    }
  
    ///<summary>
    /// a FamilyHistory
    ///</summary>
    public class FamilyHistory : HL7Connect.Utils.Base
    {

      internal FamilyHistory(ICCDFamilyHistory com) : base(com) {} 

      internal new HCCCDFamilyHistory wrapped() { return (HCCCDFamilyHistory) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      private HL7Connect.Cda.Section propGetCDASection()
      {
        return HL7Connect.Cda.WrapperFactory.Section(wrapped().CDASection);
      }
      ///<summary>
      /// Underlying CDA Section
      ///</summary>
      public HL7Connect.Cda.Section CDASection { get { return propGetCDASection(); } }

      ///<summary>
      /// The FamilyHistory section is must have some narrative describing the FamilyHistory. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      private HL7Connect.Ccd.NarrativeBuilder propGetNarrative()
      {
        return HL7Connect.Ccd.WrapperFactory.NarrativeBuilder(wrapped().Narrative);
      }
      ///<summary>
      /// The FamilyHistory section is must have some narrative describing the FamilyHistory. 
      /// 
      /// The Narrative can be used to help build it. It doesn't really help you read it. Future: Add as HTML property?
      ///</summary>
      public HL7Connect.Ccd.NarrativeBuilder Narrative { get { return propGetNarrative(); } }

      ///<summary>
      /// Details of the FamilyHistory - either Entrys or Organizers that contain Entrys
      ///</summary>
      private HL7Connect.Ccd.FamilyHistoryEntryList propGetFamilyHistoryEntryList()
      {
        return HL7Connect.Ccd.WrapperFactory.FamilyHistoryEntryList(wrapped().FamilyHistoryEntryList);
      }
      ///<summary>
      /// Details of the FamilyHistory - either Entrys or Organizers that contain Entrys
      ///</summary>
      public HL7Connect.Ccd.FamilyHistoryEntryList FamilyHistoryEntryList { get { return propGetFamilyHistoryEntryList(); } }

    }

    ///<summary>
    /// The CDA library provides a general model for CDA documents. CCD is a profile on the general CDA model which makes many restrictions on the content of the CDA document, and also provides business names that help to map the somewhat abstract names of the CDA document to the CCD context of use. 
    /// 
    /// The CCD builder provides an object API over the top of an underlying CDA that make it easy to build a CCD document by filling out all the fixed values, and expressing the API in terms of the business names defined in the CCD specification. The API is intentionally simplified, but the underlying CDA classes can be accessed through the API if more content is desired that is not fixed by the CCD specification. The CCD builder is also useful when reading CCD documents, as it surfaces the existing document through the CCD API. The CCD Builder is access through the events, by using the UseCCD() routine.
    ///</summary>
    public class Builder : HL7Connect.Utils.Base
    {

      internal Builder(ICCDBuilder com) : base(com) {} 

      internal new HCCCDBuilder wrapped() { return (HCCCDBuilder) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Underlying CDA docuemnt (may be null if not building)
      ///</summary>
      private HL7Connect.Cda.ClinicalDocument propGetCDA()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().CDA);
      }
      ///<summary>
      /// Underlying CDA docuemnt (may be null if not building)
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument CDA { get { return propGetCDA(); } }

      ///<summary>
      /// The title of the document
      ///</summary>
      private string propGetTitle()
      {
        return wrapped().title;
      }
      private void propSetTitle(string value)
      {
        wrapped().title = value;
      }
      ///<summary>
      /// The title of the document
      ///</summary>
      public string Title { get { return propGetTitle(); } set { propSetTitle(value); } }

      ///<summary>
      /// Identity of the document {mandatory; may be null if reading and document is not conformant)
      ///</summary>
      private HL7Connect.Cda.II propGetId()
      {
        return HL7Connect.Cda.WrapperFactory.II(wrapped().ID);
      }
      ///<summary>
      /// Identity of the document {mandatory; may be null if reading and document is not conformant)
      ///</summary>
      public HL7Connect.Cda.II Id { get { return propGetId(); } }

      ///<summary>
      /// the language of the document. (will not be null)
      ///</summary>
      private string propGetLanguageCode()
      {
        return wrapped().languageCode;
      }
      private void propSetLanguageCode(string value)
      {
        wrapped().languageCode = value;
      }
      ///<summary>
      /// the language of the document. (will not be null)
      ///</summary>
      public string LanguageCode { get { return propGetLanguageCode(); } set { propSetLanguageCode(value); } }

      ///<summary>
      /// The main activity being described by a CCD is the provision of healthcare over a period of time. The ServiceEvent describes the activity (will not be null)
      ///</summary>
      private HL7Connect.Ccd.ServiceEvent propGetServiceEvent()
      {
        return HL7Connect.Ccd.WrapperFactory.ServiceEvent(wrapped().serviceEvent);
      }
      ///<summary>
      /// The main activity being described by a CCD is the provision of healthcare over a period of time. The ServiceEvent describes the activity (will not be null)
      ///</summary>
      public HL7Connect.Ccd.ServiceEvent ServiceEvent { get { return propGetServiceEvent(); } }

      ///<summary>
      /// The patient concerning which the document is about. (will not be null)
      ///</summary>
      private HL7Connect.Ccd.Patient propGetPatient()
      {
        return HL7Connect.Ccd.WrapperFactory.Patient(wrapped().patient);
      }
      ///<summary>
      /// The patient concerning which the document is about. (will not be null)
      ///</summary>
      public HL7Connect.Ccd.Patient Patient { get { return propGetPatient(); } }

      ///<summary>
      /// A second patient, for the rare case in which the document concerns a pair of conjoined twins. (will be null when reading if not in source document)
      ///</summary>
      private HL7Connect.Ccd.Patient propGetPatient2()
      {
        return HL7Connect.Ccd.WrapperFactory.Patient(wrapped().Patient2);
      }
      ///<summary>
      /// A second patient, for the rare case in which the document concerns a pair of conjoined twins. (will be null when reading if not in source document)
      ///</summary>
      public HL7Connect.Ccd.Patient Patient2 { get { return propGetPatient2(); } }

      ///<summary>
      /// Identifies who or what has generated the summarization (will not be null. a valid document must have at least one entry)
      ///</summary>
      private HL7Connect.Ccd.FromList propGetFromList()
      {
        return HL7Connect.Ccd.WrapperFactory.FromList(wrapped().FromList);
      }
      ///<summary>
      /// Identifies who or what has generated the summarization (will not be null. a valid document must have at least one entry)
      ///</summary>
      public HL7Connect.Ccd.FromList FromList { get { return propGetFromList(); } }

      ///<summary>
      /// Represents the specific reason for which the summarization was generated, such as in response to a request. 
      /// 
      /// (may be null if reading and the source document does not contain a purpose)
      ///</summary>
      private HL7Connect.Ccd.Purpose propGetPurpose()
      {
        return HL7Connect.Ccd.WrapperFactory.Purpose(wrapped().Purpose);
      }
      ///<summary>
      /// Represents the specific reason for which the summarization was generated, such as in response to a request. 
      /// 
      /// (may be null if reading and the source document does not contain a purpose)
      ///</summary>
      public HL7Connect.Ccd.Purpose Purpose { get { return propGetPurpose(); } }

      ///<summary>
      /// Payers contains data on the patient's payers, whether a 'third party' insurance, self-pay, other payer or guarantor, or some combination of payers, and is used to define which entity is the responsible fiduciary for the financial aspects of a patie 
      /// 
      /// (may be null if reading and the source document does not contain a Payer)
      ///</summary>
      private HL7Connect.Ccd.Payers propGetPayers()
      {
        return HL7Connect.Ccd.WrapperFactory.Payers(wrapped().Payers);
      }
      ///<summary>
      /// Payers contains data on the patient's payers, whether a 'third party' insurance, self-pay, other payer or guarantor, or some combination of payers, and is used to define which entity is the responsible fiduciary for the financial aspects of a patie 
      /// 
      /// (may be null if reading and the source document does not contain a Payer)
      ///</summary>
      public HL7Connect.Ccd.Payers Payers { get { return propGetPayers(); } }

      ///<summary>
      /// Encounters contains data on any of the the patient's Encounters that are pertinent to the patient's current health status. 
      /// 
      /// (may be null if reading and the source document does not contain a Encounter)
      ///</summary>
      private HL7Connect.Ccd.Encounters propGetEncounters()
      {
        return HL7Connect.Ccd.WrapperFactory.Encounters(wrapped().Encounters);
      }
      ///<summary>
      /// Encounters contains data on any of the the patient's Encounters that are pertinent to the patient's current health status. 
      /// 
      /// (may be null if reading and the source document does not contain a Encounter)
      ///</summary>
      public HL7Connect.Ccd.Encounters Encounters { get { return propGetEncounters(); } }

      ///<summary>
      /// Results - lab, imaging etc.
      ///</summary>
      private HL7Connect.Ccd.Results propGetResults()
      {
        return HL7Connect.Ccd.WrapperFactory.Results(wrapped().Results);
      }
      ///<summary>
      /// Results - lab, imaging etc.
      ///</summary>
      public HL7Connect.Ccd.Results Results { get { return propGetResults(); } }

      ///<summary>
      /// Problems - All relevant clinical problems at the time the summary is generated
      ///</summary>
      private HL7Connect.Ccd.Problems propGetProblems()
      {
        return HL7Connect.Ccd.WrapperFactory.Problems(wrapped().Problems);
      }
      ///<summary>
      /// Problems - All relevant clinical problems at the time the summary is generated
      ///</summary>
      public HL7Connect.Ccd.Problems Problems { get { return propGetProblems(); } }

      ///<summary>
      /// FamilyHistory - Data defining the patients genetic relatives in terms of possible or relevant health risk factors that have a potential impact on the patient's healthcare risk profile
      ///</summary>
      private HL7Connect.Ccd.FamilyHistory propGetFamilyHistory()
      {
        return HL7Connect.Ccd.WrapperFactory.FamilyHistory(wrapped().FamilyHistory);
      }
      ///<summary>
      /// FamilyHistory - Data defining the patients genetic relatives in terms of possible or relevant health risk factors that have a potential impact on the patient's healthcare risk profile
      ///</summary>
      public HL7Connect.Ccd.FamilyHistory FamilyHistory { get { return propGetFamilyHistory(); } }

    }

    ///<summary>
    /// Used to build new instances of CCD related classes
    ///</summary>
    public class Factory : HL7Connect.Utils.Base
    {

      internal Factory(ICCDFactory com) : base(com) {} 

      internal new HCCCDFactory wrapped() { return (HCCCDFactory) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Create a CCD Device
      ///</summary>
      public HL7Connect.Ccd.Device newDevice()
      {
        return HL7Connect.Ccd.WrapperFactory.Device(wrapped().newDevice());
      }

      ///<summary>
      /// Create a CCD Person
      ///</summary>
      public HL7Connect.Ccd.Person newPerson()
      {
        return HL7Connect.Ccd.WrapperFactory.Person(wrapped().newPerson());
      }

      ///<summary>
      /// Create a CCD Organization
      ///</summary>
      public HL7Connect.Ccd.Organization newOrganization()
      {
        return HL7Connect.Ccd.WrapperFactory.Organization(wrapped().newOrganization());
      }

    }

    internal class WrapperFactory
    {
      private static Factory fWorkingFactory;
      internal static Factory WorkingFactory
      {
        get
        {
          if (fWorkingFactory == null)
            throw new Exception("You must set HL7Connect.Cda.WrapperFactory.WorkingFactory before using direct constructors of Ccd classes");
          return fWorkingFactory;
        }
        set
        {
          fWorkingFactory = value;
        }
      }
      internal static HL7Connect.Ccd.ContentBuilder ContentBuilder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ContentBuilder((ICCDContentBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.ParagraphBuilder ParagraphBuilder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ParagraphBuilder((ICCDParagraphBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.ListBuilder ListBuilder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ListBuilder((ICCDListBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.TableRowBuilder TableRowBuilder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.TableRowBuilder((ICCDTableRowBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.TableBuilder TableBuilder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.TableBuilder((ICCDTableBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.NarrativeBuilder NarrativeBuilder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.NarrativeBuilder((ICCDNarrativeBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.ServiceEvent ServiceEvent(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ServiceEvent((ICCDServiceEvent) wrapped);
      }

      internal static HL7Connect.Ccd.Patient Patient(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Patient((ICCDPatient) wrapped);
      }

      internal static HL7Connect.Ccd.Device Device(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Device((ICCDDevice) wrapped);
      }

      internal static HL7Connect.Ccd.Person Person(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Person((ICCDPerson) wrapped);
      }

      internal static HL7Connect.Ccd.Organization Organization(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Organization((ICCDOrganization) wrapped);
      }

      internal static HL7Connect.Ccd.From From(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.From((ICCDFrom) wrapped);
      }

      internal static HL7Connect.Ccd.FromList FromList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FromList((ICCDFromList) wrapped);
      }

      internal static HL7Connect.Ccd.PurposeStatement PurposeStatement(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.PurposeStatement((ICCDPurposeStatement) wrapped);
      }

      internal static HL7Connect.Ccd.PurposeStatementList PurposeStatementList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.PurposeStatementList((ICCDPurposeStatementList) wrapped);
      }

      internal static HL7Connect.Ccd.Purpose Purpose(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Purpose((ICCDPurpose) wrapped);
      }

      internal static HL7Connect.Ccd.AuthorizationActivity AuthorizationActivity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.AuthorizationActivity((ICCDAuthorizationActivity) wrapped);
      }

      internal static HL7Connect.Ccd.AuthorizationActivityList AuthorizationActivityList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.AuthorizationActivityList((ICCDAuthorizationActivityList) wrapped);
      }

      internal static HL7Connect.Ccd.PolicyActivity PolicyActivity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.PolicyActivity((ICCDPolicyActivity) wrapped);
      }

      internal static HL7Connect.Ccd.PolicyActivityList PolicyActivityList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.PolicyActivityList((ICCDPolicyActivityList) wrapped);
      }

      internal static HL7Connect.Ccd.CoverageActivity CoverageActivity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.CoverageActivity((ICCDCoverageActivity) wrapped);
      }

      internal static HL7Connect.Ccd.CoverageActivityList CoverageActivityList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.CoverageActivityList((ICCDCoverageActivityList) wrapped);
      }

      internal static HL7Connect.Ccd.Payers Payers(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Payers((ICCDPayers) wrapped);
      }

      internal static HL7Connect.Ccd.EncounterLocation EncounterLocation(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.EncounterLocation((ICCDEncounterLocation) wrapped);
      }

      internal static HL7Connect.Ccd.EncounterLocationList EncounterLocationList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.EncounterLocationList((ICCDEncounterLocationList) wrapped);
      }

      internal static HL7Connect.Ccd.EncounterActivity EncounterActivity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.EncounterActivity((ICCDEncounterActivity) wrapped);
      }

      internal static HL7Connect.Ccd.EncounterActivityList EncounterActivityList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.EncounterActivityList((ICCDEncounterActivityList) wrapped);
      }

      internal static HL7Connect.Ccd.Encounters Encounters(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Encounters((ICCDEncounters) wrapped);
      }

      internal static HL7Connect.Ccd.ResultObservation ResultObservation(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ResultObservation((ICCDResultObservation) wrapped);
      }

      internal static HL7Connect.Ccd.ResultObservationList ResultObservationList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ResultObservationList((ICCDResultObservationList) wrapped);
      }

      internal static HL7Connect.Ccd.ResultOrganizer ResultOrganizer(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ResultOrganizer((ICCDResultOrganizer) wrapped);
      }

      internal static HL7Connect.Ccd.ResultOrganizerList ResultOrganizerList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ResultOrganizerList((ICCDResultOrganizerList) wrapped);
      }

      internal static HL7Connect.Ccd.Results Results(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Results((ICCDResults) wrapped);
      }

      internal static HL7Connect.Ccd.ProblemObservation ProblemObservation(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ProblemObservation((ICCDProblemObservation) wrapped);
      }

      internal static HL7Connect.Ccd.ProblemObservationList ProblemObservationList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ProblemObservationList((ICCDProblemObservationList) wrapped);
      }

      internal static HL7Connect.Ccd.ProblemAct ProblemAct(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ProblemAct((ICCDProblemAct) wrapped);
      }

      internal static HL7Connect.Ccd.ProblemActList ProblemActList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.ProblemActList((ICCDProblemActList) wrapped);
      }

      internal static HL7Connect.Ccd.Problems Problems(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Problems((ICCDProblems) wrapped);
      }

      internal static HL7Connect.Ccd.FamilyHistoryRelative FamilyHistoryRelative(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FamilyHistoryRelative((ICCDFamilyHistoryRelative) wrapped);
      }

      internal static HL7Connect.Ccd.FamilyHistoryObservation FamilyHistoryObservation(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FamilyHistoryObservation((ICCDFamilyHistoryObservation) wrapped);
      }

      internal static HL7Connect.Ccd.FamilyHistoryObservationList FamilyHistoryObservationList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FamilyHistoryObservationList((ICCDFamilyHistoryObservationList) wrapped);
      }

      internal static HL7Connect.Ccd.FamilyHistoryEntry FamilyHistoryEntry(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FamilyHistoryEntry((ICCDFamilyHistoryEntry) wrapped);
      }

      internal static HL7Connect.Ccd.FamilyHistoryEntryList FamilyHistoryEntryList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FamilyHistoryEntryList((ICCDFamilyHistoryEntryList) wrapped);
      }

      internal static HL7Connect.Ccd.FamilyHistory FamilyHistory(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.FamilyHistory((ICCDFamilyHistory) wrapped);
      }

      internal static HL7Connect.Ccd.Builder Builder(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Builder((ICCDBuilder) wrapped);
      }

      internal static HL7Connect.Ccd.Factory Factory(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Ccd.Factory((ICCDFactory) wrapped);
      }

    }
  }
  namespace Services
  {
    ///<summary>
    /// Base for HL7 v2 services provided by HL7Connect
    ///</summary>
    public class HL7V2Manager : HL7Connect.Utils.Base
    {

      internal HL7V2Manager(IHL7V2Manager com) : base(com) {} 

      internal new HCHL7V2Manager wrapped() { return (HCHL7V2Manager) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Create a blank HL7 message
      ///</summary>
      public HL7Connect.V2.Message CreateMessage()
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().CreateMessage());
      }

      ///<summary>
      /// Create a blank HL7 message and set the version
      ///</summary>
      public HL7Connect.V2.Message CreateMessageForVersion(string version)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().CreateMessageForVersion(version));
      }

      ///<summary>
      /// Create a blank HL7 message and set the version, event, and structure (MSH-9-1 and MSH-9-2)
      ///</summary>
      public HL7Connect.V2.Message CreateMessageForEvent(string version, string event_, string msg)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().CreateMessageForEvent(version, event_, msg));
      }

      ///<summary>
      /// Read the stream as a v2 message. May be vertical bar or XML in any character encoding, with or without BOM. The entire stream will be read; it must start at the start of the message and end at the end of the message
      ///</summary>
      public HL7Connect.V2.Message CreateMessageFromStream(Stream stream)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().CreateMessageFromStream(new HL7Connect.Utils.StreamWrapper(stream)));
      }

      ///<summary>
      /// Clone an HL7 message to a new instance that can be modified without altering the original instance
      ///</summary>
      public HL7Connect.V2.Message Clone(HL7Connect.V2.Message message)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().Clone(message.wrapped()));
      }

      ///<summary>
      /// Save the message to a stream using the default encoding (the format it was read from, the format of the message to which it is an answer - if it is, or vertical bar format)
      ///</summary>
      public void SaveMessageToStream(HL7Connect.V2.Message message, Stream stream)
      {
        wrapped().SaveMessageToStream(message.wrapped(), new HL7Connect.Utils.StreamWrapper(stream));
      }

      ///<summary>
      /// Save the message to a stream using the specified format. Format is a series of tokens separated by spaces. The tokens may be one of the following: { XML;  ER7 (for vertical bar);  [char-encoding] where character encoding is ANSI, UTF-8, UTF-16BE etc. Default is ANSI for ER7 and UTF-8 for XML;  OptimisticMapping - when writing XML, how the segments are mapped against the segment structure. If this is not defined, then the list of segments must match the expected list. If this is not defined, then the mapping code will attempt to deal wit;  AllowMappingToFail - If this is set, then if mapping fails, any remaining segments not mapped will be mapped into the root segment. If this is not set, and mapping fails, then an exception will be raised and encoding will fail. Relevent for XML;  EscapeExtendedCharacters - When this is set the extended characters (non-ANSI) will automatically be escaped in ER7 format. Should only be used with character set ANSII;  ExtraFieldDelimiter - for OACIS system that requires an extra Field Delimiter at the end of every segment;  NoAddStructureName - whether to automatically encode the structure (if it can be determined by default it is added unless this option is set); }You can't specify logically incompatible options (such as XML and ER7)
      ///</summary>
      public void SaveMessageToStreamWithFormat(HL7Connect.V2.Message message, Stream stream, string format)
      {
        wrapped().SaveMessageToStreamWithFormat(message.wrapped(), new HL7Connect.Utils.StreamWrapper(stream), format);
      }

      ///<summary>
      /// The patient id of the message if it can be unambiguously determined. a null result may not indicate that a message does not contain an id, just that it cannot be determined with confidence without knowledge of specific interface busines rules. This function should only be used for messaging administration purposes (such as display in logs etc) and not when managing actual patient records
      ///</summary>
      public string GetPatientId(HL7Connect.V2.Message message)
      {
        return wrapped().GetPatientId(message.wrapped());
      }

      ///<summary>
      /// Create a transferred message ready for use with sending and/or receiving messages
      ///</summary>
      public HL7Connect.Exchange.TransferredMessage CreateTransferredMessage()
      {
        return HL7Connect.Exchange.WrapperFactory.TransferredMessage(wrapped().CreateTransferredMessage());
      }

      ///<summary>
      /// pass an HL7 v2 object to vbscript, javascript, COM, or OCL. 
      /// 
      /// script: the name of a file containing the source, or the source itself entrypoint: the name of the procedure to run, or the coclass name for com language: the name of the language to use. will be inferred from the file extension of the script if there is one. wantDebug: when using windows script host context: the object on which the scripting will occur - either a message, segment, dataelement, or component Note that the script can change the contents of the object passed to it. Any handles that the host retains to contents of the objects may be invalid after it executes (except for OCL, which cannot change the object) 1. Windows Script Host If the language is "VBScript", "JScript", or any other language string the Windows Script Host recognises, or if the file extension is (".vbs, *.js, *.py, *.pl). The script procedure is invoked with a single parameter which is an IExecuteHL7Event event. The kernel objects therwise available in when using scripts in HL7Connect will be null except for the WScript equivalent object. The script engine is Windows Script Host, like the rest of HL7Connect. The want debug flag is passed through to the windows script host engine for whether to invoke the debugger or not. 2. COM If the language is "COM", the script is ignored. The entry point is the coclass name of a registered class that implements the IHL7ConnectEventHandler interface (start mode is single threaded), which will be passed a IExecuteHL7Event. 3. OCL if the language is "OCL" or he file extension is ".ocl", the ocl provided will be executed against the message. If any assertions in the ocl script fail, an exception will be raised containing the details
      ///</summary>
      public void ExecuteScript(string script, string entryPoint, string language, string param, bool wantDebug, HL7Connect.V2.DataObject context)
      {
        wrapped().ExecuteScript(script, entryPoint, language, param, wantDebug ? (sbyte) 0 : (sbyte) -1, context.wrapped());
      }

      ///<summary>
      /// Build an IHL7Message by executing a KScript. The KScript must build a valid v2.xml version of a message. The script may be either a filename or the KScript directly
      ///</summary>
      public HL7Connect.V2.Message BuildByKScript(string script)
      {
        return HL7Connect.V2.WrapperFactory.Message(wrapped().BuildByKScript(script));
      }

    }

    ///<summary>
    /// Base for CDA and CCD services provided by HL7Connect
    ///</summary>
    public class CDAManager : HL7Connect.Utils.Base
    {

      internal CDAManager(ICDAManager com) : base(com) {} 

      internal new HCCDAManager wrapped() { return (HCCDAManager) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Create a blank CDA document. Fixed values will be populated
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument CreateDocument()
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().CreateDocument());
      }

      ///<summary>
      /// Create a blank CDA document that conforms to the CCD profile. values that are fixed in the CCD profile will be populated. The CCD builder offers a CCD-centric view of the document
      ///</summary>
      public HL7Connect.Ccd.Builder CreateCCD()
      {
        return HL7Connect.Ccd.WrapperFactory.Builder(wrapped().CreateCCD());
      }

      ///<summary>
      /// given a CDA document, provide a CCD-centric presentation of it. Caution: This may be misleading where the document does not conform to the CCD specification.
      ///</summary>
      public HL7Connect.Ccd.Builder CreateCCDFromDocument(HL7Connect.Cda.ClinicalDocument oDocument)
      {
        return HL7Connect.Ccd.WrapperFactory.Builder(wrapped().CreateCCDFromDocument(oDocument.wrapped()));
      }

      ///<summary>
      /// Read the stream as a CDA document. May be in any character encoding, with or without BOM. The entire stream will be read; it must start at the start of the document and end at the end of the document 
      /// 
      /// todo: is a DOM based method necessary? using what COM library?
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument CreateDocumentFromStream(Stream stream)
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().CreateDocumentFromStream(new HL7Connect.Utils.StreamWrapper(stream)));
      }

      ///<summary>
      /// Clone a CDA Document to a new instance that can be modified without altering the original instance
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument Clone(HL7Connect.Cda.ClinicalDocument document)
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().Clone(document.wrapped()));
      }

      ///<summary>
      /// Save the document to a stream using the default character set (UTF-8), and no pretty-printed
      ///</summary>
      public void SaveDocumentToStream(HL7Connect.Cda.ClinicalDocument Document, Stream stream)
      {
        wrapped().SaveDocumentToStream(Document.wrapped(), new HL7Connect.Utils.StreamWrapper(stream));
      }

      ///<summary>
      /// Save the document to a stream using the specified format. Format is a series of tokens separated by spaces. The tokens may be one of the following: { [char-encoding] where character encoding is ANSI, UTF-8, UTF-16BE etc. Default is ANSI for ER7 and UTF-8 for XML;  pretty - when writing XML, whether to include spaces for easy visibility; }You can only specify one character encoding. Since the list of character encodings is not limited, any unknown token will treated as a character encoding. The encoding is passed onto msxml - use one that msxml recognises.
      ///</summary>
      public void SaveDocumentToStreamWithFormat(HL7Connect.Cda.ClinicalDocument Document, Stream stream, string format)
      {
        wrapped().SaveDocumentToStreamWithFormat(Document.wrapped(), new HL7Connect.Utils.StreamWrapper(stream), format);
      }

      ///<summary>
      /// The patient id - the id identified by the provided OID. If OID is blank, the patient id if there is only one patient id. Otherwise the value will be null.
      ///</summary>
      public string GetPatientId(HL7Connect.Cda.ClinicalDocument Document, string oid)
      {
        return wrapped().GetPatientId(Document.wrapped(), oid);
      }

      ///<summary>
      /// Handle to the underlying CDA factory that can create any of the types that are part of a CDA document
      ///</summary>
      public HL7Connect.Cda.Factory CDAFactory()
      {
        return HL7Connect.Cda.WrapperFactory.Factory(wrapped().CDAFactory());
      }

      ///<summary>
      /// Handle to the underlying CCD factory that can create CCD types where required
      ///</summary>
      public HL7Connect.Ccd.Factory CCDFactory()
      {
        return HL7Connect.Ccd.WrapperFactory.Factory(wrapped().CCDFactory());
      }

      ///<summary>
      /// Create a transferred Document ready for use with sending and/or receiving Documents
      ///</summary>
      public HL7Connect.Exchange.TransferredDocument CreateTransferredDocument()
      {
        return HL7Connect.Exchange.WrapperFactory.TransferredDocument(wrapped().CreateTransferredDocument());
      }

      ///<summary>
      /// Select a set of objects by an XPath expression. 
      /// 
      /// The first parameter is the root for the XPath expression. To start at the root of the document, pass the CDA document itself, or nil. The second parameter is an XPath statement such as //v3:recordTarget/v3:patientRole/v3:id The namespace 'v3' is required on elements or the xpath won't work. Other namespaces that can be used in the XPath are xsi and the xml namespace itself. The return value is a list of the objects that match the selected XPath statement. The objects may be any of the Cda, structured text or data types. Only objects that have an element can be selected. Although you can execute xpath statements that match text, attributes, comments etc, these will never be able to be matched to any matching object, and nothing will be returned. For instance, executing the xpath above with the CDA document itself as the root will return the list of Iv3II identifiers for the patient. Note that the XPath statements operate on the original parsed XML, and the XML is not updated as the object model itself is changed. So if you add an identifier to the list of patient identifiers in a script, then execute the XPath above, the new identifier will not be returned. Further, deleting an identifier from the list, then rerunning the XPath statement, and trying to access the deleted object will cause unpredictable results (technically, the link from the XML back to the object model is not reference counted) Technical Note: The XPath expression is evaluated by the MSXML engine.
      ///</summary>
      public HL7Connect.Cda.BaseList XPath(HL7Connect.Cda.Base oRoot, string sExpression)
      {
        return HL7Connect.Cda.WrapperFactory.BaseList(wrapped().XPath(oRoot.wrapped(), sExpression));
      }

      ///<summary>
      /// pass a CDA Object to vbscript, javascript, COM, or OCL. 
      /// 
      /// script: the name of a file containing the source, or the source itself entrypoint: the name of the procedure to run, or the coclass name for com language: the name of the language to use. will be inferred from the file extension of the script if there is one. wantDebug: when using windows script host context: the object on which the scripting will occur - either a IcdaClinicalDocument, any other CDA class, any data type, or any structured text object Note that the script can change the contents of the object passed to it. Any handles that the host retains to contents of the objects may be invalid after it executes (except for OCL, which cannot change the object) 1. Windows Script Host If the language is "VBScript", "JScript", or any other language string the Windows Script Host recognises, or if the file extension is (".vbs, *.js, {.py, *.pl).; }The script procedure is invoked with a single parameter which is an IExecuteCDAEvent event. The kernel objects therwise available in when using scripts in HL7Connect will be null except for the WScript equivalent object. The script engine is Windows Script Host, like the rest of HL7Connect. The want debug flag is passed through to the windows script host engine for whether to invoke the debugger or not. 2. COM If the language is "COM", the script is ignored. The entry point is the coclass name of a registered class that implements the IHL7ConnectEventHandler interface (start mode is single threaded), which will be passed a IExecuteCDAEvent. 3. OCL if the language is "OCL" or he file extension is ".ocl", the ocl provided will be executed against the message. If any assertions in the ocl script fail, an exception will be raised containing the details
      ///</summary>
      public void ExecuteScript(string script, string entryPoint, string language, string param, bool wantDebug, HL7Connect.Cda.Base context)
      {
        wrapped().ExecuteScript(script, entryPoint, language, param, wantDebug ? (sbyte) 0 : (sbyte) -1, context.wrapped());
      }

      ///<summary>
      /// Build an IHL7Message by executing a KScript. The KScript must build a valid CDA document. The script may be either a filename or the KScript directly
      ///</summary>
      public HL7Connect.Cda.ClinicalDocument BuildByKScript(string script)
      {
        return HL7Connect.Cda.WrapperFactory.ClinicalDocument(wrapped().BuildByKScript(script));
      }

    }

    ///<summary>
    /// Factory and Utility services that HL7Connect provides to COM clients, whether internal or external
    ///</summary>
    public class Access : HL7Connect.Utils.Base
    {

      internal Access(IHL7ConnectServices com) : base(com) {} 

      internal new HCHL7ConnectServices wrapped() { return (HCHL7ConnectServices) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The current version of the HL7Connect COM Service
      ///</summary>
      public string Version()
      {
        return wrapped().Version();
      }

      ///<summary>
      /// Get a string describing the server. The string has the following parts: [Name], [licenseType] ([version]). 
      /// 
      /// If the context is the COM Client, and the library is initialised using initLocal, then no server is available, and this method will raise an eception Note that it is possible for the version returned by version and the server version to be out of sync if the library is running as a client and connecting to a server that is running a different version of HL7Connect.
      ///</summary>
      public string DescribeServer()
      {
        return wrapped().DescribeServer();
      }

      ///<summary>
      /// Get the HL7 v2 manager, which can be used to read, write, build, and transform HL7 V2 Messages
      ///</summary>
      public HL7Connect.Services.HL7V2Manager HL7()
      {
        return HL7Connect.Services.WrapperFactory.HL7V2Manager(wrapped().HL7());
      }

      ///<summary>
      /// Get the CDA manager, which can be used to read, write, build, and transform CDA and CCD documents.
      ///</summary>
      public HL7Connect.Services.CDAManager CDA()
      {
        return HL7Connect.Services.WrapperFactory.CDAManager(wrapped().CDA());
      }

      ///<summary>
      /// Get the ID Manager - provides OID services (IdByName and the HL7Connect OID are not avilable in the standalone library)
      ///</summary>
      public HL7Connect.Kernel.IdServices IDs()
      {
        return HL7Connect.Kernel.WrapperFactory.IdServices(wrapped().IDs());
      }

      ///<summary>
      /// Get the UCUM Manager - provides UCUM based unit and value services
      ///</summary>
      public HL7Connect.Ucum.Manager UCUM()
      {
        return HL7Connect.Ucum.WrapperFactory.Manager(wrapped().UCUM());
      }

      ///<summary>
      /// Get the Loinc Services - provides Loinc based unit and value services
      ///</summary>
      public HL7Connect.Loinc.Manager Loinc()
      {
        return HL7Connect.Loinc.WrapperFactory.Manager(wrapped().LOINC());
      }

      ///<summary>
      /// make an entry in the HL7Connect system log. (also displays on the telnet interface). The level relates to the level of debugging that the administrator chooses. The following levels are described (and available as constants in the script environment):  DBG_FATAL       1   Fatal Errors  DBG_SERIOUS     2   Serious Errors  DBG_ANNOUNCE    3   Announcements  DBG_WRONG       4   Code Logic Errors  DBG_EXCEPTION   6   Exceptions  DBG_ERROR       7   Operational Errors  DBG_WARNING     8   Warnings  DBG_PROCESS    10   Program Flow If the level is lower than that specified by the administrator then the message will be logged. If you log a fatal exception then HL7Connect will halt with no clean up immediately after logging the message
      ///</summary>
      public void Log(int Level, string content)
      {
        wrapped().Log(Level, content);
      }

      ///<summary>
      /// Send message to the nominated notification
      ///</summary>
      public void Notify(string name, string message)
      {
        wrapped().Notify(name, message);
      }

      ///<summary>
      /// unique number generator - returns a unique identifer in the scope of the given name.
      ///</summary>
      public int GetNextKey(string name)
      {
        return wrapped().GetNextKey(name);
      }

      ///<summary>
      /// Execute a kscript and return the output. Output may be any form - but it usually html or xml. 
      /// 
      /// script: the name of a file containing the source, or the source itself
      ///</summary>
      public string ExecuteKScript(string script)
      {
        return wrapped().ExecuteKScript(script);
      }

    }

    ///<summary>
    /// This is the master COM interface for the HL7Connect COM library. 
    /// 
    /// This is the only COM interface that is created directly; all the other objects are derived from factories generated by this interface The first method you must call is either InitServer or InitLocal. Once whichever of these has returned sucessfully, you are able to use any of the other methods. interface todo: { list users, get user details, updated passwords (by request);  list interfaces, start and stop interfaces (by request);  Snomed-CT, LOINC and UCUM services (planned for the next cycle of development); }
    ///</summary>
    public class Library : HL7Connect.Services.Access
    {

      public Library() : base(new HCHL7Connect())
      {
        HL7Connect.Cda.WrapperFactory.WorkingFactory = CDA().CDAFactory();
        HL7Connect.Ccd.WrapperFactory.WorkingFactory = CDA().CCDFactory();
      } 

      internal new HCHL7Connect wrapped() { return (HCHL7Connect) com; }

      ///<summary>
      /// Initalize the library, and connect and login to the specified HL7Connect. The server must be available and licensed with an Enterprise license or an exception will be thrown. The COM Library will continue to function if the server stops working, though some functionality that interacts with the server (messaging, etc) will be broken. 
      /// 
      /// Note that the COM Library uses web services to communicate with the noominated HL7Connect service. The COM library presents a fine grained facade to the coarse grained web services interface. You can use all the same web services functionality directly - see /wsdl/IHL7ConnectControl on the HL7Connect web interface. Snomed services are only available if Snomed-CT is configured on HL7Connect. The logfile is where internal logging and debugging messages will go. They will not be produced if the logfile is null
      ///</summary>
      public void InitServer(string logFile, string url, string name, string password)
      {
        wrapped().InitServer(logFile, url, name, password);
      }

      ///<summary>
      /// Initalise the library in local mode only. In this mode, the library does not rely on any HL7Connect service being available, and services that are provided by the central HL7Connect are not available, and will generate an exception if you try to use them: { logging;  notications;  unique key generation;  message/document sending and receiving;  interface and user status management (once implemented); }Other functions, including HL7 v2, CDA and CCD functionality will work normally. Snomed and loinc services may be provided, depending on the parameters of this method: 
      /// 
      /// { loinc Cache file name - the name of the cache file for loinc.;  snomed cache file name - the name of the cache file for snomed-CT;  ucum cache file name - the name of the cache file for ucum; }These files are found in \data in the HLConnect store on a full HL7Connect installation. if null/nil/no parameter is provided, they will not be loaded, and the corresponding services will not be available. If they are provided, the library will load them directly and the services will be available. Note that loading them is fairly quick, but will occupy the same amount of RAM in your process space as the size of the file on the disk. {* Note that loinc, snomed, and ucum services are not currently provided, and; }these paramters should be null or empty at this time ** The logfile is where internal logging and debugging messages will go. They will not be produced if the logfile is null
      ///</summary>
      public void InitLocal(string logFile, string loincCache, string snomedCache, string ucumCache)
      {
        wrapped().InitLocal(logFile, loincCache, snomedCache, ucumCache);
      }

      ///<summary>
      /// Prepare the Library to be unloaded. You need to call this, or the library will leak when you unload it. make sure you close and _release all other interfaces in the library first
      ///</summary>
      public void Close()
      {
        wrapped().Close();
      }

      ///<summary>
      /// Create an interface on which you can send messages to HL7Connect. 
      /// 
      /// The name provided must be the name of an incoming HL7 v2 interface that is defined as an incoming COM interface configured to be externally driven. The function returns an interface that can be used to send messages to HL7Connect. You can send either a fully populated message object or a binary stream of data that is the source of the message.
      ///</summary>
      public HL7Connect.Exchange.MessageIn GetMessageSender(string name)
      {
        return HL7Connect.Exchange.WrapperFactory.MessageIn(wrapped().GetMessageSender(name));
      }

      ///<summary>
      /// Create a COM interface on which you can send documents to HL7Connect. 
      /// 
      /// The name provided must be the name of an incoming CDA interface that is defined as a COM interface, configured to be externally driven. The function returns an interface that can be used to send documents to HL7Connect. You can send either a fully populated doc object or a binary stream of data that is the source of the document.
      ///</summary>
      public HL7Connect.Exchange.DocumentIn GetDocumentSender(string name)
      {
        return HL7Connect.Exchange.WrapperFactory.DocumentIn(wrapped().GetDocumentSender(name));
      }

      ///<summary>
      /// Provide a COM interface to which HL7Connect will send messages. 
      /// 
      /// The name provided must be the name of an outgoing HL7 v2 interface that is defined as a COM interface, configured to be externally driven. You must provide an implementation of the IHL7ConnectMessageTransfer COM interface that will be called sequentially for each message to be sent to the named HL7Connect interface. To avoid difficult COM threading problems, the thread that calls this method is used to poll the HL7Connect server for messages, and it will only return from this interface once message receiving is over. This will occur when: { The implementation returns tsEnd to a CheckStatus;  the associated HL7Connect interface is stopped; }
      ///</summary>
      public void BeMessageReceiver(string name, HL7Connect.Exchange.MessageOut handler)
      {
        wrapped().BeMessageReceiver(name, handler.wrapped());
      }

      ///<summary>
      /// Provide a COM interface to which HL7Connect will send documents. 
      /// 
      /// The name provided must be the name of an outgoing CDA interface that is defined as a COM interface, configured to be externally driven. You must provide an implementation of the IHL7ConnectMessageTransfer COM interface that will be called sequentially for each message to be sent to the named HL7Connect interface To avoid difficult COM threading problems, the thread that calls this method is used to poll the HL7Connect server for documents, and it will only return from this interface once document receiving is over. This will occur when: { The implementation returns tsEnd to a CheckStatus;  the associated HL7Connect interface is stopped; }
      ///</summary>
      public void BeDocumentReceiver(string name, HL7Connect.Exchange.DocumentOut handler)
      {
        wrapped().BeDocumentReceiver(name, handler.wrapped());
      }

      ///<summary>
      /// By default, Hl7Connect will wait the the configured timeout for a response from the interface, not knowing the status. Set the timeout too short, and HL7Connect will abandon the message/document before you've processed it, it processing takes too long. Set the timeout too long, and HL7Connect will take ages to give up on the client when the client is not available. One way to resolve this is for to notify Hl7Connect with an estimate of how long processing will take using this method 
      /// 
      /// The instance identifier is the parameter of the SendMessage or SendDocument method. HL7Connect will wait the specified number of seconds from the time *it started waiting*.
      ///</summary>
      public void NotifyWait(int iId, int iSeconds)
      {
        wrapped().NotifyWait(iId, iSeconds);
      }

    }

    internal class WrapperFactory
    {
      internal static HL7Connect.Services.HL7V2Manager HL7V2Manager(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Services.HL7V2Manager((IHL7V2Manager) wrapped);
      }

      internal static HL7Connect.Services.CDAManager CDAManager(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Services.CDAManager((ICDAManager) wrapped);
      }

      internal static HL7Connect.Services.Access Access(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Services.Access((IHL7ConnectServices) wrapped);
      }

    }
  }
  namespace Dicom
  {
    ///<summary>
    /// An abstract entry in a DICOM Dictionary
    ///</summary>
    public class DictEntity : HL7Connect.Utils.Base
    {

      internal DictEntity(IDicomDictionaryEntity com) : base(com) {} 

      internal new HCDicomDictionaryEntity wrapped() { return (HCDicomDictionaryEntity) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Unique Identifier (UID) ï¿½ a globally unique ï¿½dotted decimalï¿½ string that identifies a specific object or a class of objects; an ISO-8824 Object Identifier. 
      /// 
      /// DICOM Unique Identifiers (UIDs) provide the capability to uniquely identify a wide variety of items. They guarantee uniqueness across multiple countries, sites, vendors and equipment. Different classes of objects, instance of objects and information entities can be distinguished from one another across the DICOM universe of discourse irrespective of any semantic context.
      ///</summary>
      private string propGetUID()
      {
        return wrapped().UID;
      }
      ///<summary>
      /// Unique Identifier (UID) ï¿½ a globally unique ï¿½dotted decimalï¿½ string that identifies a specific object or a class of objects; an ISO-8824 Object Identifier. 
      /// 
      /// DICOM Unique Identifiers (UIDs) provide the capability to uniquely identify a wide variety of items. They guarantee uniqueness across multiple countries, sites, vendors and equipment. Different classes of objects, instance of objects and information entities can be distinguished from one another across the DICOM universe of discourse irrespective of any semantic context.
      ///</summary>
      public string UID { get { return propGetUID(); } }

    }

    ///<summary>
    /// A list of abstract entry in a DICOM Dictionary
    ///</summary>
    public class DictEntityList : HL7Connect.Utils.Base
    {

      internal DictEntityList(IDicomDictionaryEntityList com) : base(com) {} 

      internal new HCDicomDictionaryEntityList wrapped() { return (HCDicomDictionaryEntityList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Sorted Dictionary entities by their UID
      ///</summary>
      public void SortedByUID()
      {
        wrapped().SortedByUID();
      }

      ///<summary>
      /// True if items are sorted by their UID
      ///</summary>
      public bool IsSortedByUID()
      {
        return wrapped().IsSortedByUID() != 0;
      }

      ///<summary>
      /// The index of the first item with matching UID
      ///</summary>
      public int IndexByUID(string sUID)
      {
        return wrapped().IndexByUID(sUID);
      }

      ///<summary>
      /// True if there existed an item with matching UID
      ///</summary>
      public bool ExistsByUID(string sUID)
      {
        return wrapped().ExistsByUID(sUID) != 0;
      }

      ///<summary>
      /// Return the item with matching UID, or Null
      ///</summary>
      public HL7Connect.Dicom.DictEntity GetByUID(string sUID)
      {
        return HL7Connect.Dicom.WrapperFactory.DictEntity(wrapped().GetByUID(sUID));
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DictEntity value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomDictionaryEntity. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DictEntity Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictEntity(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

    }

    ///<summary>
    /// A transfer syntax, which is set of encoding rules, allows communicating Application Entities to negotiate common encoding techniques they both support (e.g., byte ordering, compression, etc.). 
    /// 
    /// A Transfer Syntax is an attribute of a Presentation Context, one or more of which are negotiated at the establishment of an Association between DICOM Application Entities. This Association negotiation is specified in PS 3.8 and discussed in PS 3.7.
    ///</summary>
    public class DictTransferSyntax : HL7Connect.Dicom.DictEntity
    {

      internal DictTransferSyntax(IDicomDictionaryTransferSyntax com) : base(com) {} 

      internal new HCDicomDictionaryTransferSyntax wrapped() { return (HCDicomDictionaryTransferSyntax) com; }

      ///<summary>
      /// Return the value of custom property with given key
      ///</summary>
      public string GetCustomProperty(string sPropertyName)
      {
        return wrapped().GetCustomProperty(sPropertyName);
      }

      ///<summary>
      /// Return the list of custom property keys
      ///</summary>
      public IList<String> GetCustomPropertyKeys()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().GetCustomPropertyKeys());
      }

      ///<summary>
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      ///</summary>
      private bool propGetIsBigEndian()
      {
        return wrapped().IsBigEndian != 0;
      }
      ///<summary>
      ///</summary>
      public bool IsBigEndian { get { return propGetIsBigEndian(); } }

      ///<summary>
      ///</summary>
      private bool propGetIsExplicitVR()
      {
        return wrapped().IsExplicitVR != 0;
      }
      ///<summary>
      ///</summary>
      public bool IsExplicitVR { get { return propGetIsExplicitVR(); } }

      ///<summary>
      ///</summary>
      private bool propGetIsEncapsulated()
      {
        return wrapped().IsEncapsulated != 0;
      }
      ///<summary>
      ///</summary>
      public bool IsEncapsulated { get { return propGetIsEncapsulated(); } }

      ///<summary>
      ///</summary>
      private bool propGetIsLossy()
      {
        return wrapped().IsLossy != 0;
      }
      ///<summary>
      ///</summary>
      public bool IsLossy { get { return propGetIsLossy(); } }

      ///<summary>
      ///</summary>
      private bool propGetIsDeflated()
      {
        return wrapped().IsDeflated != 0;
      }
      ///<summary>
      ///</summary>
      public bool IsDeflated { get { return propGetIsDeflated(); } }

    }

    ///<summary>
    /// A list of transfer syntax
    ///</summary>
    public class DictTransferSyntaxList : HL7Connect.Dicom.DictEntityList
    {

      internal DictTransferSyntaxList(IDicomDictionaryTransferSyntaxList com) : base(com) {} 

      internal new HCDicomDictionaryTransferSyntaxList wrapped() { return (HCDicomDictionaryTransferSyntaxList) com; }

      ///<summary>
      /// Return a transfer syntax with matching UID, or NULL
      ///</summary>
      public HL7Connect.Dicom.DictTransferSyntax GetTransferSyntaxByUID(string sUID)
      {
        return HL7Connect.Dicom.WrapperFactory.DictTransferSyntax(wrapped().GetTransferSyntaxByUID(sUID));
      }

      ///<summary>
      /// Get the iIndexth IDicomDictionaryTransferSyntax. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DictTransferSyntax ItemTransferSyntax(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictTransferSyntax(wrapped().ItemTransferSyntax(iIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DictTransferSyntax GetTransferSyntaxes(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictTransferSyntax(wrapped().get_TransferSyntaxes(iIndex));
      }
    }

    ///<summary>
    /// The Value Representation of a Data Element, describes the data type and format of that Data Element's Value(s). 
    /// 
    /// PS 3.6 lists the VR of each Data Element by Data Element Tag.
    ///</summary>
    public class DictVR : HL7Connect.Utils.Base
    {

      internal DictVR(IDicomDictionaryVR com) : base(com) {} 

      internal new HCDicomDictionaryVR wrapped() { return (HCDicomDictionaryVR) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// True if this VR is string-based
      ///</summary>
      public bool IsString()
      {
        return wrapped().IsString() != 0;
      }

      ///<summary>
      /// The type of the VR 
      /// 
      /// -- List of possible Value Representation (VR) type dvtCSdvtSHdvtLOdvtSTdvtLTdvtUTdvtAEdvtPNdvtUIdvtDAdvtTMdvtDTdvtASdvtISdvtDSdvtSSdvtUSdvtSLdvtULdvtATdvtFLdvtFDdvtOBdvtOWdvtOFdvtUN
      ///</summary>
      private TDicomVRType propGetVRType()
      {
        return wrapped().VRType;
      }
      ///<summary>
      /// The type of the VR 
      /// 
      /// -- List of possible Value Representation (VR) type dvtCSdvtSHdvtLOdvtSTdvtLTdvtUTdvtAEdvtPNdvtUIdvtDAdvtTMdvtDTdvtASdvtISdvtDSdvtSSdvtUSdvtSLdvtULdvtATdvtFLdvtFDdvtOBdvtOWdvtOFdvtUN
      ///</summary>
      public TDicomVRType VRType { get { return propGetVRType(); } }

      ///<summary>
      /// The code represented this VR
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      ///<summary>
      /// The code represented this VR
      ///</summary>
      public string Code { get { return propGetCode(); } }

      ///<summary>
      /// Short description of this VR (can be seen as its name)
      ///</summary>
      private string propGetDescription()
      {
        return wrapped().Description;
      }
      ///<summary>
      /// Short description of this VR (can be seen as its name)
      ///</summary>
      public string Description { get { return propGetDescription(); } }

      ///<summary>
      /// Full description of this VR
      ///</summary>
      private string propGetDoco()
      {
        return wrapped().Doco;
      }
      ///<summary>
      /// Full description of this VR
      ///</summary>
      public string Doco { get { return propGetDoco(); } }

      ///<summary>
      /// Maximum length in bytes of value instance of this VR
      ///</summary>
      private uint propGetLength()
      {
        return wrapped().Length;
      }
      ///<summary>
      /// Maximum length in bytes of value instance of this VR
      ///</summary>
      public uint Length { get { return propGetLength(); } }

      ///<summary>
      /// True if value instance of this VR is of fixed length
      ///</summary>
      private bool propGetFixed()
      {
        return wrapped().Fixed != 0;
      }
      ///<summary>
      /// True if value instance of this VR is of fixed length
      ///</summary>
      public bool Fixed { get { return propGetFixed(); } }

      ///<summary>
      /// True if an element of this VR could contains multiple values
      ///</summary>
      private bool propGetRepeatable()
      {
        return wrapped().Repeatable != 0;
      }
      ///<summary>
      /// True if an element of this VR could contains multiple values
      ///</summary>
      public bool Repeatable { get { return propGetRepeatable(); } }

    }

    ///<summary>
    /// A list of Value Representation.
    ///</summary>
    public class DictVRList : HL7Connect.Dicom.DictEntityList
    {

      internal DictVRList(IDicomDictionaryVRList com) : base(com) {} 

      internal new HCDicomDictionaryVRList wrapped() { return (HCDicomDictionaryVRList) com; }

      ///<summary>
      /// Get the iIndexth IDicomDictionaryVR. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DictVR ItemVR(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictVR(wrapped().ItemVR(iIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DictVR GetVRs(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictVR(wrapped().get_VRs(iIndex));
      }
    }

    ///<summary>
    /// A data element, which is a unit of information in an object definition 
    /// 
    /// A Data Set represents an instance of a real world Information Object.  A Data Set is constructed of Data Elements. Data Elements contain  the encoded Values of Attributes of that object. The specific content  and semantics of these Attributes are specified in Information Object Definitions (see PS 3.3).  A Data Element is uniquely identified by a Data Element Tag. The Data Elements  in a Data Set shall be ordered by increasing Data Element Tag Number  and shall occur at most once in a Data Set.
    ///</summary>
    public class DictElement : HL7Connect.Utils.Base
    {

      internal DictElement(IDicomDictionaryElement com) : base(com) {} 

      internal new HCDicomDictionaryElement wrapped() { return (HCDicomDictionaryElement) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// True if this element is a sequence
      ///</summary>
      public bool IsSequence()
      {
        return wrapped().IsSequence() != 0;
      }

      ///<summary>
      /// Return a string representation of this element
      ///</summary>
      public string AsString()
      {
        return wrapped().AsString();
      }

      ///<summary>
      /// The group Id of the element tag
      ///</summary>
      private string propGetGroupId()
      {
        return wrapped().GroupId;
      }
      ///<summary>
      /// The group Id of the element tag
      ///</summary>
      public string GroupId { get { return propGetGroupId(); } }

      ///<summary>
      /// The element id of the element tag
      ///</summary>
      private string propGetElementId()
      {
        return wrapped().ElementId;
      }
      ///<summary>
      /// The element id of the element tag
      ///</summary>
      public string ElementId { get { return propGetElementId(); } }

      ///<summary>
      /// The name of the group this element belongs to
      ///</summary>
      private string propGetGroupName()
      {
        return wrapped().GroupName;
      }
      ///<summary>
      /// The name of the group this element belongs to
      ///</summary>
      public string GroupName { get { return propGetGroupName(); } }

      ///<summary>
      /// The name of this element
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The name of this element
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// Code Name of this element
      ///</summary>
      private string propGetCode()
      {
        return wrapped().Code;
      }
      ///<summary>
      /// Code Name of this element
      ///</summary>
      public string Code { get { return propGetCode(); } }

      ///<summary>
      /// List of VR that values of this element can be encoded in
      ///</summary>
      private HL7Connect.Dicom.DictVRList propGetVRs()
      {
        return HL7Connect.Dicom.WrapperFactory.DictVRList(wrapped().VRs);
      }
      ///<summary>
      /// List of VR that values of this element can be encoded in
      ///</summary>
      public HL7Connect.Dicom.DictVRList VRs { get { return propGetVRs(); } }

      ///<summary>
      /// The minimum number of values that this element contains
      ///</summary>
      private int propGetMin()
      {
        return wrapped().Min;
      }
      ///<summary>
      /// The minimum number of values that this element contains
      ///</summary>
      public int Min { get { return propGetMin(); } }

      ///<summary>
      /// The maximum number of values that this element contains
      ///</summary>
      private int propGetMax()
      {
        return wrapped().Max;
      }
      ///<summary>
      /// The maximum number of values that this element contains
      ///</summary>
      public int Max { get { return propGetMax(); } }

    }

    ///<summary>
    /// List of Data Element
    ///</summary>
    public class DictElementList : HL7Connect.Utils.Base
    {

      internal DictElementList(IDicomDictionaryElementList com) : base(com) {} 

      internal new HCDicomDictionaryElementList wrapped() { return (HCDicomDictionaryElementList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Sorted elements by their tags (Group ID first, then Element ID)
      ///</summary>
      public void SortedByTags()
      {
        wrapped().SortedByTags();
      }

      ///<summary>
      /// True if elements are sorted by their tags
      ///</summary>
      public bool IsSortedByTags()
      {
        return wrapped().IsSortedByTags() != 0;
      }

      ///<summary>
      /// The index of an item with matching tag, or -1 if not found
      ///</summary>
      public int IndexByTags(string sGroup, string sElement)
      {
        return wrapped().IndexByTags(sGroup, sElement);
      }

      ///<summary>
      /// True if existed item with matching tag
      ///</summary>
      public bool ExistsByTags(string sGroup, string sElement)
      {
        return wrapped().ExistsByTags(sGroup, sElement) != 0;
      }

      ///<summary>
      /// The item with matching tag, or NULL if not found
      ///</summary>
      public HL7Connect.Dicom.DictElement GetByTags(string sGroup, string sElement)
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().GetByTags(sGroup, sElement));
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DictElement value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomDictionaryElement. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DictElement Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DictElement GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// List of Elements, organised into groups
    ///</summary>
    public class DictElementGroupList : HL7Connect.Utils.Base
    {

      internal DictElementGroupList(IDicomDictionaryElementGroupList com) : base(com) {} 

      internal new HCDicomDictionaryElementGroupList wrapped() { return (HCDicomDictionaryElementGroupList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Get the iIndexth List(IDicomDictionaryElement). (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DictElementList Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictElementList(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DictElementList GetElementGroup(string sKey)
      {
        return HL7Connect.Dicom.WrapperFactory.DictElementList(wrapped().get_ElementGroup(sKey));
      }
    }

    ///<summary>
    /// Represent a Dicom DIMSE message's parameter. 
    /// 
    /// It contains information such as the element type, whether the parameter is fixed/auto-calculated or to be supplied
    ///</summary>
    public class DimseParam : HL7Connect.Utils.Base
    {

      internal DimseParam(IDicomDimseParam com) : base(com) {} 

      internal new HCDicomDimseParam wrapped() { return (HCDicomDimseParam) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The parameter name
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The parameter name
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// The fixed value, if it exists, for this parameter
      ///</summary>
      private string propGetFixedValue()
      {
        return wrapped().FixedValue;
      }
      ///<summary>
      /// The fixed value, if it exists, for this parameter
      ///</summary>
      public string FixedValue { get { return propGetFixedValue(); } }

      ///<summary>
      /// The parameter type (fixed/auto-calculated or to be supplied) -- List of possible Dicom param types 
      /// 
      /// dimseParamFixeddimseParamAutodimseParamRequired
      ///</summary>
      private TDicomDimseParamType propGetParamType()
      {
        return wrapped().ParamType;
      }
      ///<summary>
      /// The parameter type (fixed/auto-calculated or to be supplied) -- List of possible Dicom param types 
      /// 
      /// dimseParamFixeddimseParamAutodimseParamRequired
      ///</summary>
      public TDicomDimseParamType ParamType { get { return propGetParamType(); } }

      ///<summary>
      /// The element tag id, used to connected this parameter to a valid element instance
      ///</summary>
      private string propGetElementId()
      {
        return wrapped().ElementId;
      }
      ///<summary>
      /// The element tag id, used to connected this parameter to a valid element instance
      ///</summary>
      public string ElementId { get { return propGetElementId(); } }

      ///<summary>
      /// The dictionary element this parameter belonged to.
      ///</summary>
      private HL7Connect.Dicom.DictElement propGetElement()
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().Element);
      }
      private void propSetElement(HL7Connect.Dicom.DictElement value)
      {
        wrapped().Element = value.wrapped();
      }
      ///<summary>
      /// The dictionary element this parameter belonged to.
      ///</summary>
      public HL7Connect.Dicom.DictElement Element { get { return propGetElement(); } set { propSetElement(value); } }

    }

    ///<summary>
    /// List of DIMSE message parameters
    ///</summary>
    public class DimseParamList : HL7Connect.Utils.Base
    {

      internal DimseParamList(IDicomDimseParamList com) : base(com) {} 

      internal new HCDicomDimseParamList wrapped() { return (HCDicomDimseParamList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DimseParam value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomDimseParam. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DimseParam Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DimseParam(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DimseParam GetDimseParams(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DimseParam(wrapped().get_DimseParams(iIndex));
      }
    }

    ///<summary>
    /// Represent a DICOM Message Service Element (DIMSE) message. 
    /// 
    /// The DIMSE defines an Application Service Element (both the service and protocol) used by peer DICOM Application Entities for the purpose of exchanging medical images and related information. The DIMSE provides its services by relying on the DIMSE protocol. The DIMSE protocol defines the encoding rules necessary to construct Messages. A Message is composed of a Command Set (defined in this part of the DICOM Standard) followed by a conditional Data Set (defined in PS 3.5).
    ///</summary>
    public class DimseMessage : HL7Connect.Utils.Base
    {

      internal DimseMessage(IDicomDimseMessage com) : base(com) {} 

      internal new HCDicomDimseMessage wrapped() { return (HCDicomDimseMessage) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The DIMSE message name (e.g. E-Echo Request/Response etc.)
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The DIMSE message name (e.g. E-Echo Request/Response etc.)
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// List of data elements used as parameter for this DIMSE message
      ///</summary>
      private HL7Connect.Dicom.DimseParamList propGetParams()
      {
        return HL7Connect.Dicom.WrapperFactory.DimseParamList(wrapped().Params);
      }
      ///<summary>
      /// List of data elements used as parameter for this DIMSE message
      ///</summary>
      public HL7Connect.Dicom.DimseParamList Params { get { return propGetParams(); } }

    }

    ///<summary>
    /// List of DIMSE message
    ///</summary>
    public class DimseService : HL7Connect.Utils.Base
    {

      internal DimseService(IDicomDimseService com) : base(com) {} 

      internal new HCDicomDimseService wrapped() { return (HCDicomDimseService) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DimseMessage value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomDimseMessage message. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DimseMessage Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DimseMessage(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DimseMessage GetDimseMessage(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DimseMessage(wrapped().get_DimseMessage(iIndex));
      }
      ///<summary>
      /// The DIMSE service type -- List of possible DICOM Message Service Element (DIMSE) types 
      /// 
      /// dimseCStoredimseCFinddimseCGetdimseCMovedimseCEchodimseNEventdimseNGetdimseNSetdimseNActiondimseNCreatedimseNDelete
      ///</summary>
      private TDicomDimseType propGetServiceType()
      {
        return wrapped().ServiceType;
      }
      ///<summary>
      /// The DIMSE service type -- List of possible DICOM Message Service Element (DIMSE) types 
      /// 
      /// dimseCStoredimseCFinddimseCGetdimseCMovedimseCEchodimseNEventdimseNGetdimseNSetdimseNActiondimseNCreatedimseNDelete
      ///</summary>
      public TDicomDimseType ServiceType { get { return propGetServiceType(); } }

    }

    ///<summary>
    /// List of DIMSE message, organised into service type names
    ///</summary>
    public class DimseServiceTypeDict : HL7Connect.Utils.Base
    {

      internal DimseServiceTypeDict(IDicomDimseServiceDict com) : base(com) {} 

      internal new HCDicomDimseServiceDict wrapped() { return (HCDicomDimseServiceDict) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Get the iIndexth IDicomDimseService. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DimseService Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DimseService(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DimseService GetService(string sKey)
      {
        return HL7Connect.Dicom.WrapperFactory.DimseService(wrapped().get_Service(sKey));
      }
    }

    ///<summary>
    /// An abstract attribute entry, with name, comment and other entries as its chidren 
    /// 
    /// Concrete subclasses are InfoEntryAttr or InfoEntryReference
    ///</summary>
    public class InfoEntry : HL7Connect.Utils.Base
    {

      internal InfoEntry(IDicomInfoEntry com) : base(com) {} 

      internal new HCDicomInfoEntry wrapped() { return (HCDicomInfoEntry) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The entry name, which is a human-readable name
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The entry name, which is a human-readable name
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// List of entries that are children of this entry
      ///</summary>
      private HL7Connect.Dicom.InfoEntryList propGetChildren()
      {
        return HL7Connect.Dicom.WrapperFactory.InfoEntryList(wrapped().Children);
      }
      ///<summary>
      /// List of entries that are children of this entry
      ///</summary>
      public HL7Connect.Dicom.InfoEntryList Children { get { return propGetChildren(); } }

      ///<summary>
      /// Further comment about this entry, can be used as the entry documentation
      ///</summary>
      private string propGetComment()
      {
        return wrapped().Comment;
      }
      ///<summary>
      /// Further comment about this entry, can be used as the entry documentation
      ///</summary>
      public string Comment { get { return propGetComment(); } }

    }

    ///<summary>
    /// List of abstract attribute entry
    ///</summary>
    public class InfoEntryList : HL7Connect.Utils.Base
    {

      internal InfoEntryList(IDicomInfoEntryList com) : base(com) {} 

      internal new HCDicomInfoEntryList wrapped() { return (HCDicomInfoEntryList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.InfoEntry value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomInfoEntry. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.InfoEntry Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.InfoEntry(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.InfoEntry GetEntry(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.InfoEntry(wrapped().get_entry(iIndex));
      }
    }

    ///<summary>
    /// A macro/module reference 
    /// 
    /// Module/Macro may reference other module/macro, incorporated the referenced module/macro entries as its own
    ///</summary>
    public class InfoEntryReference : HL7Connect.Dicom.InfoEntry
    {

      internal InfoEntryReference(IDicomInfoEntryReference com) : base(com) {} 

      internal new HCDicomInfoEntryReference wrapped() { return (HCDicomInfoEntryReference) com; }

      ///<summary>
      /// The referenced module/macro unique key, which can be used to resolved this entry into a module/macro
      ///</summary>
      private string propGetRefId()
      {
        return wrapped().RefId;
      }
      ///<summary>
      /// The referenced module/macro unique key, which can be used to resolved this entry into a module/macro
      ///</summary>
      public string RefId { get { return propGetRefId(); } }

      ///<summary>
      /// The referenced module/macro. Initially, this would be null. After reference resolution, it would be set to be the referenced module/macro
      ///</summary>
      private HL7Connect.Dicom.InfoEntryGroup propGetRefEntry()
      {
        return HL7Connect.Dicom.WrapperFactory.InfoEntryGroup(wrapped().RefEntry);
      }
      ///<summary>
      /// The referenced module/macro. Initially, this would be null. After reference resolution, it would be set to be the referenced module/macro
      ///</summary>
      public HL7Connect.Dicom.InfoEntryGroup RefEntry { get { return propGetRefEntry(); } }

      ///<summary>
      ///</summary>
      private string propGetContextId()
      {
        return wrapped().ContextId;
      }
      ///<summary>
      ///</summary>
      public string ContextId { get { return propGetContextId(); } }

      ///<summary>
      ///</summary>
      private string propGetBaselineContextId()
      {
        return wrapped().BaselineContextId;
      }
      ///<summary>
      ///</summary>
      public string BaselineContextId { get { return propGetBaselineContextId(); } }

      ///<summary>
      ///</summary>
      private string propGetDefinedTemplateId()
      {
        return wrapped().DefinedTemplateId;
      }
      ///<summary>
      ///</summary>
      public string DefinedTemplateId { get { return propGetDefinedTemplateId(); } }

      ///<summary>
      ///</summary>
      private string propGetBaselineTemplateId()
      {
        return wrapped().BaselineTemplateId;
      }
      ///<summary>
      ///</summary>
      public string BaselineTemplateId { get { return propGetBaselineTemplateId(); } }

    }

    ///<summary>
    /// Describe each attribute entry in the Information Object model
    ///</summary>
    public class InfoEntryAttr : HL7Connect.Dicom.InfoEntry
    {

      internal InfoEntryAttr(IDicomInfoEntryAttr com) : base(com) {} 

      internal new HCDicomInfoEntryAttr wrapped() { return (HCDicomInfoEntryAttr) com; }

      ///<summary>
      /// The unique tag to identify the data element that corresponds to this attribute
      ///</summary>
      private string propGetTag()
      {
        return wrapped().tag;
      }
      ///<summary>
      /// The unique tag to identify the data element that corresponds to this attribute
      ///</summary>
      public string Tag { get { return propGetTag(); } }

      ///<summary>
      /// The compulsary requirement for this attribute (e.g. required, nullable, optional, etc.) -- List of possible required type for attribute 
      /// 
      /// irtRequireirtRequireCondirtRequireNullableirtRequireNullableCondirtOptional
      ///</summary>
      private TDicomInfoRequiredType propGetRequiredType()
      {
        return wrapped().RequiredType;
      }
      ///<summary>
      /// The compulsary requirement for this attribute (e.g. required, nullable, optional, etc.) -- List of possible required type for attribute 
      /// 
      /// irtRequireirtRequireCondirtRequireNullableirtRequireNullableCondirtOptional
      ///</summary>
      public TDicomInfoRequiredType RequiredType { get { return propGetRequiredType(); } }

      ///<summary>
      /// The resolved data element corresponding to this attribute
      ///</summary>
      private HL7Connect.Dicom.DictElement propGetRefElement()
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().RefElement);
      }
      ///<summary>
      /// The resolved data element corresponding to this attribute
      ///</summary>
      public HL7Connect.Dicom.DictElement RefElement { get { return propGetRefElement(); } }

    }

    ///<summary>
    /// An abstract collection of attributes and references. 
    /// 
    /// Each group have a human readable name, a unique key and any further comment
    ///</summary>
    public class InfoEntryGroup : HL7Connect.Utils.Base
    {

      internal InfoEntryGroup(IDicomInfoGroup com) : base(com) {} 

      internal new HCDicomInfoGroup wrapped() { return (HCDicomInfoGroup) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The unique key of this group (e.g. Table number)
      ///</summary>
      private string propGetKey()
      {
        return wrapped().Key;
      }
      ///<summary>
      /// The unique key of this group (e.g. Table number)
      ///</summary>
      public string Key { get { return propGetKey(); } }

      ///<summary>
      /// Human-readable name of this group
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// Human-readable name of this group
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// Documentational comment about this group
      ///</summary>
      private string propGetComment()
      {
        return wrapped().Comment;
      }
      ///<summary>
      /// Documentational comment about this group
      ///</summary>
      public string Comment { get { return propGetComment(); } }

      ///<summary>
      /// The list of attributes and references contained in this group The attributes and references my contain further attributes and references within themselves.
      ///</summary>
      private HL7Connect.Dicom.InfoEntryList propGetChildren()
      {
        return HL7Connect.Dicom.WrapperFactory.InfoEntryList(wrapped().Children);
      }
      ///<summary>
      /// The list of attributes and references contained in this group The attributes and references my contain further attributes and references within themselves.
      ///</summary>
      public HL7Connect.Dicom.InfoEntryList Children { get { return propGetChildren(); } }

    }

    ///<summary>
    /// A set of Attributes that are described in a single table that is referenced by  multiple Module or other tables.
    ///</summary>
    public class Macro : HL7Connect.Dicom.InfoEntryGroup
    {

      internal Macro(IDicomMacro com) : base(com) {} 

      internal new HCDicomMacro wrapped() { return (HCDicomMacro) com; }

    }

    ///<summary>
    /// A Dictionary of Macros, indexed by macro's reference key (i.e. table number)
    ///</summary>
    public class MacroDict : HL7Connect.Utils.Base
    {

      internal MacroDict(IDicomMacroDict com) : base(com) {} 

      internal new HCDicomMacroDict wrapped() { return (HCDicomMacroDict) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.Macro value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomMacro. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.Macro ItemMacro(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Macro(wrapped().ItemMacro(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.Macro Macro(string sKey)
      {
        return HL7Connect.Dicom.WrapperFactory.Macro(wrapped().Macro(sKey));
      }

    }

    ///<summary>
    /// A set of Attributes within an Information Entity or Normalized IOD  which are logically related to each other. (Very similar to macro, only separated for conceptual reason)
    ///</summary>
    public class Module : HL7Connect.Dicom.InfoEntryGroup
    {

      internal Module(IDicomModule com) : base(com) {} 

      internal new HCDicomModule wrapped() { return (HCDicomModule) com; }

    }

    ///<summary>
    /// A Dictionary of Modules, index by module's reference key (i.e. table number)
    ///</summary>
    public class ModuleDict : HL7Connect.Dicom.MacroDict
    {

      internal ModuleDict(IDicomModuleDict com) : base(com) {} 

      internal new HCDicomModuleDict wrapped() { return (HCDicomModuleDict) com; }

      ///<summary>
      /// Get the iIndexth IDicomModule. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.Module ItemModule(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Module(wrapped().ItemModule(iIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.Module GetModule(string sKey)
      {
        return HL7Connect.Dicom.WrapperFactory.Module(wrapped().get_Module(sKey));
      }
    }

    ///<summary>
    /// For used in IOD, is a reference to a module (using module names)
    ///</summary>
    public class ModuleReference : HL7Connect.Utils.Base
    {

      internal ModuleReference(IDicomModuleReference com) : base(com) {} 

      internal new HCDicomModuleReference wrapped() { return (HCDicomModuleReference) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The referenced module name, currently used to resolved this reference
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The referenced module name, currently used to resolved this reference
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// The key of the referenced module, after reference resolution (i.e. table number)
      ///</summary>
      private string propGetKey()
      {
        return wrapped().Key;
      }
      ///<summary>
      /// The key of the referenced module, after reference resolution (i.e. table number)
      ///</summary>
      public string Key { get { return propGetKey(); } }

      ///<summary>
      /// The referenced module, after reference resolution
      ///</summary>
      private HL7Connect.Dicom.Module propGetRefEntry()
      {
        return HL7Connect.Dicom.WrapperFactory.Module(wrapped().RefEntry);
      }
      ///<summary>
      /// The referenced module, after reference resolution
      ///</summary>
      public HL7Connect.Dicom.Module RefEntry { get { return propGetRefEntry(); } }

      ///<summary>
      /// The usage type of this module, within the parent IOD (e.g. Mandatory, Conditional or User Option) -- List of possible required type for module in Information Object Definition (IOD) 
      /// 
      /// mutMandatorymutConditionalmutUserOption
      ///</summary>
      private TDicomModuleUsageType propGetUsageType()
      {
        return wrapped().UsageType;
      }
      ///<summary>
      /// The usage type of this module, within the parent IOD (e.g. Mandatory, Conditional or User Option) -- List of possible required type for module in Information Object Definition (IOD) 
      /// 
      /// mutMandatorymutConditionalmutUserOption
      ///</summary>
      public TDicomModuleUsageType UsageType { get { return propGetUsageType(); } }

      ///<summary>
      /// The section number, which refer to the section that defined the referenced module
      ///</summary>
      private string propGetSectionReference()
      {
        return wrapped().SectionReference;
      }
      ///<summary>
      /// The section number, which refer to the section that defined the referenced module
      ///</summary>
      public string SectionReference { get { return propGetSectionReference(); } }

      ///<summary>
      /// Documentational comment about the referenced module usage within the parent IOD
      ///</summary>
      private string propGetComment()
      {
        return wrapped().Comment;
      }
      ///<summary>
      /// Documentational comment about the referenced module usage within the parent IOD
      ///</summary>
      public string Comment { get { return propGetComment(); } }

    }

    ///<summary>
    /// A list of module references
    ///</summary>
    public class ModuleReferenceList : HL7Connect.Utils.Base
    {

      internal ModuleReferenceList(IDicomModuleReferenceList com) : base(com) {} 

      internal new HCDicomModuleReferenceList wrapped() { return (HCDicomModuleReferenceList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.ModuleReference value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomModuleReference. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.ModuleReference Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.ModuleReference(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.ModuleReference GetReferences(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.ModuleReference(wrapped().get_References(iIndex));
      }
    }

    ///<summary>
    /// Information Object Definition (IOD): a data abstraction of a class of  similar Real-World Objects which defines the nature and Attributes  relevant to the class of Real-World Objects represented.
    ///</summary>
    public class IOD : HL7Connect.Utils.Base
    {

      internal IOD(IDicomIOD com) : base(com) {} 

      internal new HCDicomIOD wrapped() { return (HCDicomIOD) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The human-readable name of this IOD
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The human-readable name of this IOD
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// The unique key identified this IOD (e.g. table number)
      ///</summary>
      private string propGetKey()
      {
        return wrapped().Key;
      }
      ///<summary>
      /// The unique key identified this IOD (e.g. table number)
      ///</summary>
      public string Key { get { return propGetKey(); } }

      ///<summary>
      /// The list of modules that make up this Information Object Definition
      ///</summary>
      private HL7Connect.Dicom.ModuleReferenceList propGetModules()
      {
        return HL7Connect.Dicom.WrapperFactory.ModuleReferenceList(wrapped().Modules);
      }
      ///<summary>
      /// The list of modules that make up this Information Object Definition
      ///</summary>
      public HL7Connect.Dicom.ModuleReferenceList Modules { get { return propGetModules(); } }

    }

    ///<summary>
    /// A dictionary of Information Object Definition, indexed by its key  (e.g. table number)
    ///</summary>
    public class IODDict : HL7Connect.Utils.Base
    {

      internal IODDict(IDicomIODDict com) : base(com) {} 

      internal new HCDicomIODDict wrapped() { return (HCDicomIODDict) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.IOD value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomIOD. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.IOD Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.IOD(wrapped().Item(iIndex));
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.IOD GetEntry(string sKey)
      {
        return HL7Connect.Dicom.WrapperFactory.IOD(wrapped().get_entry(sKey));
      }
    }

    ///<summary>
    /// A Service-Object Pair (SOP) Class is defined by the union of an IOD  and a DIMSE Service Group. The SOP Class definition contains the rules  and semantics which may restrict the use of the services in the DIMSE  Service Group and/or the Attributes of the IOD.  
    /// 
    /// The selection of SOP Classes is used by Application Entities to establish  an agreed set of capabilities to support their interaction. This negotiation  is performed at association establishment time as described in PS 3.7.  An extended negotiation allows Application Entities to further agree on  specific options within a SOP Class.
    ///</summary>
    public class DictSOP : HL7Connect.Dicom.DictEntity
    {

      internal DictSOP(IDicomDictionarySOP com) : base(com) {} 

      internal new HCDicomDictionarySOP wrapped() { return (HCDicomDictionarySOP) com; }

      ///<summary>
      /// The human-readable name of this SOP
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The human-readable name of this SOP
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// The IOD stated in the document, but doesn't semantically matched the SOP
      ///</summary>
      private string propGetStatedIOD()
      {
        return wrapped().StatedIOD;
      }
      ///<summary>
      /// The IOD stated in the document, but doesn't semantically matched the SOP
      ///</summary>
      public string StatedIOD { get { return propGetStatedIOD(); } }

      ///<summary>
      /// The referenced key to the IOD used for this SOP
      ///</summary>
      private string propGetIODRef()
      {
        return wrapped().IODRef;
      }
      ///<summary>
      /// The referenced key to the IOD used for this SOP
      ///</summary>
      public string IODRef { get { return propGetIODRef(); } }

      ///<summary>
      /// The IOD referenced by this SOP
      ///</summary>
      private HL7Connect.Dicom.IOD propGetIOD()
      {
        return HL7Connect.Dicom.WrapperFactory.IOD(wrapped().IOD);
      }
      ///<summary>
      /// The IOD referenced by this SOP
      ///</summary>
      public HL7Connect.Dicom.IOD IOD { get { return propGetIOD(); } }

    }

    ///<summary>
    /// A list of Service-Object pair
    ///</summary>
    public class DictSOPList : HL7Connect.Dicom.DictEntityList
    {

      internal DictSOPList(IDicomDictionarySOPList com) : base(com) {} 

      internal new HCDicomDictionarySOPList wrapped() { return (HCDicomDictionarySOPList) com; }

      ///<summary>
      /// Return the SOP object given its UID
      ///</summary>
      public HL7Connect.Dicom.DictSOP GetDictionarySOPByUID(string sUID)
      {
        return HL7Connect.Dicom.WrapperFactory.DictSOP(wrapped().GetDictionarySOPByUID(sUID));
      }

      ///<summary>
      /// Get the iIndexth IDicomDictionarySOP. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DictSOP ItemSOP(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictSOP(wrapped().ItemSOP(iIndex));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DictSOP GetSOPs(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DictSOP(wrapped().get_SOPs(iIndex));
      }
    }

    ///<summary>
    /// A collection of all DICOM data models extracted from the standard, possibly with local extensions, to facilitate our working with DICOM.
    ///</summary>
    public class Dictionary : HL7Connect.Utils.Base
    {

      internal Dictionary(IDicomDictionary com) : base(com) {} 

      internal new HCDicomDictionary wrapped() { return (HCDicomDictionary) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Determinine the VR matching the given VR code -- List of possible Value Representation (VR) type 
      /// 
      /// dvtCSdvtSHdvtLOdvtSTdvtLTdvtUTdvtAEdvtPNdvtUIdvtDAdvtTMdvtDTdvtASdvtISdvtDSdvtSSdvtUSdvtSLdvtULdvtATdvtFLdvtFDdvtOBdvtOWdvtOFdvtUN
      ///</summary>
      public TDicomVRType DetermineVRType(string sCode)
      {
        return wrapped().DetermineVRType(sCode);
      }

      ///<summary>
      /// Deterimine if the given VR code is valid
      ///</summary>
      public bool isValidVRType(string sCode)
      {
        return wrapped().isValidVRType(sCode) != 0;
      }

      ///<summary>
      /// Find a matching element in the dictionary, giving the element tag (i.e. group id and element id)
      ///</summary>
      public HL7Connect.Dicom.DictElement FindMatchingElement(int iGroup, int iElement, bool bErrorIfNotFound)
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().FindMatchingElement(iGroup, iElement, bErrorIfNotFound ? (sbyte) 0 : (sbyte) -1));
      }

      ///<summary>
      /// Return the VR giving its VR Type
      ///</summary>
      public HL7Connect.Dicom.DictVR GetVRByType(TDicomVRType aType)
      {
        return HL7Connect.Dicom.WrapperFactory.DictVR(wrapped().GetVRByType(aType));
      }

      ///<summary>
      /// Return the VR giving its VR Type code
      ///</summary>
      public HL7Connect.Dicom.DictVR GetVRByTypeCode(string sCode)
      {
        return HL7Connect.Dicom.WrapperFactory.DictVR(wrapped().GetVRByTypeCode(sCode));
      }

      ///<summary>
      /// Get the list of VR Type codes
      ///</summary>
      public IList<String> GetVRTypeCodes()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().GetVRTypeCodes());
      }

      ///<summary>
      /// Get the name for the specified abstract syntax/SOP class UID. 
      /// 
      /// "unknown" if no match
      ///</summary>
      public string AbstractSyntaxName(string uid)
      {
        return wrapped().AbstractSyntaxName(uid);
      }

      ///<summary>
      /// Get the name for the specified transfer syntax class UID. 
      /// 
      /// "unknown" if no match
      ///</summary>
      public string TransferSyntaxName(string uid)
      {
        return wrapped().TransferSyntaxName(uid);
      }

      ///<summary>
      /// The human-readable name of this dictionary
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The human-readable name of this dictionary
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// The list of transfer syntaxes defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.DictTransferSyntaxList propGetTransferSyntaxes()
      {
        return HL7Connect.Dicom.WrapperFactory.DictTransferSyntaxList(wrapped().TransferSyntaxes);
      }
      ///<summary>
      /// The list of transfer syntaxes defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.DictTransferSyntaxList TransferSyntaxes { get { return propGetTransferSyntaxes(); } }

      ///<summary>
      /// The list of Service-Object pair defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.DictSOPList propGetSOPs()
      {
        return HL7Connect.Dicom.WrapperFactory.DictSOPList(wrapped().SOPs);
      }
      ///<summary>
      /// The list of Service-Object pair defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.DictSOPList SOPs { get { return propGetSOPs(); } }

      ///<summary>
      /// The list of elements defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.DictElementList propGetElements()
      {
        return HL7Connect.Dicom.WrapperFactory.DictElementList(wrapped().Elements);
      }
      ///<summary>
      /// The list of elements defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.DictElementList Elements { get { return propGetElements(); } }

      ///<summary>
      /// The list of element groups defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.DictElementGroupList propGetElementGroups()
      {
        return HL7Connect.Dicom.WrapperFactory.DictElementGroupList(wrapped().ElementGroups);
      }
      ///<summary>
      /// The list of element groups defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.DictElementGroupList ElementGroups { get { return propGetElementGroups(); } }

      ///<summary>
      /// The list of DICOM Message service element defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.DimseServiceTypeDict propGetDimses()
      {
        return HL7Connect.Dicom.WrapperFactory.DimseServiceTypeDict(wrapped().Dimses);
      }
      ///<summary>
      /// The list of DICOM Message service element defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.DimseServiceTypeDict Dimses { get { return propGetDimses(); } }

      ///<summary>
      /// The list of Macros defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.MacroDict propGetMacros()
      {
        return HL7Connect.Dicom.WrapperFactory.MacroDict(wrapped().Macros);
      }
      ///<summary>
      /// The list of Macros defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.MacroDict Macros { get { return propGetMacros(); } }

      ///<summary>
      /// The list of Modules defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.ModuleDict propGetModules()
      {
        return HL7Connect.Dicom.WrapperFactory.ModuleDict(wrapped().Modules);
      }
      ///<summary>
      /// The list of Modules defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.ModuleDict Modules { get { return propGetModules(); } }

      ///<summary>
      /// The list of Information Object Definition (IOD) defined in this dictionary
      ///</summary>
      private HL7Connect.Dicom.IODDict propGetIODs()
      {
        return HL7Connect.Dicom.WrapperFactory.IODDict(wrapped().IODs);
      }
      ///<summary>
      /// The list of Information Object Definition (IOD) defined in this dictionary
      ///</summary>
      public HL7Connect.Dicom.IODDict IODs { get { return propGetIODs(); } }

    }

    ///<summary>
    /// A DICOM value
    ///</summary>
    public class Value : HL7Connect.Utils.Base
    {

      internal Value(IDicomValue com) : base(com) {} 

      internal new HCDicomValue wrapped() { return (HCDicomValue) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The dictionary in used
      ///</summary>
      private HL7Connect.Dicom.Dictionary propGetDictionary()
      {
        return HL7Connect.Dicom.WrapperFactory.Dictionary(wrapped().Dictionary);
      }
      ///<summary>
      /// The dictionary in used
      ///</summary>
      public HL7Connect.Dicom.Dictionary Dictionary { get { return propGetDictionary(); } }

      ///<summary>
      /// The value as a string
      ///</summary>
      private string propGetAsString()
      {
        return wrapped().AsString;
      }
      private void propSetAsString(string value)
      {
        wrapped().AsString = value;
      }
      ///<summary>
      /// The value as a string
      ///</summary>
      public string AsString { get { return propGetAsString(); } set { propSetAsString(value); } }

      ///<summary>
      /// The value as 'Code String', A string of characters with leading or trailing spaces being nonsignificant
      ///</summary>
      private string propGetAsCS()
      {
        return wrapped().AsCS;
      }
      private void propSetAsCS(string value)
      {
        wrapped().AsCS = value;
      }
      ///<summary>
      /// The value as 'Code String', A string of characters with leading or trailing spaces being nonsignificant
      ///</summary>
      public string AsCS { get { return propGetAsCS(); } set { propSetAsCS(value); } }

      ///<summary>
      /// The value as 'Short String', A short character string. Example: telephone numbers, IDs
      ///</summary>
      private string propGetAsSH()
      {
        return wrapped().AsSH;
      }
      private void propSetAsSH(string value)
      {
        wrapped().AsSH = value;
      }
      ///<summary>
      /// The value as 'Short String', A short character string. Example: telephone numbers, IDs
      ///</summary>
      public string AsSH { get { return propGetAsSH(); } set { propSetAsSH(value); } }

      ///<summary>
      /// The value as 'Long String', A character string that may be padded with leading and/or trailing spaces
      ///</summary>
      private string propGetAsLO()
      {
        return wrapped().AsLO;
      }
      private void propSetAsLO(string value)
      {
        wrapped().AsLO = value;
      }
      ///<summary>
      /// The value as 'Long String', A character string that may be padded with leading and/or trailing spaces
      ///</summary>
      public string AsLO { get { return propGetAsLO(); } set { propSetAsLO(value); } }

      ///<summary>
      /// The value as 'Short Text', A character string that may contain one or more paragraphs.
      ///</summary>
      private string propGetAsST()
      {
        return wrapped().AsST;
      }
      private void propSetAsST(string value)
      {
        wrapped().AsST = value;
      }
      ///<summary>
      /// The value as 'Short Text', A character string that may contain one or more paragraphs.
      ///</summary>
      public string AsST { get { return propGetAsST(); } set { propSetAsST(value); } }

      ///<summary>
      /// The value as 'Long Text', A character string that may contain one or more paragraphs, the same as LO, but can be much longer
      ///</summary>
      private string propGetAsLT()
      {
        return wrapped().AsLT;
      }
      private void propSetAsLT(string value)
      {
        wrapped().AsLT = value;
      }
      ///<summary>
      /// The value as 'Long Text', A character string that may contain one or more paragraphs, the same as LO, but can be much longer
      ///</summary>
      public string AsLT { get { return propGetAsLT(); } set { propSetAsLT(value); } }

      ///<summary>
      /// The value as 'Unlimited Text', A character string that may contain one or more paragraphs, similar to LT.
      ///</summary>
      private string propGetAsUT()
      {
        return wrapped().AsUT;
      }
      private void propSetAsUT(string value)
      {
        wrapped().AsUT = value;
      }
      ///<summary>
      /// The value as 'Unlimited Text', A character string that may contain one or more paragraphs, similar to LT.
      ///</summary>
      public string AsUT { get { return propGetAsUT(); } set { propSetAsUT(value); } }

      ///<summary>
      /// The value as 'Application Entity', A string of characters that identifies a device name with leading and trailing spaces being nonsignificant.
      ///</summary>
      private string propGetAsAE()
      {
        return wrapped().AsAE;
      }
      private void propSetAsAE(string value)
      {
        wrapped().AsAE = value;
      }
      ///<summary>
      /// The value as 'Application Entity', A string of characters that identifies a device name with leading and trailing spaces being nonsignificant.
      ///</summary>
      public string AsAE { get { return propGetAsAE(); } set { propSetAsAE(value); } }

      ///<summary>
      /// The value as 'Unique Identifier (UID)', A character string containing a UID that is used to uniquely identify a wide variety of items
      ///</summary>
      private string propGetAsUI()
      {
        return wrapped().AsUI;
      }
      private void propSetAsUI(string value)
      {
        wrapped().AsUI = value;
      }
      ///<summary>
      /// The value as 'Unique Identifier (UID)', A character string containing a UID that is used to uniquely identify a wide variety of items
      ///</summary>
      public string AsUI { get { return propGetAsUI(); } set { propSetAsUI(value); } }

      ///<summary>
      /// The value as 'Date', A string of characters of the format YYYYMMDD; where YYYY shall contain year, MM shall contain the month, and DD shall contain the day
      ///</summary>
      private DateTime propGetAsDA()
      {
        return wrapped().AsDA;
      }
      private void propSetAsDA(DateTime value)
      {
        wrapped().AsDA = value;
      }
      ///<summary>
      /// The value as 'Date', A string of characters of the format YYYYMMDD; where YYYY shall contain year, MM shall contain the month, and DD shall contain the day
      ///</summary>
      public DateTime AsDA { get { return propGetAsDA(); } set { propSetAsDA(value); } }

      ///<summary>
      /// The value as 'Time', A string of characters of the format HHMMSS.FRAC; where HH contains hours (range ï¿½00ï¿½ ï¿½ ï¿½23ï¿½), MM contains minutes (range ï¿½00ï¿½ ï¿½ ï¿½59ï¿½), '+'SS contains seconds (range ï¿½00ï¿½ ï¿½ï¿½59ï¿½), and FRAC contains a fractional part of a second as small as one millionth of a second. 
      /// 
      /// Example: ï¿½183200.00ï¿½ stands for 6:32 PM.
      ///</summary>
      private DateTime propGetAsTM()
      {
        return wrapped().AsTM;
      }
      private void propSetAsTM(DateTime value)
      {
        wrapped().AsTM = value;
      }
      ///<summary>
      /// The value as 'Time', A string of characters of the format HHMMSS.FRAC; where HH contains hours (range ï¿½00ï¿½ ï¿½ ï¿½23ï¿½), MM contains minutes (range ï¿½00ï¿½ ï¿½ ï¿½59ï¿½), '+'SS contains seconds (range ï¿½00ï¿½ ï¿½ï¿½59ï¿½), and FRAC contains a fractional part of a second as small as one millionth of a second. 
      /// 
      /// Example: ï¿½183200.00ï¿½ stands for 6:32 PM.
      ///</summary>
      public DateTime AsTM { get { return propGetAsTM(); } set { propSetAsTM(value); } }

      ///<summary>
      /// The value as 'Date Time', Concatenated datetime string in the format: YYYYMMDDHHMMSS.FFFFFF The components of this string, from left to right, are YYYY = Year, '+'MM = Month, DD = Day, HH = Hour, MM = Minute, SS = Second, FFFFFF = Fractional Second. 
      /// 
      /// Example: ï¿½20050812183000.00ï¿½ stands for 6:30 PM, August 12, 2005');
      ///</summary>
      private DateTime propGetAsDT()
      {
        return wrapped().AsDT;
      }
      private void propSetAsDT(DateTime value)
      {
        wrapped().AsDT = value;
      }
      ///<summary>
      /// The value as 'Date Time', Concatenated datetime string in the format: YYYYMMDDHHMMSS.FFFFFF The components of this string, from left to right, are YYYY = Year, '+'MM = Month, DD = Day, HH = Hour, MM = Minute, SS = Second, FFFFFF = Fractional Second. 
      /// 
      /// Example: ï¿½20050812183000.00ï¿½ stands for 6:30 PM, August 12, 2005');
      ///</summary>
      public DateTime AsDT { get { return propGetAsDT(); } set { propSetAsDT(value); } }

      ///<summary>
      /// The value as 'Age String', A string of characters with one of the following formats: nnnD, nnnW, nnnM, nnnY; where nnn contains the number of days for D, weeks for W, months for M, or years for Y. Example: "018M" would represent an age of 18 months.
      ///</summary>
      private string propGetAsAS()
      {
        return wrapped().AsAS;
      }
      private void propSetAsAS(string value)
      {
        wrapped().AsAS = value;
      }
      ///<summary>
      /// The value as 'Age String', A string of characters with one of the following formats: nnnD, nnnW, nnnM, nnnY; where nnn contains the number of days for D, weeks for W, months for M, or years for Y. Example: "018M" would represent an age of 18 months.
      ///</summary>
      public string AsAS { get { return propGetAsAS(); } set { propSetAsAS(value); } }

      ///<summary>
      /// The value as 'Integer String', A string of characters representing an integer. Example: ï¿½-1234567ï¿½.
      ///</summary>
      private string propGetAsIS()
      {
        return wrapped().AsIS;
      }
      private void propSetAsIS(string value)
      {
        wrapped().AsIS = value;
      }
      ///<summary>
      /// The value as 'Integer String', A string of characters representing an integer. Example: ï¿½-1234567ï¿½.
      ///</summary>
      public string AsIS { get { return propGetAsIS(); } set { propSetAsIS(value); } }

      ///<summary>
      /// The value as 'Decimal String', A string of characters representing either a fixed point number or a floating point number
      ///</summary>
      private string propGetAsDS()
      {
        return wrapped().AsDS;
      }
      private void propSetAsDS(string value)
      {
        wrapped().AsDS = value;
      }
      ///<summary>
      /// The value as 'Decimal String', A string of characters representing either a fixed point number or a floating point number
      ///</summary>
      public string AsDS { get { return propGetAsDS(); } set { propSetAsDS(value); } }

      ///<summary>
      /// The value as 'Signed Short', Signed binary integer 16 bits long.
      ///</summary>
      private short propGetAsSS()
      {
        return wrapped().AsSS;
      }
      private void propSetAsSS(short value)
      {
        wrapped().AsSS = value;
      }
      ///<summary>
      /// The value as 'Signed Short', Signed binary integer 16 bits long.
      ///</summary>
      public short AsSS { get { return propGetAsSS(); } set { propSetAsSS(value); } }

      ///<summary>
      /// The value as 'Unsigned Short', Unsigned binary integer 16 bits long.
      ///</summary>
      private int propGetAsUS()
      {
        return wrapped().AsUS;
      }
      private void propSetAsUS(int value)
      {
        wrapped().AsUS = value;
      }
      ///<summary>
      /// The value as 'Unsigned Short', Unsigned binary integer 16 bits long.
      ///</summary>
      public int AsUS { get { return propGetAsUS(); } set { propSetAsUS(value); } }

      ///<summary>
      /// The value as 'Signed Long', Signed binary integer
      ///</summary>
      private int propGetAsSL()
      {
        return wrapped().AsSL;
      }
      private void propSetAsSL(int value)
      {
        wrapped().AsSL = value;
      }
      ///<summary>
      /// The value as 'Signed Long', Signed binary integer
      ///</summary>
      public int AsSL { get { return propGetAsSL(); } set { propSetAsSL(value); } }

      ///<summary>
      /// The value as 'Unsigned Long', Unsigned binary integer 32 bits long.
      ///</summary>
      private uint propGetAsUL()
      {
        return wrapped().AsUL;
      }
      private void propSetAsUL(uint value)
      {
        wrapped().AsUL = value;
      }
      ///<summary>
      /// The value as 'Unsigned Long', Unsigned binary integer 32 bits long.
      ///</summary>
      public uint AsUL { get { return propGetAsUL(); } set { propSetAsUL(value); } }

      ///<summary>
      /// The value as 'Floating Point Single', Single precision binary floating point number.
      ///</summary>
      private double propGetAsFL()
      {
        return wrapped().AsFL;
      }
      private void propSetAsFL(double value)
      {
        wrapped().AsFL = value;
      }
      ///<summary>
      /// The value as 'Floating Point Single', Single precision binary floating point number.
      ///</summary>
      public double AsFL { get { return propGetAsFL(); } set { propSetAsFL(value); } }

      ///<summary>
      /// The value as 'Floating Point Double', Double precision binary floating point number
      ///</summary>
      private double propGetAsFD()
      {
        return wrapped().AsFD;
      }
      private void propSetAsFD(double value)
      {
        wrapped().AsFD = value;
      }
      ///<summary>
      /// The value as 'Floating Point Double', Double precision binary floating point number
      ///</summary>
      public double AsFD { get { return propGetAsFD(); } set { propSetAsFD(value); } }

    }

    ///<summary>
    ///</summary>
    public class ValueList : HL7Connect.Utils.Base
    {

      internal ValueList(IDicomValueList com) : base(com) {} 

      internal new HCDicomValueList wrapped() { return (HCDicomValueList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Facade to access PossibleTypes in script, which is a list of possible types for these values
      ///</summary>
      public IList<String> GetPossibleTypes()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().GetPossibleTypes());
      }

      ///<summary>
      /// Add a IDicomValue to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.Value Append()
      {
        return HL7Connect.Dicom.WrapperFactory.Value(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomValue to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.Value value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.Value value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomValue before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.Value Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Value(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomValue before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.Value value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomValue. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.Value Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Value(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomValue. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.Value value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      /// -- List of possible Value Representation (VR) type 
      /// 
      /// dvtCSdvtSHdvtLOdvtSTdvtLTdvtUTdvtAEdvtPNdvtUIdvtDAdvtTMdvtDTdvtASdvtISdvtDSdvtSSdvtUSdvtSLdvtULdvtATdvtFLdvtFDdvtOBdvtOWdvtOFdvtUN
      ///</summary>
      private TDicomVRType propGetKnownType()
      {
        return wrapped().KnownType;
      }
      ///<summary>
      /// -- List of possible Value Representation (VR) type 
      /// 
      /// dvtCSdvtSHdvtLOdvtSTdvtLTdvtUTdvtAEdvtPNdvtUIdvtDAdvtTMdvtDTdvtASdvtISdvtDSdvtSSdvtUSdvtSLdvtULdvtATdvtFLdvtFDdvtOBdvtOWdvtOFdvtUN
      ///</summary>
      public TDicomVRType KnownType { get { return propGetKnownType(); } }

      ///<summary>
      /// The dictionary in used
      ///</summary>
      private HL7Connect.Dicom.Dictionary propGetDictionary()
      {
        return HL7Connect.Dicom.WrapperFactory.Dictionary(wrapped().Dictionary);
      }
      ///<summary>
      /// The dictionary in used
      ///</summary>
      public HL7Connect.Dicom.Dictionary Dictionary { get { return propGetDictionary(); } }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.Value GetValues(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Value(wrapped().get_Values(iIndex));
      }
    }

    ///<summary>
    /// A simple DICOM string
    ///</summary>
    public class DicomString : HL7Connect.Utils.Base
    {

      internal DicomString(IDicomString com) : base(com) {} 

      internal new HCDicomString wrapped() { return (HCDicomString) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Return the string as cardinal number, or 0 if not a cardinal number
      ///</summary>
      public uint AsCardinal()
      {
        return wrapped().AsCardinal();
      }

      ///<summary>
      /// The actual string value
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      ///<summary>
      /// The actual string value
      ///</summary>
      public string Value { get { return propGetValue(); } }

    }

    ///<summary>
    /// A list of Dicom string
    ///</summary>
    public class DicomStringList : HL7Connect.Utils.Base
    {

      internal DicomStringList(IDicomStringList com) : base(com) {} 

      internal new HCDicomStringList wrapped() { return (HCDicomStringList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomString to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.DicomString Append()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomString to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.DicomString value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DicomString value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomString before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DicomString Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomString before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.DicomString value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomString. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DicomString Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomString. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.DicomString value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DicomString GetChildren(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().get_Children(iIndex));
      }
    }

    ///<summary>
    /// A data element, which is a unit of information in an object definition 
    /// 
    /// A Data Set (i.e. DicomObject) represents an instance of a real world Information Object.  A Data Set is constructed of Data Elements. Data Elements contain the encoded Values of Attributes of that object. The specific content  and semantics of these Attributes are specified in Information Object Definitions (see PS 3.3).  A Data Element is uniquely identified by a Data Element Tag. The Data Elements  in a Data Set shall be ordered by increasing Data Element Tag Number  and shall occur at most once in a Data Set. NOTE: Different to DictElement, which represent a data element definition, DataElement is an actual data object (i.e. with value(s).)
    ///</summary>
    public class DataElement : HL7Connect.Utils.Base
    {

      internal DataElement(IDicomDataElement com) : base(com) {} 

      internal new HCDicomDataElement wrapped() { return (HCDicomDataElement) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The size of the element when parsed. 
      /// 
      /// The size will be 0 if the element is being built instead of parsed. The size of the element may be wrong if script has modified it's contents after parsing
      ///</summary>
      public uint Size()
      {
        return wrapped().Size();
      }

      ///<summary>
      /// The group Id of the element tag
      ///</summary>
      private int propGetGroupId()
      {
        return wrapped().GroupId;
      }
      ///<summary>
      /// The group Id of the element tag
      ///</summary>
      public int GroupId { get { return propGetGroupId(); } }

      ///<summary>
      /// The element id of the element tag
      ///</summary>
      private int propGetElementId()
      {
        return wrapped().ElementId;
      }
      ///<summary>
      /// The element id of the element tag
      ///</summary>
      public int ElementId { get { return propGetElementId(); } }

      ///<summary>
      /// The dictionary used to decode this element
      ///</summary>
      private HL7Connect.Dicom.Dictionary propGetDictionary()
      {
        return HL7Connect.Dicom.WrapperFactory.Dictionary(wrapped().Dictionary);
      }
      ///<summary>
      /// The dictionary used to decode this element
      ///</summary>
      public HL7Connect.Dicom.Dictionary Dictionary { get { return propGetDictionary(); } }

      ///<summary>
      /// The object model definition of this element
      ///</summary>
      private HL7Connect.Dicom.DictElement propGetElementDefinition()
      {
        return HL7Connect.Dicom.WrapperFactory.DictElement(wrapped().ElementDefinition);
      }
      ///<summary>
      /// The object model definition of this element
      ///</summary>
      public HL7Connect.Dicom.DictElement ElementDefinition { get { return propGetElementDefinition(); } }

      ///<summary>
      /// True if this data element is not a sequence
      ///</summary>
      private bool propGetIsSimple()
      {
        return wrapped().IsSimple != 0;
      }
      ///<summary>
      /// True if this data element is not a sequence
      ///</summary>
      public bool IsSimple { get { return propGetIsSimple(); } }

      ///<summary>
      /// List of data values contained in this element
      ///</summary>
      private HL7Connect.Dicom.ValueList propGetValues()
      {
        return HL7Connect.Dicom.WrapperFactory.ValueList(wrapped().Values);
      }
      ///<summary>
      /// List of data values contained in this element
      ///</summary>
      public HL7Connect.Dicom.ValueList Values { get { return propGetValues(); } }

      ///<summary>
      /// If this is a sequence, it would contain a list of DICOM objects
      ///</summary>
      private HL7Connect.Dicom.DicomObjectList propGetObjects()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObjectList(wrapped().Objects);
      }
      ///<summary>
      /// If this is a sequence, it would contain a list of DICOM objects
      ///</summary>
      public HL7Connect.Dicom.DicomObjectList Objects { get { return propGetObjects(); } }

    }

    ///<summary>
    /// A list of Dicom data element instance
    ///</summary>
    public class DataElementList : HL7Connect.Utils.Base
    {

      internal DataElementList(IDicomDataElementList com) : base(com) {} 

      internal new HCDicomDataElementList wrapped() { return (HCDicomDataElementList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Sorted data elements by their tags (i.e. GroupId first, then ElementId)
      ///</summary>
      public void SortedByTags()
      {
        wrapped().SortedByTags();
      }

      ///<summary>
      /// True if elements are sorted by their tags
      ///</summary>
      public bool IsSortedByTags()
      {
        return wrapped().IsSortedByTags() != 0;
      }

      ///<summary>
      /// Index of item with maching group id/element Id, -1 if not found
      ///</summary>
      public int IndexByTags(int group, int element)
      {
        return wrapped().IndexByTags(group, element);
      }

      ///<summary>
      /// True if existed item with matching group id/element id
      ///</summary>
      public bool ExistsByTags(int group, int element)
      {
        return wrapped().ExistsByTags(group, element) != 0;
      }

      ///<summary>
      /// True if existed item with matching group id/element id in format Group,Element, with hex numbers, like this: 0800,1600, or NULL if not found
      ///</summary>
      public bool ExistsByTag(string tag)
      {
        return wrapped().ExistsByTag(tag) != 0;
      }

      ///<summary>
      /// Return item with matching group id/element id, or NULL if not found
      ///</summary>
      public HL7Connect.Dicom.DataElement GetByTags(int group, int element)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().GetByTags(group, element));
      }

      ///<summary>
      /// Return item with matching group id/element id in format Group,Element, with hex numbers, like this: 0800,1600, or NULL if not found
      ///</summary>
      public HL7Connect.Dicom.DataElement GetByTag(string tag)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().GetByTag(tag));
      }

      ///<summary>
      /// Add an already existing IDicomDataElement to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.DataElement value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DataElement value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert an existing IDicomDataElement before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.DataElement value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomDataElement. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DataElement Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomDataElement. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.DataElement value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DataElement GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().get_Elements(iIndex));
      }
      ///<summary>
      /// The dictionary used in this list
      ///</summary>
      private HL7Connect.Dicom.Dictionary propGetDictionary()
      {
        return HL7Connect.Dicom.WrapperFactory.Dictionary(wrapped().Dictionary);
      }
      ///<summary>
      /// The dictionary used in this list
      ///</summary>
      public HL7Connect.Dicom.Dictionary Dictionary { get { return propGetDictionary(); } }

    }

    ///<summary>
    /// A simple DICOM object
    ///</summary>
    public class DicomObject : HL7Connect.Utils.Base
    {

      internal DicomObject(IDicomObject com) : base(com) {} 

      internal new HCDicomObject wrapped() { return (HCDicomObject) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The size of the object when parsed. 
      /// 
      /// The size will be 0 if the object is being built instead of parsed. The size of the object may be wrong if script has modified it's contents after parsing
      ///</summary>
      public uint Size()
      {
        return wrapped().Size();
      }

      ///<summary>
      /// Query a Dicom Object for one or more contained elements. Whether more than one element can be returned will depend on the query string. 
      /// 
      /// The format for query string is a repeating series of tag[filter] specifiers, with a seperator. This format is loosely based on XPath. "tag" is any dicom tag, in hex, such as 0002,0010 (which is File Transfer Syntax UID). Wild cards such as 1000,xxx0 are allowed. Also the tag value '*' is allowed, which matches any tag (and is synonymous with xxxx,xxxx) The seperator "/" means to match only immediate children of the existing set of matching node. The seperator "//" means to match any descendent element. While the query may start with a seperator, the query is always executed from the context of the current object (Unlike XPath. a starting "/" is redundant and ignored, but a starting "//" means "any descendent of the current object" The filter is a formula. The outcome from the formula can either be a boolean, a numerical value, or a list of elements. If the outcome of the formula is a boolean (e.g 0018,6011[0018,6012 = 1], select any US regions that have a spacial format of 1) then an element will be included in the match list if the formula evaluates to true for it. If the formula returns a list of data elements, then an element will be included in the match list if any of the elements in the filter formula have a value (e.g. 0018,6011[0018,6012], which selects any US region that has a specified spacial format. Finally, if the return value is a numerical value, then the value is treated as an index in the sibling list of matching elements (e.g 0018,6011[2] means the second US region). The formula can use the following operators: =, !=, &lt;&gt;, &gt;, &lt;, &lt;=, &gt;=, +, -, \, * In addition, & means string concatenation, ++ means integer addition (i.e. null if there's an error), and == means case-insensitive comparison. OIDs are treated as strings. The following formulas are defined:   position() -  the index of the element in tag match list (the list of elements that match the tag specification, irrespective of the filter)   last() - the index number of the last element in the tag match list (count() - 1)   count() - the number of tag matches   contains()   substring(value, start, end)   substring-before(value, offset)   substring-after(value, offset)   starts-with(value, possible-start-value)   ends-with(value, possible-start-value)   string-length(value)   upper-case(value)   lower-case(value)   if(test,value-if-true,value-if-false) All the values can be a nested query, a string or numerical constant, an OID, or another formula. You can combine queries using the | character.
      ///</summary>
      public HL7Connect.Dicom.DataElementList Query(string path)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElementList(wrapped().query(path));
      }

      ///<summary>
      /// A short cut method to get a simple tag as a plain string. The method will fail if { the element doesn't exist;  the element is empty;  the element has multiple values;  the element has a complex type that can't be represented as a single string (PN etc); }
      ///</summary>
      public string ElementAsString(string tagId)
      {
        return wrapped().ElementAsString(tagId);
      }

      ///<summary>
      /// List of DICOM data elements made up this DICOM object
      ///</summary>
      private HL7Connect.Dicom.DataElementList propGetElements()
      {
        return HL7Connect.Dicom.WrapperFactory.DataElementList(wrapped().Elements);
      }
      ///<summary>
      /// List of DICOM data elements made up this DICOM object
      ///</summary>
      public HL7Connect.Dicom.DataElementList Elements { get { return propGetElements(); } }

    }

    ///<summary>
    /// A list of simple DICOM objects
    ///</summary>
    public class DicomObjectList : HL7Connect.Utils.Base
    {

      internal DicomObjectList(IDicomObjectList com) : base(com) {} 

      internal new HCDicomObjectList wrapped() { return (HCDicomObjectList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomObject to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.DicomObject Append()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomObject to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.DicomObject value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.DicomObject value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomObject before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DicomObject Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomObject before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.DicomObject value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomObject. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.DicomObject Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomObject. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.DicomObject value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.DicomObject GetChildren(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().get_Children(iIndex));
      }
    }

    ///<summary>
    /// A list of simple DICOM objects
    ///</summary>
    public class PDU : HL7Connect.Utils.Base
    {

      internal PDU(IDicomPDU com) : base(com) {} 

      internal new HCDicomPDU wrapped() { return (HCDicomPDU) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The PDU type 
      /// 
      /// -- List of possible PDU types (Associate request/accept/reject, data, abort, release request/response) pduAssociateRequestpduAssociateAcceptpduAssociateRejectpduDatapduAbortpduReleaseRequestpduReleaseResponse
      ///</summary>
      private TDicomPDUType propGetPacketType()
      {
        return wrapped().PacketType;
      }
      ///<summary>
      /// The PDU type 
      /// 
      /// -- List of possible PDU types (Associate request/accept/reject, data, abort, release request/response) pduAssociateRequestpduAssociateAcceptpduAssociateRejectpduDatapduAbortpduReleaseRequestpduReleaseResponse
      ///</summary>
      public TDicomPDUType PacketType { get { return propGetPacketType(); } }

      ///<summary>
      ///</summary>
      private int propGetVersion()
      {
        return wrapped().Version;
      }
      ///<summary>
      ///</summary>
      public int Version { get { return propGetVersion(); } }

      ///<summary>
      /// The Dictionary used with this PDU
      ///</summary>
      private HL7Connect.Dicom.Dictionary propGetDictionary()
      {
        return HL7Connect.Dicom.WrapperFactory.Dictionary(wrapped().Dictionary);
      }
      ///<summary>
      /// The Dictionary used with this PDU
      ///</summary>
      public HL7Connect.Dicom.Dictionary Dictionary { get { return propGetDictionary(); } }

    }

    ///<summary>
    /// A Presentation Context defines the presentation of the data on an Association.  It provides a lower level of negotiation and one or more Presentation Contexts  can be offered and accepted per Association.  
    /// 
    /// A Presentation Context consists of three components, a Presentation Context ID,  an Abstract Syntax Name, and a list of one or more Transfer Syntax Names.  Only one Abstract Syntax shall be offered per Presentation Context. However,  multiple Transfer Syntaxes may be offered per Presentation Context,  but only one shall be accepted.
    ///</summary>
    public class PresentationContextInfo : HL7Connect.Utils.Base
    {

      internal PresentationContextInfo(IDicomPresentationContextInfo com) : base(com) {} 

      internal new HCDicomPresentationContextInfo wrapped() { return (HCDicomPresentationContextInfo) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The unique id (within this communication) of this presentation context
      ///</summary>
      private byte propGetId()
      {
        return wrapped().ID;
      }
      ///<summary>
      /// The unique id (within this communication) of this presentation context
      ///</summary>
      public byte Id { get { return propGetId(); } }

      ///<summary>
      /// The abstract syntax UID that's supported by this presentation context
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetAbstractSyntax()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().AbstractSyntax);
      }
      ///<summary>
      /// The abstract syntax UID that's supported by this presentation context
      ///</summary>
      public HL7Connect.Dicom.DicomString AbstractSyntax { get { return propGetAbstractSyntax(); } }

      ///<summary>
      /// The list of transfer syntax that're associated with this presentation context
      ///</summary>
      private HL7Connect.Dicom.DicomStringList propGetTransferSyntaxes()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomStringList(wrapped().TransferSyntaxes);
      }
      ///<summary>
      /// The list of transfer syntax that're associated with this presentation context
      ///</summary>
      public HL7Connect.Dicom.DicomStringList TransferSyntaxes { get { return propGetTransferSyntaxes(); } }

    }

    ///<summary>
    /// A list of Presentation contexts
    ///</summary>
    public class PresentationContextInfoList : HL7Connect.Utils.Base
    {

      internal PresentationContextInfoList(IDicomPresentationContextInfoList com) : base(com) {} 

      internal new HCDicomPresentationContextInfoList wrapped() { return (HCDicomPresentationContextInfoList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomPresentationContextInfo to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.PresentationContextInfo Append()
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationContextInfo(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomPresentationContextInfo to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.PresentationContextInfo value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.PresentationContextInfo value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomPresentationContextInfo before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.PresentationContextInfo Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationContextInfo(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomPresentationContextInfo before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.PresentationContextInfo value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomPresentationContextInfo. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.PresentationContextInfo Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationContextInfo(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomPresentationContextInfo. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.PresentationContextInfo value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.PresentationContextInfo GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationContextInfo(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// A presentation context info response
    ///</summary>
    public class PresentationAcceptContextInfo : HL7Connect.Utils.Base
    {

      internal PresentationAcceptContextInfo(IDicomPresentationAcceptContextInfo com) : base(com) {} 

      internal new HCDicomPresentationAcceptContextInfo wrapped() { return (HCDicomPresentationAcceptContextInfo) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The unique id (within this communication) of this presentation context
      ///</summary>
      private byte propGetId()
      {
        return wrapped().ID;
      }
      ///<summary>
      /// The unique id (within this communication) of this presentation context
      ///</summary>
      public byte Id { get { return propGetId(); } }

      ///<summary>
      /// The select transfer syntax that is deemed suitable for both communication parties
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetTransferSyntax()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().TransferSyntax);
      }
      ///<summary>
      /// The select transfer syntax that is deemed suitable for both communication parties
      ///</summary>
      public HL7Connect.Dicom.DicomString TransferSyntax { get { return propGetTransferSyntax(); } }

      ///<summary>
      /// The presentation context result 
      /// 
      /// -- List of possible presentation results  (Accept, User rejection, Provider Reject, Abstract syntax or Transfer Syntax) parAcceptparUserRejectionparProviderRejectionparAbstractSyntaxparTransferSyntax
      ///</summary>
      private TPresentationAcceptResult propGetResult()
      {
        return wrapped().Result;
      }
      ///<summary>
      /// The presentation context result 
      /// 
      /// -- List of possible presentation results  (Accept, User rejection, Provider Reject, Abstract syntax or Transfer Syntax) parAcceptparUserRejectionparProviderRejectionparAbstractSyntaxparTransferSyntax
      ///</summary>
      public TPresentationAcceptResult Result { get { return propGetResult(); } }

    }

    ///<summary>
    /// A list of Presentation contexts result
    ///</summary>
    public class PresentationAcceptContextInfoList : HL7Connect.Utils.Base
    {

      internal PresentationAcceptContextInfoList(IDicomPresentationAcceptContextInfoList com) : base(com) {} 

      internal new HCDicomPresentationAcceptContextInfoList wrapped() { return (HCDicomPresentationAcceptContextInfoList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomPresentationAcceptContextInfo to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.PresentationAcceptContextInfo Append()
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationAcceptContextInfo(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomPresentationAcceptContextInfo to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.PresentationAcceptContextInfo value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.PresentationAcceptContextInfo value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomPresentationAcceptContextInfo before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.PresentationAcceptContextInfo Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationAcceptContextInfo(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomPresentationAcceptContextInfo before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.PresentationAcceptContextInfo value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomPresentationAcceptContextInfo. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.PresentationAcceptContextInfo Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationAcceptContextInfo(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomPresentationAcceptContextInfo. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.PresentationAcceptContextInfo value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.PresentationAcceptContextInfo GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationAcceptContextInfo(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// The user information parameter, of the A-ASSOCIATE primitive, can be extended  to support the negotiation needs of DICOM Application Entities using the  Upper Layer (UL) Service. This will result in the definition of specific  user information sub-items. These sub-items shall be assigned unique  item-type values registered in PS 3.7
    ///</summary>
    public class UserData : HL7Connect.Dicom.DicomString
    {

      internal UserData(IDicomUserData com) : base(com) {} 

      internal new HCDicomUserData wrapped() { return (HCDicomUserData) com; }

      ///<summary>
      /// The Id of this user data
      ///</summary>
      private int propGetId()
      {
        return wrapped().ID;
      }
      ///<summary>
      /// The Id of this user data
      ///</summary>
      public int Id { get { return propGetId(); } }

    }

    ///<summary>
    /// A list of Presentation contexts result
    ///</summary>
    public class UserDataList : HL7Connect.Utils.Base
    {

      internal UserDataList(IDicomUserDataList com) : base(com) {} 

      internal new HCDicomUserDataList wrapped() { return (HCDicomUserDataList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomUserData to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.UserData Append()
      {
        return HL7Connect.Dicom.WrapperFactory.UserData(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomUserData to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.UserData value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.UserData value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomUserData before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.UserData Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.UserData(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomUserData before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.UserData value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomUserData. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.UserData Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.UserData(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomUserData. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.UserData value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.UserData GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.UserData(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// A request for the establishment of an association between two Application Entities (AEs)
    ///</summary>
    public class AssociateRequestPDU : HL7Connect.Dicom.PDU
    {

      internal AssociateRequestPDU(IDicomAssociateRequestPDU com) : base(com) {} 

      internal new HCDicomAssociateRequestPDU wrapped() { return (HCDicomAssociateRequestPDU) com; }

      ///<summary>
      /// This parameter identifies the Application Entity  that shall contain the  intended acceptor of the A-ASSOCIATE service. It is based on the  Destination DICOM Application Name.  The Called AE title may or may not be the same as the Receiver Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetCalledEntity()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().CalledEntity);
      }
      ///<summary>
      /// This parameter identifies the Application Entity  that shall contain the  intended acceptor of the A-ASSOCIATE service. It is based on the  Destination DICOM Application Name.  The Called AE title may or may not be the same as the Receiver Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      public HL7Connect.Dicom.DicomString CalledEntity { get { return propGetCalledEntity(); } }

      ///<summary>
      /// This parameter identifies the Application Entity (AE) that shall contain  the requestor of the A-ASSOCIATE service. It is based on the Source DICOM  Application Name.  The Calling AE title may or may not be the same as the Initiator Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetCallingEntity()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().CallingEntity);
      }
      ///<summary>
      /// This parameter identifies the Application Entity (AE) that shall contain  the requestor of the A-ASSOCIATE service. It is based on the Source DICOM  Application Name.  The Calling AE title may or may not be the same as the Initiator Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      public HL7Connect.Dicom.DicomString CallingEntity { get { return propGetCallingEntity(); } }

      ///<summary>
      /// This parameter identifies the application context proposed by the requestor.  The acceptor shall return either the same or a different name.  The returned name shall specify the application context to be used  for this association
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetApplicationContext()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().ApplicationContext);
      }
      ///<summary>
      /// This parameter identifies the application context proposed by the requestor.  The acceptor shall return either the same or a different name.  The returned name shall specify the application context to be used  for this association
      ///</summary>
      public HL7Connect.Dicom.DicomString ApplicationContext { get { return propGetApplicationContext(); } }

      ///<summary>
      /// This parameter used in an A-ASSOCIATE request or indication shall consist  of a list containing one or more presentation contexts. Each item shall   contain three components,  a presentation context identification,  an Abstract Syntax Name, and a list of one or more Transfer Syntax Names.
      ///</summary>
      private HL7Connect.Dicom.PresentationContextInfoList propGetPresentationContexts()
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationContextInfoList(wrapped().PresentationContexts);
      }
      ///<summary>
      /// This parameter used in an A-ASSOCIATE request or indication shall consist  of a list containing one or more presentation contexts. Each item shall   contain three components,  a presentation context identification,  an Abstract Syntax Name, and a list of one or more Transfer Syntax Names.
      ///</summary>
      public HL7Connect.Dicom.PresentationContextInfoList PresentationContexts { get { return propGetPresentationContexts(); } }

      ///<summary>
      /// This negotiation allows the receivers to limit the size of the  Presentation Data Values List parameters of each P-DATA Indication.  The association-requestor shall specify in the user information parameter of the A-ASSOCIATE request primitive the maximum length in bytes for  the PDV list parameter it is ready to receive in each P-DATA indication.  The association-acceptor shall ensure in its fragmentation of the DICOM  Messages that the list of PDVs included in each P-DATA request does not  exceed this maximum length. Different maximum lengths can be specified for each direction of data flow  on the association.
      ///</summary>
      private uint propGetMaxLength()
      {
        return wrapped().MaxLength;
      }
      ///<summary>
      /// This negotiation allows the receivers to limit the size of the  Presentation Data Values List parameters of each P-DATA Indication.  The association-requestor shall specify in the user information parameter of the A-ASSOCIATE request primitive the maximum length in bytes for  the PDV list parameter it is ready to receive in each P-DATA indication.  The association-acceptor shall ensure in its fragmentation of the DICOM  Messages that the list of PDVs included in each P-DATA request does not  exceed this maximum length. Different maximum lengths can be specified for each direction of data flow  on the association.
      ///</summary>
      public uint MaxLength { get { return propGetMaxLength(); } }

      ///<summary>
      /// This parameter shall be used by the requestor and the acceptor of  the association to include DICOM Application Entity user information.  Its meaning shall depend on the application context that accompanies  the primitive
      ///</summary>
      private HL7Connect.Dicom.UserDataList propGetUserData()
      {
        return HL7Connect.Dicom.WrapperFactory.UserDataList(wrapped().UserData);
      }
      ///<summary>
      /// This parameter shall be used by the requestor and the acceptor of  the association to include DICOM Application Entity user information.  Its meaning shall depend on the application context that accompanies  the primitive
      ///</summary>
      public HL7Connect.Dicom.UserDataList UserData { get { return propGetUserData(); } }

    }

    ///<summary>
    /// An association accept response for the establishment request of an association  between two Application Entities (AEs)
    ///</summary>
    public class AssociateAcceptPDU : HL7Connect.Dicom.PDU
    {

      internal AssociateAcceptPDU(IDicomAssociateAcceptPDU com) : base(com) {} 

      internal new HCDicomAssociateAcceptPDU wrapped() { return (HCDicomAssociateAcceptPDU) com; }

      ///<summary>
      /// This parameter identifies the Application Entity  that shall contain the  intended acceptor of the A-ASSOCIATE service. It is based on the  Destination DICOM Application Name.  The Called AE title may or may not be the same as the Receiver Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetCalledEntity()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().CalledEntity);
      }
      ///<summary>
      /// This parameter identifies the Application Entity  that shall contain the  intended acceptor of the A-ASSOCIATE service. It is based on the  Destination DICOM Application Name.  The Called AE title may or may not be the same as the Receiver Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      public HL7Connect.Dicom.DicomString CalledEntity { get { return propGetCalledEntity(); } }

      ///<summary>
      /// This parameter identifies the Application Entity (AE) that shall contain  the requestor of the A-ASSOCIATE service. It is based on the Source DICOM  Application Name.  The Calling AE title may or may not be the same as the Initiator Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetCallingEntity()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().CallingEntity);
      }
      ///<summary>
      /// This parameter identifies the Application Entity (AE) that shall contain  the requestor of the A-ASSOCIATE service. It is based on the Source DICOM  Application Name.  The Calling AE title may or may not be the same as the Initiator Address  present in DICOM Messages exchanged over the association.
      ///</summary>
      public HL7Connect.Dicom.DicomString CallingEntity { get { return propGetCallingEntity(); } }

      ///<summary>
      /// This parameter identifies the application context proposed by the requestor.  The acceptor shall return either the same or a different name.  The returned name shall specify the application context to be used  for this association
      ///</summary>
      private HL7Connect.Dicom.DicomString propGetApplicationContext()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomString(wrapped().ApplicationContext);
      }
      ///<summary>
      /// This parameter identifies the application context proposed by the requestor.  The acceptor shall return either the same or a different name.  The returned name shall specify the application context to be used  for this association
      ///</summary>
      public HL7Connect.Dicom.DicomString ApplicationContext { get { return propGetApplicationContext(); } }

      ///<summary>
      /// This parameter used in the A-ASSOCIATE Response and Confirmation indicates  the acceptance or rejection of each of the presentation context definitions  proposed in the presentation context definition list parameter  (Section 7.1.1.13).  The Presentation Context Definition Result List parameter shall take the  form of a list of result values. There is a one to one correspondence  between each one of these result values and each of the presentation  contexts proposed in the Presentation Context Definition List parameter.  Each result value represents either "acceptance", "user-rejection", or  "provider-rejection". The values of the results are assigned by the Upper  Layer (UL) user on the response service primitive. The result values may be  sent in any order.
      ///</summary>
      private HL7Connect.Dicom.PresentationAcceptContextInfoList propGetPresentationContexts()
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationAcceptContextInfoList(wrapped().PresentationContexts);
      }
      ///<summary>
      /// This parameter used in the A-ASSOCIATE Response and Confirmation indicates  the acceptance or rejection of each of the presentation context definitions  proposed in the presentation context definition list parameter  (Section 7.1.1.13).  The Presentation Context Definition Result List parameter shall take the  form of a list of result values. There is a one to one correspondence  between each one of these result values and each of the presentation  contexts proposed in the Presentation Context Definition List parameter.  Each result value represents either "acceptance", "user-rejection", or  "provider-rejection". The values of the results are assigned by the Upper  Layer (UL) user on the response service primitive. The result values may be  sent in any order.
      ///</summary>
      public HL7Connect.Dicom.PresentationAcceptContextInfoList PresentationContexts { get { return propGetPresentationContexts(); } }

      ///<summary>
      /// the association-acceptor can specify in the user information parameter of  A-ASSOCIATE response primitive the maximum length in bytes for the PDV  list parameter it is ready to receive in each P-DATA indication.  The association-requestor shall ensure in its fragmentation of the DICOM  Messages that the list of PDVs included in each P-DATA request does not  exceed this maximum length. Different maximum lengths can be specified for each direction of data flow  on the association.
      ///</summary>
      private uint propGetMaxLength()
      {
        return wrapped().MaxLength;
      }
      ///<summary>
      /// the association-acceptor can specify in the user information parameter of  A-ASSOCIATE response primitive the maximum length in bytes for the PDV  list parameter it is ready to receive in each P-DATA indication.  The association-requestor shall ensure in its fragmentation of the DICOM  Messages that the list of PDVs included in each P-DATA request does not  exceed this maximum length. Different maximum lengths can be specified for each direction of data flow  on the association.
      ///</summary>
      public uint MaxLength { get { return propGetMaxLength(); } }

      ///<summary>
      /// This parameter shall be used by the requestor and the acceptor of  the association to include DICOM Application Entity user information.  Its meaning shall depend on the application context that accompanies  the primitive
      ///</summary>
      private HL7Connect.Dicom.UserDataList propGetUserData()
      {
        return HL7Connect.Dicom.WrapperFactory.UserDataList(wrapped().UserData);
      }
      ///<summary>
      /// This parameter shall be used by the requestor and the acceptor of  the association to include DICOM Application Entity user information.  Its meaning shall depend on the application context that accompanies  the primitive
      ///</summary>
      public HL7Connect.Dicom.UserDataList UserData { get { return propGetUserData(); } }

    }

    ///<summary>
    /// An association reject response for the establishment request of an association  between two Application Entities (AEs)
    ///</summary>
    public class AssociateRejectPDU : HL7Connect.Dicom.PDU
    {

      internal AssociateRejectPDU(IDicomAssociateRejectPDU com) : base(com) {} 

      internal new HCDicomAssociateRejectPDU wrapped() { return (HCDicomAssociateRejectPDU) com; }

      ///<summary>
      /// This parameter shall be provided either by the acceptor of the A-ASSOCIATE  request, or by the Upper Layer (UL) service-provider. It shall indicate  the result of using the A-ASSOCIATE service. 
      /// 
      /// -- List of possible association reject types (permantent or transient) RejectedPermanentRejectedTransient
      ///</summary>
      private TDicomAssociateRejectResult propGetResult()
      {
        return wrapped().Result;
      }
      ///<summary>
      /// This parameter shall be provided either by the acceptor of the A-ASSOCIATE  request, or by the Upper Layer (UL) service-provider. It shall indicate  the result of using the A-ASSOCIATE service. 
      /// 
      /// -- List of possible association reject types (permantent or transient) RejectedPermanentRejectedTransient
      ///</summary>
      public TDicomAssociateRejectResult Result { get { return propGetResult(); } }

      ///<summary>
      /// The value of the parameter is supplied by the Upper Layer (UL)  service-provider. It identifies the creating source of the Result parameter  and the Diagnostic parameter, if present. 
      /// 
      /// -- List of possible association reject source (user, acse or presentation) RejectedUserRejectedACSERejectedPresentation
      ///</summary>
      private TDicomAssociateRejectSource propGetSource()
      {
        return wrapped().Source;
      }
      ///<summary>
      /// The value of the parameter is supplied by the Upper Layer (UL)  service-provider. It identifies the creating source of the Result parameter  and the Diagnostic parameter, if present. 
      /// 
      /// -- List of possible association reject source (user, acse or presentation) RejectedUserRejectedACSERejectedPresentation
      ///</summary>
      public TDicomAssociateRejectSource Source { get { return propGetSource(); } }

      ///<summary>
      /// It shall be used to provide diagnostic information about the result of the  A-ASSOCIATE service (i.e. reason to reject) 
      /// 
      /// -- List of possible association reject reasons (No reason, not support, calling AE Not known, Protocol version not support, temporary congestion or local limit exceeded) RejectNoReasonAppContextNotSupportedCallingAENotKnownCalledAENotKnownProtocolVersionNotSupportedTemporaryCongestionLocalLimitExceeded
      ///</summary>
      private TDicomAssociateRejectReason propGetReason()
      {
        return wrapped().Reason;
      }
      ///<summary>
      /// It shall be used to provide diagnostic information about the result of the  A-ASSOCIATE service (i.e. reason to reject) 
      /// 
      /// -- List of possible association reject reasons (No reason, not support, calling AE Not known, Protocol version not support, temporary congestion or local limit exceeded) RejectNoReasonAppContextNotSupportedCallingAENotKnownCalledAENotKnownProtocolVersionNotSupportedTemporaryCongestionLocalLimitExceeded
      ///</summary>
      public TDicomAssociateRejectReason Reason { get { return propGetReason(); } }

    }

    ///<summary>
    /// DICOM Messages are encapsulated in P-DATA request primitives as the user data  of Presentation Data Values (PDV). A DICOM Message is fragmented in Command Fragments and Data Fragments, each placed in a PDV. The same presentation context shall be used for every fragment of the same message (i.e. same Presentation Context ID for the user data of the PDVs containing the fragments of a same message)
    ///</summary>
    public class PresentationDataValue : HL7Connect.Utils.Base
    {

      internal PresentationDataValue(IDicomPresentationDataValue com) : base(com) {} 

      internal new HCDicomPresentationDataValue wrapped() { return (HCDicomPresentationDataValue) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Whether the fragment is of the Command or Data type
      ///</summary>
      private bool propGetCommand()
      {
        return wrapped().Command != 0;
      }
      ///<summary>
      /// Whether the fragment is of the Command or Data type
      ///</summary>
      public bool Command { get { return propGetCommand(); } }

      ///<summary>
      /// Whether the fragment is or is not the last fragment of a Command/Data Stream of a DICOM Message
      ///</summary>
      private bool propGetLast()
      {
        return wrapped().Last != 0;
      }
      ///<summary>
      /// Whether the fragment is or is not the last fragment of a Command/Data Stream of a DICOM Message
      ///</summary>
      public bool Last { get { return propGetLast(); } }

    }

    ///<summary>
    /// A list of Presentation Data Values (PDV)
    ///</summary>
    public class PresentationDataValueList : HL7Connect.Utils.Base
    {

      internal PresentationDataValueList(IDicomPresentationDataValueList com) : base(com) {} 

      internal new HCDicomPresentationDataValueList wrapped() { return (HCDicomPresentationDataValueList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomPresentationDataValue to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.PresentationDataValue Append()
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationDataValue(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomPresentationDataValue to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.PresentationDataValue value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.PresentationDataValue value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomPresentationDataValue before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.PresentationDataValue Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationDataValue(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomPresentationDataValue before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.PresentationDataValue value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomPresentationDataValue. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.PresentationDataValue Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationDataValue(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomPresentationDataValue. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.PresentationDataValue value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.PresentationDataValue GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationDataValue(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// This Presentation P-DATA Service shall be used by either AE to cause the exchange of application information (i.e. DICOM Messages). DICOM Messages shall be exchanged as defined in PS 3.7. An association provides a simultaneous bi-directional exchange of P-DATA request/indication primitives.
    ///</summary>
    public class DataPDU : HL7Connect.Dicom.PDU
    {

      internal DataPDU(IDicomDataPDU com) : base(com) {} 

      internal new HCDicomDataPDU wrapped() { return (HCDicomDataPDU) com; }

      ///<summary>
      /// The same presentation context id that is applied to all Presentation Data Values (PDV) in this PDU
      ///</summary>
      private byte propGetContextId()
      {
        return wrapped().ContextId;
      }
      ///<summary>
      /// The same presentation context id that is applied to all Presentation Data Values (PDV) in this PDU
      ///</summary>
      public byte ContextId { get { return propGetContextId(); } }

      ///<summary>
      /// The list of Presentation Data Values (PDV) that contains the message fragments
      ///</summary>
      private HL7Connect.Dicom.PresentationDataValueList propGetDataValues()
      {
        return HL7Connect.Dicom.WrapperFactory.PresentationDataValueList(wrapped().DataValues);
      }
      ///<summary>
      /// The list of Presentation Data Values (PDV) that contains the message fragments
      ///</summary>
      public HL7Connect.Dicom.PresentationDataValueList DataValues { get { return propGetDataValues(); } }

    }

    ///<summary>
    /// The graceful release of an association between two AEs shall be performed through ACSE A-RELEASE request/response primitives. This is the request.
    ///</summary>
    public class ReleaseRequestPDU : HL7Connect.Dicom.PDU
    {

      internal ReleaseRequestPDU(IDicomReleaseRequestPDU com) : base(com) {} 

      internal new HCDicomReleaseRequestPDU wrapped() { return (HCDicomReleaseRequestPDU) com; }

    }

    ///<summary>
    /// The graceful release of an association between two AEs shall be performed  through ACSE A-RELEASE request/response primitives.  This is the response.
    ///</summary>
    public class ReleaseResponsePDU : HL7Connect.Dicom.PDU
    {

      internal ReleaseResponsePDU(IDicomReleaseResponsePDU com) : base(com) {} 

      internal new HCDicomReleaseResponsePDU wrapped() { return (HCDicomReleaseResponsePDU) com; }

    }

    ///<summary>
    /// The ACSE A-ABORT service shall be used by a requestor in either of the AEs  to cause the abnormal release of the association. It shall be a non-confirmed  service. However, because of the possibility of an A-ABORT service procedure  collision, the delivery of the indication primitive is not guaranteed. Should  such a collision occur, both AEs are aware that the association has been terminated.
    ///</summary>
    public class AbortPDU : HL7Connect.Dicom.PDU
    {

      internal AbortPDU(IDicomAbortPDU com) : base(com) {} 

      internal new HCDicomAbortPDU wrapped() { return (HCDicomAbortPDU) com; }

      ///<summary>
      /// This parameter indicates the initiating source of  this abort. It shall take one of the following symbolic values:  a)  UL service-user  b)  UL service-provider (ACSE related)  
      /// 
      /// -- List of possible PDU types (by User or Provider) abortUserabortProvider
      ///</summary>
      private TDicomAbortSource propGetSource()
      {
        return wrapped().Source;
      }
      ///<summary>
      /// This parameter indicates the initiating source of  this abort. It shall take one of the following symbolic values:  a)  UL service-user  b)  UL service-provider (ACSE related)  
      /// 
      /// -- List of possible PDU types (by User or Provider) abortUserabortProvider
      ///</summary>
      public TDicomAbortSource Source { get { return propGetSource(); } }

      ///<summary>
      /// Provide a diagnostic reason for the abort 
      /// 
      /// -- List of possible abort reasons (Not specified, unrecognised PDU, unexpected PDU, unregconised parameter, unexpected parameter, invalid parameter) abortNotSpecifiedabortUnrecognisedPDUabortUnexpectedPDUabortUnrecognisedParameterabortUnexpectedParameterabortInvalidParameter
      ///</summary>
      private TDicomAbortReason propGetReason()
      {
        return wrapped().Reason;
      }
      ///<summary>
      /// Provide a diagnostic reason for the abort 
      /// 
      /// -- List of possible abort reasons (Not specified, unrecognised PDU, unexpected PDU, unregconised parameter, unexpected parameter, invalid parameter) abortNotSpecifiedabortUnrecognisedPDUabortUnexpectedPDUabortUnrecognisedParameterabortUnexpectedParameterabortInvalidParameter
      ///</summary>
      public TDicomAbortReason Reason { get { return propGetReason(); } }

    }

    ///<summary>
    /// The DICOM File Format provides a means to encapsulate in a file the  Data Set representing a SOP Instance related to a DICOM IOD. The byte stream  of the Data Set is placed into the file after the DICOM File Meta Information.   Each file contains a single SOP Instance.
    ///</summary>
    public class DicomFile : HL7Connect.Utils.Base
    {

      internal DicomFile(IDicomFile com) : base(com) {} 

      internal new HCDicomFile wrapped() { return (HCDicomFile) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// This is a 2-byte field where each bit identifies a version of this File Meta Information hea- der. In current DICOM version, the first byte value is 00H and the second byte value is 01H Media Storage
      ///</summary>
      public int FileMetaInformation()
      {
        return wrapped().FileMetaInformation();
      }

      ///<summary>
      /// Uniquely identifies the SOP Class associated with the DICOM data object. The value of this element is based on the image modality type; in other words, it should contain the C- Store SOP for image modality (see 7.3)
      ///</summary>
      public string SOPClassUID()
      {
        return wrapped().SOPClassUID();
      }

      ///<summary>
      /// Uniquely identifies the SOP Instance associated with the DICOM data object placed in the file and following the File Meta Information. This value comes from the Image SOP
      ///</summary>
      public string MediaStorageSOPInstanceUID()
      {
        return wrapped().MediaStorageSOPInstanceUID();
      }

      ///<summary>
      /// UI Uniquely identifies the Transfer Syntax used to encode the following data object. This Transfer Syntax does not apply to the File Meta Information
      ///</summary>
      public string TransferSyntaxUID()
      {
        return wrapped().TransferSyntaxUID();
      }

      ///<summary>
      /// Uniquely identifies the implementation that wrote the file and its content. It provides an unambiguous identification of the type of implementation that last wrote the file in the event of interchange problems Same value as used in Implementation idenï¿½ tification Item at association establishment
      ///</summary>
      public string ImplementationClassUID()
      {
        return wrapped().ImplementationClassUID();
      }

      ///<summary>
      /// Identifies a version for an Implementation Class UID using up to 16 characters. Same value as used in Implementation identification Item at association establishment
      ///</summary>
      public string ImplementationVersionName()
      {
        return wrapped().ImplementationVersionName();
      }

      ///<summary>
      /// The DICOM AET of the AE that wrote this fileï¿½s content (or last updated it). If used, it allows the source of errors to be traced in the event of media interchange problems Same value as used in Calling AET at association establishment
      ///</summary>
      public string SourceAET()
      {
        return wrapped().SourceAET();
      }

      ///<summary>
      /// The file name, may be null if this is not an actual file on storage disk
      ///</summary>
      private string propGetName()
      {
        return wrapped().Name;
      }
      ///<summary>
      /// The file name, may be null if this is not an actual file on storage disk
      ///</summary>
      public string Name { get { return propGetName(); } }

      ///<summary>
      /// A set of DICOM Meta Elements with Tags and Lengths as defined in PS3.10, Table 7.1-1
      ///</summary>
      private HL7Connect.Dicom.DicomObject propGetHeader()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().Header);
      }
      ///<summary>
      /// A set of DICOM Meta Elements with Tags and Lengths as defined in PS3.10, Table 7.1-1
      ///</summary>
      public HL7Connect.Dicom.DicomObject Header { get { return propGetHeader(); } }

      ///<summary>
      /// The contained Data Set, representing a single SOP Instance related to a single SOP Class (and corresponding IOD).
      ///</summary>
      private HL7Connect.Dicom.DicomObject propGetContent()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().content);
      }
      ///<summary>
      /// The contained Data Set, representing a single SOP Instance related to a single SOP Class (and corresponding IOD).
      ///</summary>
      public HL7Connect.Dicom.DicomObject Content { get { return propGetContent(); } }

    }

    ///<summary>
    /// A dicom message, with a command a data object (A SOP pair)
    ///</summary>
    public class Message : HL7Connect.Utils.Base
    {

      internal Message(IDicomMessage com) : base(com) {} 

      internal new HCDicomMessage wrapped() { return (HCDicomMessage) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// read the element that carries the message id in the command
      ///</summary>
      public string ReadMessageId()
      {
        return wrapped().ReadMessageId();
      }

      ///<summary>
      /// read the element that carries the patient id in the data
      ///</summary>
      public string ReadPatientId()
      {
        return wrapped().ReadPatientId();
      }

      ///<summary>
      /// read the element that carries the command id (type of command) in the command.
      ///</summary>
      public int ReadCommandId()
      {
        return wrapped().ReadCommandId();
      }

      ///<summary>
      /// read the SOP Class as specified in the command
      ///</summary>
      public string ReadSOPClass()
      {
        return wrapped().ReadSOPClass();
      }

      ///<summary>
      /// read the SOP Instance as specified in the command
      ///</summary>
      public string ReadSOPInstance()
      {
        return wrapped().ReadSOPInstance();
      }

      ///<summary>
      /// The size of the object when parsed. 
      /// 
      /// The size will be 0 if the object is being built instead of parsed. The size of the object may be wrong if script has modified it's contents after parsing
      ///</summary>
      public uint Size()
      {
        return wrapped().Size();
      }

      ///<summary>
      /// The command part of the message
      ///</summary>
      private HL7Connect.Dicom.DicomObject propGetCommand()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().Command);
      }
      ///<summary>
      /// The command part of the message
      ///</summary>
      public HL7Connect.Dicom.DicomObject Command { get { return propGetCommand(); } }

      ///<summary>
      /// The data part of the message
      ///</summary>
      private HL7Connect.Dicom.DicomObject propGetData()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().Data);
      }
      ///<summary>
      /// The data part of the message
      ///</summary>
      public HL7Connect.Dicom.DicomObject Data { get { return propGetData(); } }

      ///<summary>
      /// The AbstractSyntax (SOP) of the message. 
      /// 
      /// Note that changing this does not change the contents of the message
      ///</summary>
      private string propGetAbstractSyntax()
      {
        return wrapped().AbstractSyntax;
      }
      private void propSetAbstractSyntax(string value)
      {
        wrapped().AbstractSyntax = value;
      }
      ///<summary>
      /// The AbstractSyntax (SOP) of the message. 
      /// 
      /// Note that changing this does not change the contents of the message
      ///</summary>
      public string AbstractSyntax { get { return propGetAbstractSyntax(); } set { propSetAbstractSyntax(value); } }

      ///<summary>
      /// The TransferSyntax (SOP) of the message. 
      /// 
      /// Note that changing this does not change the contents of the message. To change the actual transfer syntax of the message, use the DicomFactory.
      ///</summary>
      private string propGetTransferSyntax()
      {
        return wrapped().TransferSyntax;
      }
      private void propSetTransferSyntax(string value)
      {
        wrapped().TransferSyntax = value;
      }
      ///<summary>
      /// The TransferSyntax (SOP) of the message. 
      /// 
      /// Note that changing this does not change the contents of the message. To change the actual transfer syntax of the message, use the DicomFactory.
      ///</summary>
      public string TransferSyntax { get { return propGetTransferSyntax(); } set { propSetTransferSyntax(value); } }

    }

    ///<summary>
    /// A list of Presentation Data Values (PDV)
    ///</summary>
    public class DicomMessageList : HL7Connect.Utils.Base
    {

      internal DicomMessageList(IDicomMessageList com) : base(com) {} 

      internal new HCDicomMessageList wrapped() { return (HCDicomMessageList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomMessage to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.Message Append()
      {
        return HL7Connect.Dicom.WrapperFactory.Message(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomMessage to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.Message value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.Message value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomMessage before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.Message Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Message(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomMessage before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.Message value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomMessage. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.Message Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Message(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomMessage. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.Message value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.Message GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.Message(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// A dicom object instance. 
    /// 
    /// This acts as a wrapper, which could be a file object, a straight data object or one of the PDU.
    ///</summary>
    public class Instance : HL7Connect.Utils.Base
    {

      internal Instance(IDicomInstance com) : base(com) {} 

      internal new HCDicomInstance wrapped() { return (HCDicomInstance) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The DICOM object type 
      /// 
      /// -- List of DICOM instance object type ditNullditSimpleObjectditMessageditFileObjectditAssociateRequestPDUditAssociateAcceptPDUditAssociateRejectPDUditDataPDUditAbortPDUditReleaseRequestPDUditReleaseResponsePDU
      ///</summary>
      private TDicomInstanceType propGetInstanceType()
      {
        return wrapped().InstanceType;
      }
      ///<summary>
      /// The DICOM object type 
      /// 
      /// -- List of DICOM instance object type ditNullditSimpleObjectditMessageditFileObjectditAssociateRequestPDUditAssociateAcceptPDUditAssociateRejectPDUditDataPDUditAbortPDUditReleaseRequestPDUditReleaseResponsePDU
      ///</summary>
      public TDicomInstanceType InstanceType { get { return propGetInstanceType(); } }

      ///<summary>
      /// The wrapped simple DICOM object
      ///</summary>
      private HL7Connect.Dicom.DicomObject propGetSimpleObject()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().SimpleObject);
      }
      ///<summary>
      /// The wrapped simple DICOM object
      ///</summary>
      public HL7Connect.Dicom.DicomObject SimpleObject { get { return propGetSimpleObject(); } }

      ///<summary>
      /// The wrapped message (Command + Data)
      ///</summary>
      private HL7Connect.Dicom.Message propGetMessage()
      {
        return HL7Connect.Dicom.WrapperFactory.Message(wrapped().Message);
      }
      ///<summary>
      /// The wrapped message (Command + Data)
      ///</summary>
      public HL7Connect.Dicom.Message Message { get { return propGetMessage(); } }

      ///<summary>
      /// The wrapped file object
      ///</summary>
      private HL7Connect.Dicom.DicomFile propGetFileObject()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomFile(wrapped().FileObject);
      }
      ///<summary>
      /// The wrapped file object
      ///</summary>
      public HL7Connect.Dicom.DicomFile FileObject { get { return propGetFileObject(); } }

      ///<summary>
      /// The wrapped associate request
      ///</summary>
      private HL7Connect.Dicom.AssociateRequestPDU propGetAssociateRequest()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociateRequestPDU(wrapped().AssociateRequest);
      }
      ///<summary>
      /// The wrapped associate request
      ///</summary>
      public HL7Connect.Dicom.AssociateRequestPDU AssociateRequest { get { return propGetAssociateRequest(); } }

      ///<summary>
      /// The wrapped associate accept
      ///</summary>
      private HL7Connect.Dicom.AssociateAcceptPDU propGetAssociateAccept()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociateAcceptPDU(wrapped().AssociateAccept);
      }
      ///<summary>
      /// The wrapped associate accept
      ///</summary>
      public HL7Connect.Dicom.AssociateAcceptPDU AssociateAccept { get { return propGetAssociateAccept(); } }

      ///<summary>
      /// The wrapped associatie reject
      ///</summary>
      private HL7Connect.Dicom.AssociateRejectPDU propGetAssociateReject()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociateRejectPDU(wrapped().AssociateReject);
      }
      ///<summary>
      /// The wrapped associatie reject
      ///</summary>
      public HL7Connect.Dicom.AssociateRejectPDU AssociateReject { get { return propGetAssociateReject(); } }

      ///<summary>
      /// The wrapped data PDU
      ///</summary>
      private HL7Connect.Dicom.DataPDU propGetData()
      {
        return HL7Connect.Dicom.WrapperFactory.DataPDU(wrapped().Data);
      }
      ///<summary>
      /// The wrapped data PDU
      ///</summary>
      public HL7Connect.Dicom.DataPDU Data { get { return propGetData(); } }

      ///<summary>
      /// The wrapped abort PDU
      ///</summary>
      private HL7Connect.Dicom.AbortPDU propGetAbort()
      {
        return HL7Connect.Dicom.WrapperFactory.AbortPDU(wrapped().Abort);
      }
      ///<summary>
      /// The wrapped abort PDU
      ///</summary>
      public HL7Connect.Dicom.AbortPDU Abort { get { return propGetAbort(); } }

      ///<summary>
      /// The wrapped release request
      ///</summary>
      private HL7Connect.Dicom.ReleaseRequestPDU propGetReleaseRequest()
      {
        return HL7Connect.Dicom.WrapperFactory.ReleaseRequestPDU(wrapped().ReleaseRequest);
      }
      ///<summary>
      /// The wrapped release request
      ///</summary>
      public HL7Connect.Dicom.ReleaseRequestPDU ReleaseRequest { get { return propGetReleaseRequest(); } }

      ///<summary>
      /// The wrapped release response
      ///</summary>
      private HL7Connect.Dicom.ReleaseResponsePDU propGetReleaseResponse()
      {
        return HL7Connect.Dicom.WrapperFactory.ReleaseResponsePDU(wrapped().ReleaseResponse);
      }
      ///<summary>
      /// The wrapped release response
      ///</summary>
      public HL7Connect.Dicom.ReleaseResponsePDU ReleaseResponse { get { return propGetReleaseResponse(); } }

    }

    ///<summary>
    /// Used to build new instances of DICOM related classes
    ///</summary>
    public class Factory : HL7Connect.Utils.Base
    {

      internal Factory(IDicomFactory com) : base(com) {} 

      internal new HCDicomFactory wrapped() { return (HCDicomFactory) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Create a DICOM data element
      ///</summary>
      public HL7Connect.Dicom.DataElement MakeElement(string sTag, string sValue)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().MakeElement(sTag, sValue));
      }

      ///<summary>
      /// Create a custom DICOM data element
      ///</summary>
      public HL7Connect.Dicom.DataElement MakeElementCustom(string sTag, TDicomVRType aVRType, string sValue)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().MakeElementCustom(sTag, aVRType, sValue));
      }

      ///<summary>
      /// Create a complex DICOM data element
      ///</summary>
      public HL7Connect.Dicom.DataElement MakeElementComplex(string sTag)
      {
        return HL7Connect.Dicom.WrapperFactory.DataElement(wrapped().MakeElementComplex(sTag));
      }

      ///<summary>
      /// Create a Dicom Object.
      ///</summary>
      public HL7Connect.Dicom.DicomObject MakeObject()
      {
        return HL7Connect.Dicom.WrapperFactory.DicomObject(wrapped().MakeObject());
      }

      ///<summary>
      /// Create a DICOm Instance. 
      /// 
      /// This acts as a wrapper, which could be a file object, a straight data object or one of the PDU.
      ///</summary>
      public HL7Connect.Dicom.Instance MakeInstance(TDicomInstanceType aType)
      {
        return HL7Connect.Dicom.WrapperFactory.Instance(wrapped().MakeInstance(aType));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.AssocationUserData MakeAssociationUserData()
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserData(wrapped().MakeAssociationUserData());
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequest MakeAssociationContextRequest()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequest(wrapped().MakeAssociationContextRequest());
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse MakeAssociationContextResponse()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().MakeAssociationContextResponse());
      }

      ///<summary>
      /// ensure that the object has an element corresponding to the tag (add it if required) and set it's value to the provided value
      ///</summary>
      public void SetElement(HL7Connect.Dicom.DicomObject oObject, string sTag, string sValue)
      {
        wrapped().SetElement(oObject.wrapped(), sTag, sValue);
      }

      ///<summary>
      /// The Dictionary used by the DICOM factory
      ///</summary>
      private HL7Connect.Dicom.Dictionary propGetDictionary()
      {
        return HL7Connect.Dicom.WrapperFactory.Dictionary(wrapped().Dictionary);
      }
      ///<summary>
      /// The Dictionary used by the DICOM factory
      ///</summary>
      public HL7Connect.Dicom.Dictionary Dictionary { get { return propGetDictionary(); } }

    }

    ///<summary>
    /// represents a user data item on an association. 
    /// 
    /// Note that the user data $51 (81) is reserved for MaxLength, and should not put inot the user data
    ///</summary>
    public class AssocationUserData : HL7Connect.Utils.Base
    {

      internal AssocationUserData(IDicomAssocationUserData com) : base(com) {} 

      internal new HCDicomAssocationUserData wrapped() { return (HCDicomAssocationUserData) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The id of the user data item. Must be in the value range 0..255. The value $55 (85 decimal) is customarily used for the software details.
      ///</summary>
      private int propGetId()
      {
        return wrapped().ID;
      }
      private void propSetId(int value)
      {
        wrapped().ID = value;
      }
      ///<summary>
      /// The id of the user data item. Must be in the value range 0..255. The value $55 (85 decimal) is customarily used for the software details.
      ///</summary>
      public int Id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// the value of the user item.
      ///</summary>
      private string propGetValue()
      {
        return wrapped().Value;
      }
      private void propSetValue(string value)
      {
        wrapped().Value = value;
      }
      ///<summary>
      /// the value of the user item.
      ///</summary>
      public string Value { get { return propGetValue(); } set { propSetValue(value); } }

    }

    ///<summary>
    /// A list of user data items on an association
    ///</summary>
    public class AssocationUserDataList : HL7Connect.Utils.Base
    {

      internal AssocationUserDataList(IDicomAssocationUserDataList com) : base(com) {} 

      internal new HCDicomAssocationUserDataList wrapped() { return (HCDicomAssocationUserDataList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      ///</summary>
      public void Add(int Id, string Value)
      {
        wrapped().Add(Id, Value);
      }

      ///<summary>
      /// Add a IDicomAssocationUserData to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.AssocationUserData Append()
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserData(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomAssocationUserData to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.AssocationUserData value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.AssocationUserData value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomAssocationUserData before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.AssocationUserData Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserData(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomAssocationUserData before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.AssocationUserData value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomAssocationUserData. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.AssocationUserData Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserData(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomAssocationUserData. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.AssocationUserData value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.AssocationUserData GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserData(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    ///</summary>
    public class AssociationContextRequest : HL7Connect.Utils.Base
    {

      internal AssociationContextRequest(IDicomAssociationContextRequest com) : base(com) {} 

      internal new HCDicomAssociationContextRequest wrapped() { return (HCDicomAssociationContextRequest) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The id of the presentation context. Must be in the value range 0..255.
      ///</summary>
      private int propGetId()
      {
        return wrapped().ID;
      }
      private void propSetId(int value)
      {
        wrapped().ID = value;
      }
      ///<summary>
      /// The id of the presentation context. Must be in the value range 0..255.
      ///</summary>
      public int Id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// The abstract syntax for the presentation context
      ///</summary>
      private string propGetAbstractSyntax()
      {
        return wrapped().AbstractSyntax;
      }
      private void propSetAbstractSyntax(string value)
      {
        wrapped().AbstractSyntax = value;
      }
      ///<summary>
      /// The abstract syntax for the presentation context
      ///</summary>
      public string AbstractSyntax { get { return propGetAbstractSyntax(); } set { propSetAbstractSyntax(value); } }

      ///<summary>
      /// The Transfer syntaxes associated with this presentation context request
      ///</summary>
      private IList<String> propGetTransferSyntaxes()
      {
        return new HL7Connect.Utils.StringListWrapper(wrapped().TransferSyntaxes);
      }
      ///<summary>
      /// The Transfer syntaxes associated with this presentation context request
      ///</summary>
      public IList<String> TransferSyntaxes { get { return propGetTransferSyntaxes(); } }

    }

    ///<summary>
    ///</summary>
    public class AssociationContextRequestList : HL7Connect.Utils.Base
    {

      internal AssociationContextRequestList(IDicomAssociationContextRequestList com) : base(com) {} 

      internal new HCDicomAssociationContextRequestList wrapped() { return (HCDicomAssociationContextRequestList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// return highest Id of the existing contexts, or 0 if none exist
      ///</summary>
      public int HighestID()
      {
        return wrapped().HighestID();
      }

      ///<summary>
      /// return Id of context for given (abstract, transfer syntax) pair, or 0 if none exists
      ///</summary>
      public int Exists(string abstractSyntax, string transferSyntax)
      {
        return wrapped().Exists(abstractSyntax, transferSyntax);
      }

      ///<summary>
      /// Add a IDicomAssociationContextRequest to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequest Append()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequest(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomAssociationContextRequest to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.AssociationContextRequest value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.AssociationContextRequest value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomAssociationContextRequest before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequest Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequest(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomAssociationContextRequest before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.AssociationContextRequest value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomAssociationContextRequest. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequest Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequest(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomAssociationContextRequest. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.AssociationContextRequest value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      /// Get the abstract syntax given its abstract syntax id
      ///</summary>
      public string GetAbstractById(int iId)
      {
        return wrapped().GetAbstractById(iId);
      }

      ///<summary>
      /// Get the Context request object givent its abstract syntax name
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequest GetByAbstract(string sUid)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequest(wrapped().GetByAbstract(sUid));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequest GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequest(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    ///</summary>
    public class AssociationContextResponse : HL7Connect.Utils.Base
    {

      internal AssociationContextResponse(IDicomAssociationContextResponse com) : base(com) {} 

      internal new HCDicomAssociationContextResponse wrapped() { return (HCDicomAssociationContextResponse) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The id of the presentation context. Must be in the value range 0..255.
      ///</summary>
      private int propGetId()
      {
        return wrapped().ID;
      }
      private void propSetId(int value)
      {
        wrapped().ID = value;
      }
      ///<summary>
      /// The id of the presentation context. Must be in the value range 0..255.
      ///</summary>
      public int Id { get { return propGetId(); } set { propSetId(value); } }

      ///<summary>
      /// The abstract syntax for the presentation context
      ///</summary>
      private string propGetAbstractSyntax()
      {
        return wrapped().AbstractSyntax;
      }
      private void propSetAbstractSyntax(string value)
      {
        wrapped().AbstractSyntax = value;
      }
      ///<summary>
      /// The abstract syntax for the presentation context
      ///</summary>
      public string AbstractSyntax { get { return propGetAbstractSyntax(); } set { propSetAbstractSyntax(value); } }

      ///<summary>
      /// The transfer syntax that is associate with this presentation context response
      ///</summary>
      private string propGetTransferSyntax()
      {
        return wrapped().TransferSyntax;
      }
      private void propSetTransferSyntax(string value)
      {
        wrapped().TransferSyntax = value;
      }
      ///<summary>
      /// The transfer syntax that is associate with this presentation context response
      ///</summary>
      public string TransferSyntax { get { return propGetTransferSyntax(); } set { propSetTransferSyntax(value); } }

    }

    ///<summary>
    ///</summary>
    public class AssociationContextResponseList : HL7Connect.Utils.Base
    {

      internal AssociationContextResponseList(IDicomAssociationContextResponseList com) : base(com) {} 

      internal new HCDicomAssociationContextResponseList wrapped() { return (HCDicomAssociationContextResponseList) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// Add a IDicomAssociationContextResponse to the End of the list.
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse Append()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().Append());
      }

      ///<summary>
      /// Add an already existing IDicomAssociationContextResponse to the End of the list.
      ///</summary>
      public void AddItem(HL7Connect.Dicom.AssociationContextResponse value)
      {
        wrapped().AddItem(value.wrapped());
      }

      ///<summary>
      /// See if an item is already in the list. returns -1 if not in the list
      ///</summary>
      public int IndexOf(HL7Connect.Dicom.AssociationContextResponse value)
      {
        return wrapped().IndexOf(value.wrapped());
      }

      ///<summary>
      /// Insert IDicomAssociationContextResponse before the designated index (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse Insert(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().insert(iIndex));
      }

      ///<summary>
      /// Insert an existing IDicomAssociationContextResponse before the designated index (0 = first item)
      ///</summary>
      public void InsertItem(int iIndex, HL7Connect.Dicom.AssociationContextResponse value)
      {
        wrapped().InsertItem(iIndex, value.wrapped());
      }

      ///<summary>
      /// Get the iIndexth IDicomAssociationContextResponse. (0 = first item)
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse Item(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().Item(iIndex));
      }

      ///<summary>
      /// Set the iIndexth IDicomAssociationContextResponse. (0 = first item)
      ///</summary>
      public void SetItemByIndex(int iIndex, HL7Connect.Dicom.AssociationContextResponse value)
      {
        wrapped().SetItemByIndex(iIndex, value.wrapped());
      }

      ///<summary>
      /// The number of items in the collection
      ///</summary>
      public int Count()
      {
        return wrapped().Count();
      }

      ///<summary>
      /// Remove the iIndexth item. The first item is index 0.
      ///</summary>
      public void Remove(int iIndex)
      {
        wrapped().Remove(iIndex);
      }

      ///<summary>
      /// Remove All Items from the list
      ///</summary>
      public void ClearItems()
      {
        wrapped().ClearItems();
      }

      ///<summary>
      /// Add a new presentation context response
      ///</summary>
      public void Add(int Id, string sAbstract, string sTransfer)
      {
        wrapped().Add(Id, sAbstract, sTransfer);
      }

      ///<summary>
      /// Get the presentation context response with matching abstract syntax
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse GetByAbstract(string sUid)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().GetByAbstract(sUid));
      }

      ///<summary>
      /// Get the presentation context response with matching abstract syntax id
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse GetById(byte iId)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().GetById(iId));
      }

      ///<summary>
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponse GetElements(int iIndex)
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponse(wrapped().get_Elements(iIndex));
      }
    }

    ///<summary>
    /// This describes the DICOM association negotiation phase, and can be used to control how HL7Connect responds to an association request
    ///</summary>
    public class Association : HL7Connect.Utils.Base
    {

      internal Association(IDicomAssociation com) : base(com) {} 

      internal new HCDicomAssociation wrapped() { return (HCDicomAssociation) com; }

      /// <summary>
      ///   Because of the way the HL7Connect C# / COM architecture works, multiple different instances may refer to the same underlying implementation instance. All the different classes that share the same instance will have the same handle value
      /// <summary>
      public int Handle()
      {
        return wrapped().Handle();
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public string GetProperty(string Name)
      {
        return wrapped().GetCOMProperty(Name);
      }
      /// <summary>
      ///   Future extensibility capability - not used at present
      /// <summary>
      public void SetProperty(string Name, string Value)
      {
        wrapped().SetCOMProperty(Name, Value);
      }
      ///<summary>
      /// The state of the assoication - either StaWaitAssociateRequest, StaWaitAssociateResponse 
      /// 
      /// -- List of possible state of DICOM association StaIdleStaTransportOpeningStaWaitAssociateRequestStaWaitAssociateResponseStaAssociatedStaWaitReleaseResponseStaWaitTransportClose
      ///</summary>
      private TDicomAssociationState propGetState()
      {
        return wrapped().State;
      }
      private void propSetState(TDicomAssociationState value)
      {
        wrapped().State = value;
      }
      ///<summary>
      /// The state of the assoication - either StaWaitAssociateRequest, StaWaitAssociateResponse 
      /// 
      /// -- List of possible state of DICOM association StaIdleStaTransportOpeningStaWaitAssociateRequestStaWaitAssociateResponseStaAssociatedStaWaitReleaseResponseStaWaitTransportClose
      ///</summary>
      public TDicomAssociationState State { get { return propGetState(); } set { propSetState(value); } }

      ///<summary>
      /// The AT title of the user opening the connection. 
      /// 
      /// You can modify this value. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      private string propGetRequestEntity()
      {
        return wrapped().RequestEntity;
      }
      private void propSetRequestEntity(string value)
      {
        wrapped().RequestEntity = value;
      }
      ///<summary>
      /// The AT title of the user opening the connection. 
      /// 
      /// You can modify this value. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      public string RequestEntity { get { return propGetRequestEntity(); } set { propSetRequestEntity(value); } }

      ///<summary>
      /// The maximum length that the user opening the connection proposed. 
      /// 
      /// You can modify this value. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      private int propGetRequestMaxLength()
      {
        return wrapped().RequestMaxLength;
      }
      private void propSetRequestMaxLength(int value)
      {
        wrapped().RequestMaxLength = value;
      }
      ///<summary>
      /// The maximum length that the user opening the connection proposed. 
      /// 
      /// You can modify this value. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      public int RequestMaxLength { get { return propGetRequestMaxLength(); } set { propSetRequestMaxLength(value); } }

      ///<summary>
      /// The contexts that the user (client) proposed when opening the association. 
      /// 
      /// You can modify the contexts. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      private HL7Connect.Dicom.AssociationContextRequestList propGetRequestContexts()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextRequestList(wrapped().RequestContexts);
      }
      ///<summary>
      /// The contexts that the user (client) proposed when opening the association. 
      /// 
      /// You can modify the contexts. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      public HL7Connect.Dicom.AssociationContextRequestList RequestContexts { get { return propGetRequestContexts(); } }

      ///<summary>
      /// The user data that the user (client) supplied when opening the association. 
      /// 
      /// You can modify the user data. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      private HL7Connect.Dicom.AssocationUserDataList propGetRequestUserData()
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserDataList(wrapped().RequestUserData);
      }
      ///<summary>
      /// The user data that the user (client) supplied when opening the association. 
      /// 
      /// You can modify the user data. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts
      ///</summary>
      public HL7Connect.Dicom.AssocationUserDataList RequestUserData { get { return propGetRequestUserData(); } }

      ///<summary>
      /// The AE title that HL7Connect is configured to use when responding to the association request. 
      /// 
      /// You can modify this value. The modified value will be returned to the user (client) and stored for the duration of the association
      ///</summary>
      private string propGetResponseEntity()
      {
        return wrapped().ResponseEntity;
      }
      private void propSetResponseEntity(string value)
      {
        wrapped().ResponseEntity = value;
      }
      ///<summary>
      /// The AE title that HL7Connect is configured to use when responding to the association request. 
      /// 
      /// You can modify this value. The modified value will be returned to the user (client) and stored for the duration of the association
      ///</summary>
      public string ResponseEntity { get { return propGetResponseEntity(); } set { propSetResponseEntity(value); } }

      ///<summary>
      /// The maximum length that is configured to use when responding to the association request. 
      /// 
      /// You can modify this value. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts The maximum length must be greater than 20 and less than 2GB-1.
      ///</summary>
      private int propGetResponseMaxLength()
      {
        return wrapped().ResponseMaxLength;
      }
      private void propSetResponseMaxLength(int value)
      {
        wrapped().ResponseMaxLength = value;
      }
      ///<summary>
      /// The maximum length that is configured to use when responding to the association request. 
      /// 
      /// You can modify this value. The new value will replace the previous value for the duration of the association. The value is not used in HL7Connect, but is accessible in other scripts The maximum length must be greater than 20 and less than 2GB-1.
      ///</summary>
      public int ResponseMaxLength { get { return propGetResponseMaxLength(); } set { propSetResponseMaxLength(value); } }

      ///<summary>
      /// The presentation contexts that HL7Connect is configured to use when responding to this association request. 
      /// 
      /// You can modify these contexts. The modified value will be returned to the user (client) and stored for the duration of the association
      ///</summary>
      private HL7Connect.Dicom.AssociationContextResponseList propGetResponseContexts()
      {
        return HL7Connect.Dicom.WrapperFactory.AssociationContextResponseList(wrapped().ResponseContexts);
      }
      ///<summary>
      /// The presentation contexts that HL7Connect is configured to use when responding to this association request. 
      /// 
      /// You can modify these contexts. The modified value will be returned to the user (client) and stored for the duration of the association
      ///</summary>
      public HL7Connect.Dicom.AssociationContextResponseList ResponseContexts { get { return propGetResponseContexts(); } }

      ///<summary>
      /// The User Data that HL7Connect is configured to use when responding to this association request. 
      /// 
      /// Note - do not use $51 for Max length - use the response max length parameter directly You can modify these contexts. The modified value will be returned to the user (client) and stored for the duration of the association
      ///</summary>
      private HL7Connect.Dicom.AssocationUserDataList propGetResponseUserData()
      {
        return HL7Connect.Dicom.WrapperFactory.AssocationUserDataList(wrapped().ResponseUserData);
      }
      ///<summary>
      /// The User Data that HL7Connect is configured to use when responding to this association request. 
      /// 
      /// Note - do not use $51 for Max length - use the response max length parameter directly You can modify these contexts. The modified value will be returned to the user (client) and stored for the duration of the association
      ///</summary>
      public HL7Connect.Dicom.AssocationUserDataList ResponseUserData { get { return propGetResponseUserData(); } }

    }

    internal class WrapperFactory
    {
      private static Factory fWorkingFactory;
      internal static Factory WorkingFactory
      {
        get
        {
          if (fWorkingFactory == null)
            throw new Exception("You must set HL7Connect.Cda.WrapperFactory.WorkingFactory before using direct constructors of Dicom classes");
          return fWorkingFactory;
        }
        set
        {
          fWorkingFactory = value;
        }
      }
      internal static HL7Connect.Dicom.DictEntity DictEntity(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomDictionaryTransferSyntax)
          return /*4*/HL7Connect.Dicom.WrapperFactory.DictTransferSyntax(wrapped);
        else if (wrapped is HCDicomDictionarySOP)
          return /*4*/HL7Connect.Dicom.WrapperFactory.DictSOP(wrapped);
        else
          return new HL7Connect.Dicom.DictEntity((IDicomDictionaryEntity) wrapped);
      }

      internal static HL7Connect.Dicom.DictEntityList DictEntityList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomDictionaryTransferSyntaxList)
          return /*4*/HL7Connect.Dicom.WrapperFactory.DictTransferSyntaxList(wrapped);
        else if (wrapped is HCDicomDictionaryVRList)
          return /*4*/HL7Connect.Dicom.WrapperFactory.DictVRList(wrapped);
        else if (wrapped is HCDicomDictionarySOPList)
          return /*4*/HL7Connect.Dicom.WrapperFactory.DictSOPList(wrapped);
        else
          return new HL7Connect.Dicom.DictEntityList((IDicomDictionaryEntityList) wrapped);
      }

      internal static HL7Connect.Dicom.DictTransferSyntax DictTransferSyntax(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictTransferSyntax((IDicomDictionaryTransferSyntax) wrapped);
      }

      internal static HL7Connect.Dicom.DictTransferSyntaxList DictTransferSyntaxList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictTransferSyntaxList((IDicomDictionaryTransferSyntaxList) wrapped);
      }

      internal static HL7Connect.Dicom.DictVR DictVR(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictVR((IDicomDictionaryVR) wrapped);
      }

      internal static HL7Connect.Dicom.DictVRList DictVRList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictVRList((IDicomDictionaryVRList) wrapped);
      }

      internal static HL7Connect.Dicom.DictElement DictElement(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictElement((IDicomDictionaryElement) wrapped);
      }

      internal static HL7Connect.Dicom.DictElementList DictElementList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictElementList((IDicomDictionaryElementList) wrapped);
      }

      internal static HL7Connect.Dicom.DictElementGroupList DictElementGroupList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictElementGroupList((IDicomDictionaryElementGroupList) wrapped);
      }

      internal static HL7Connect.Dicom.DimseParam DimseParam(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DimseParam((IDicomDimseParam) wrapped);
      }

      internal static HL7Connect.Dicom.DimseParamList DimseParamList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DimseParamList((IDicomDimseParamList) wrapped);
      }

      internal static HL7Connect.Dicom.DimseMessage DimseMessage(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DimseMessage((IDicomDimseMessage) wrapped);
      }

      internal static HL7Connect.Dicom.DimseService DimseService(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DimseService((IDicomDimseService) wrapped);
      }

      internal static HL7Connect.Dicom.DimseServiceTypeDict DimseServiceTypeDict(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DimseServiceTypeDict((IDicomDimseServiceDict) wrapped);
      }

      internal static HL7Connect.Dicom.InfoEntry InfoEntry(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomInfoEntryReference)
          return /*4*/HL7Connect.Dicom.WrapperFactory.InfoEntryReference(wrapped);
        else if (wrapped is HCDicomInfoEntryAttr)
          return /*4*/HL7Connect.Dicom.WrapperFactory.InfoEntryAttr(wrapped);
        else
          return new HL7Connect.Dicom.InfoEntry((IDicomInfoEntry) wrapped);
      }

      internal static HL7Connect.Dicom.InfoEntryList InfoEntryList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.InfoEntryList((IDicomInfoEntryList) wrapped);
      }

      internal static HL7Connect.Dicom.InfoEntryReference InfoEntryReference(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.InfoEntryReference((IDicomInfoEntryReference) wrapped);
      }

      internal static HL7Connect.Dicom.InfoEntryAttr InfoEntryAttr(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.InfoEntryAttr((IDicomInfoEntryAttr) wrapped);
      }

      internal static HL7Connect.Dicom.InfoEntryGroup InfoEntryGroup(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomMacro)
          return /*4*/HL7Connect.Dicom.WrapperFactory.Macro(wrapped);
        else if (wrapped is HCDicomModule)
          return /*4*/HL7Connect.Dicom.WrapperFactory.Module(wrapped);
        else
          return new HL7Connect.Dicom.InfoEntryGroup((IDicomInfoGroup) wrapped);
      }

      internal static HL7Connect.Dicom.Macro Macro(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Macro((IDicomMacro) wrapped);
      }

      internal static HL7Connect.Dicom.MacroDict MacroDict(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomModuleDict)
          return /*4*/HL7Connect.Dicom.WrapperFactory.ModuleDict(wrapped);
        else
          return new HL7Connect.Dicom.MacroDict((IDicomMacroDict) wrapped);
      }

      internal static HL7Connect.Dicom.Module Module(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Module((IDicomModule) wrapped);
      }

      internal static HL7Connect.Dicom.ModuleDict ModuleDict(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.ModuleDict((IDicomModuleDict) wrapped);
      }

      internal static HL7Connect.Dicom.ModuleReference ModuleReference(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.ModuleReference((IDicomModuleReference) wrapped);
      }

      internal static HL7Connect.Dicom.ModuleReferenceList ModuleReferenceList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.ModuleReferenceList((IDicomModuleReferenceList) wrapped);
      }

      internal static HL7Connect.Dicom.IOD IOD(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.IOD((IDicomIOD) wrapped);
      }

      internal static HL7Connect.Dicom.IODDict IODDict(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.IODDict((IDicomIODDict) wrapped);
      }

      internal static HL7Connect.Dicom.DictSOP DictSOP(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictSOP((IDicomDictionarySOP) wrapped);
      }

      internal static HL7Connect.Dicom.DictSOPList DictSOPList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DictSOPList((IDicomDictionarySOPList) wrapped);
      }

      internal static HL7Connect.Dicom.Dictionary Dictionary(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Dictionary((IDicomDictionary) wrapped);
      }

      internal static HL7Connect.Dicom.Value Value(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Value((IDicomValue) wrapped);
      }

      internal static HL7Connect.Dicom.ValueList ValueList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.ValueList((IDicomValueList) wrapped);
      }

      internal static HL7Connect.Dicom.DicomString DicomString(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomUserData)
          return /*4*/HL7Connect.Dicom.WrapperFactory.UserData(wrapped);
        else
          return new HL7Connect.Dicom.DicomString((IDicomString) wrapped);
      }

      internal static HL7Connect.Dicom.DicomStringList DicomStringList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DicomStringList((IDicomStringList) wrapped);
      }

      internal static HL7Connect.Dicom.DataElement DataElement(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DataElement((IDicomDataElement) wrapped);
      }

      internal static HL7Connect.Dicom.DataElementList DataElementList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DataElementList((IDicomDataElementList) wrapped);
      }

      internal static HL7Connect.Dicom.DicomObject DicomObject(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DicomObject((IDicomObject) wrapped);
      }

      internal static HL7Connect.Dicom.DicomObjectList DicomObjectList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DicomObjectList((IDicomObjectList) wrapped);
      }

      internal static HL7Connect.Dicom.PDU PDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else if (wrapped is HCDicomAssociateRequestPDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.AssociateRequestPDU(wrapped);
        else if (wrapped is HCDicomAssociateAcceptPDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.AssociateAcceptPDU(wrapped);
        else if (wrapped is HCDicomAssociateRejectPDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.AssociateRejectPDU(wrapped);
        else if (wrapped is HCDicomDataPDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.DataPDU(wrapped);
        else if (wrapped is HCDicomReleaseRequestPDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.ReleaseRequestPDU(wrapped);
        else if (wrapped is HCDicomReleaseResponsePDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.ReleaseResponsePDU(wrapped);
        else if (wrapped is HCDicomAbortPDU)
          return /*4*/HL7Connect.Dicom.WrapperFactory.AbortPDU(wrapped);
        else
          return new HL7Connect.Dicom.PDU((IDicomPDU) wrapped);
      }

      internal static HL7Connect.Dicom.PresentationContextInfo PresentationContextInfo(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.PresentationContextInfo((IDicomPresentationContextInfo) wrapped);
      }

      internal static HL7Connect.Dicom.PresentationContextInfoList PresentationContextInfoList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.PresentationContextInfoList((IDicomPresentationContextInfoList) wrapped);
      }

      internal static HL7Connect.Dicom.PresentationAcceptContextInfo PresentationAcceptContextInfo(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.PresentationAcceptContextInfo((IDicomPresentationAcceptContextInfo) wrapped);
      }

      internal static HL7Connect.Dicom.PresentationAcceptContextInfoList PresentationAcceptContextInfoList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.PresentationAcceptContextInfoList((IDicomPresentationAcceptContextInfoList) wrapped);
      }

      internal static HL7Connect.Dicom.UserData UserData(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.UserData((IDicomUserData) wrapped);
      }

      internal static HL7Connect.Dicom.UserDataList UserDataList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.UserDataList((IDicomUserDataList) wrapped);
      }

      internal static HL7Connect.Dicom.AssociateRequestPDU AssociateRequestPDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociateRequestPDU((IDicomAssociateRequestPDU) wrapped);
      }

      internal static HL7Connect.Dicom.AssociateAcceptPDU AssociateAcceptPDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociateAcceptPDU((IDicomAssociateAcceptPDU) wrapped);
      }

      internal static HL7Connect.Dicom.AssociateRejectPDU AssociateRejectPDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociateRejectPDU((IDicomAssociateRejectPDU) wrapped);
      }

      internal static HL7Connect.Dicom.PresentationDataValue PresentationDataValue(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.PresentationDataValue((IDicomPresentationDataValue) wrapped);
      }

      internal static HL7Connect.Dicom.PresentationDataValueList PresentationDataValueList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.PresentationDataValueList((IDicomPresentationDataValueList) wrapped);
      }

      internal static HL7Connect.Dicom.DataPDU DataPDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DataPDU((IDicomDataPDU) wrapped);
      }

      internal static HL7Connect.Dicom.ReleaseRequestPDU ReleaseRequestPDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.ReleaseRequestPDU((IDicomReleaseRequestPDU) wrapped);
      }

      internal static HL7Connect.Dicom.ReleaseResponsePDU ReleaseResponsePDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.ReleaseResponsePDU((IDicomReleaseResponsePDU) wrapped);
      }

      internal static HL7Connect.Dicom.AbortPDU AbortPDU(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AbortPDU((IDicomAbortPDU) wrapped);
      }

      internal static HL7Connect.Dicom.DicomFile DicomFile(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DicomFile((IDicomFile) wrapped);
      }

      internal static HL7Connect.Dicom.Message Message(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Message((IDicomMessage) wrapped);
      }

      internal static HL7Connect.Dicom.DicomMessageList DicomMessageList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.DicomMessageList((IDicomMessageList) wrapped);
      }

      internal static HL7Connect.Dicom.Instance Instance(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Instance((IDicomInstance) wrapped);
      }

      internal static HL7Connect.Dicom.Factory Factory(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Factory((IDicomFactory) wrapped);
      }

      internal static HL7Connect.Dicom.AssocationUserData AssocationUserData(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssocationUserData((IDicomAssocationUserData) wrapped);
      }

      internal static HL7Connect.Dicom.AssocationUserDataList AssocationUserDataList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssocationUserDataList((IDicomAssocationUserDataList) wrapped);
      }

      internal static HL7Connect.Dicom.AssociationContextRequest AssociationContextRequest(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociationContextRequest((IDicomAssociationContextRequest) wrapped);
      }

      internal static HL7Connect.Dicom.AssociationContextRequestList AssociationContextRequestList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociationContextRequestList((IDicomAssociationContextRequestList) wrapped);
      }

      internal static HL7Connect.Dicom.AssociationContextResponse AssociationContextResponse(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociationContextResponse((IDicomAssociationContextResponse) wrapped);
      }

      internal static HL7Connect.Dicom.AssociationContextResponseList AssociationContextResponseList(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.AssociationContextResponseList((IDicomAssociationContextResponseList) wrapped);
      }

      internal static HL7Connect.Dicom.Association Association(object wrapped)
      {
        if (wrapped == null)
          return null;
        else
          return new HL7Connect.Dicom.Association((IDicomAssociation) wrapped);
      }

    }
  }

  #endregion Generated Code

}

